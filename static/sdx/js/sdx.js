(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

require("./modernizr");

require("./polyfills/selectedOptions");

var _Utils = require("./src/Utils");

var _LoaderBar = require("./src/loader/LoaderBar");

var LoaderBar = _interopRequireWildcard(_LoaderBar);

var _InputField = require("./src/form/InputField");

var InputFields = _interopRequireWildcard(_InputField);

var _Textarea = require("./src/form/Textarea");

var Textarea = _interopRequireWildcard(_Textarea);

var _Select = require("./src/form/Select");

var Select = _interopRequireWildcard(_Select);

var _Range = require("./src/form/Range");

var Range = _interopRequireWildcard(_Range);

var _Autocomplete = require("./src/form/Autocomplete");

var Autocomplete = _interopRequireWildcard(_Autocomplete);

var _ProgressLight = require("./src/progress/ProgressLight");

var ProgressLight = _interopRequireWildcard(_ProgressLight);

var _ProgressFull = require("./src/progress/ProgressFull");

var ProgressFull = _interopRequireWildcard(_ProgressFull);

var _Modal = require("./src/modal/Modal");

var Modal = _interopRequireWildcard(_Modal);

var _Toolbar = require("./src/toolbar/Toolbar");

var Toolbar = _interopRequireWildcard(_Toolbar);

var _Notification = require("./src/notification/Notification");

var Notification = _interopRequireWildcard(_Notification);

var _Collapse = require("./src/collapse/Collapse");

var Collapse = _interopRequireWildcard(_Collapse);

var _Accordion = require("./src/accordion/Accordion");

var Accordion = _interopRequireWildcard(_Accordion);

var _MenuFlyout = require("./src/menu/MenuFlyout");

var MenuFlyout = _interopRequireWildcard(_MenuFlyout);

var _Navigation = require("./src/navigation/Navigation");

var Navigation = _interopRequireWildcard(_Navigation);

var _NavigationSide = require("./src/navigation/NavigationSide");

var NavigationSide = _interopRequireWildcard(_NavigationSide);

var _SearchInput = require("./src/search/SearchInput");

var SearchInput = _interopRequireWildcard(_SearchInput);

var _EmptyState = require("./src/empty-states/EmptyState");

var EmptyState = _interopRequireWildcard(_EmptyState);

var _Carousel = require("./src/carousel/Carousel");

var Carousel = _interopRequireWildcard(_Carousel);

var _Table = require("./src/table/Table");

var Table = _interopRequireWildcard(_Table);

var _PieChart = require("./src/charts/PieChart");

var PieChart = _interopRequireWildcard(_PieChart);

var _BarChartHorizontal = require("./src/charts/BarChartHorizontal");

var BarChartHorizontal = _interopRequireWildcard(_BarChartHorizontal);

var _BarChartVertical = require("./src/charts/BarChartVertical");

var BarChartVertical = _interopRequireWildcard(_BarChartVertical);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* Form Components */
(0, _Utils.onDocumentReady)(function () {
  InputFields.init();
  Textarea.init();
  Select.init();
  LoaderBar.init();
  Autocomplete.init();

  ProgressLight.init();
  ProgressFull.init();

  Range.init();
  Modal.init();

  Accordion.init();
  Collapse.init();
  MenuFlyout.init();

  Navigation.init();
  NavigationSide.init();
  SearchInput.init();
  EmptyState.init();
  Carousel.init();
  Table.init();

  PieChart.init();
  BarChartHorizontal.init();
  BarChartVertical.init();
});

/* Polyfills */


var sdx = window.sdx || {};

sdx.VERSION = "1.2.0";
sdx.LoaderBar = LoaderBar.default;
sdx.Select = Select.default;
sdx.InputField = InputFields.default;
sdx.Textarea = Textarea.default;
sdx.Autocomplete = Autocomplete.default;

sdx.ProgressLight = ProgressLight.default;
sdx.ProgressFull = ProgressFull.default;

sdx.Range = Range.default;
sdx.Modal = Modal.default;
sdx.Toolbar = Toolbar.default;
sdx.Notification = Notification;

sdx.Collapse = Collapse.default;
sdx.Accordion = Accordion.default;

sdx.MenuFlyout = MenuFlyout.default;

sdx.Navigation = Navigation.default;
sdx.NavigationSide = NavigationSide.default;
sdx.SearchInput = SearchInput.default;
sdx.EmptyState = EmptyState.default;
sdx.Carousel = Carousel.default;

sdx.Table = Table.default;

sdx.PieChart = PieChart.default;
sdx.BarChartHorizontal = BarChartHorizontal.default;
sdx.BarChartVertical = BarChartVertical.default;

window.sdx = sdx;

},{"./modernizr":2,"./polyfills/selectedOptions":3,"./src/Utils":7,"./src/accordion/Accordion":8,"./src/carousel/Carousel":9,"./src/charts/BarChartHorizontal":10,"./src/charts/BarChartVertical":11,"./src/charts/PieChart":13,"./src/collapse/Collapse":14,"./src/empty-states/EmptyState":15,"./src/form/Autocomplete":16,"./src/form/InputField":17,"./src/form/Range":18,"./src/form/Select":19,"./src/form/Textarea":20,"./src/loader/LoaderBar":21,"./src/menu/MenuFlyout":22,"./src/modal/Modal":23,"./src/navigation/Navigation":24,"./src/navigation/NavigationSide":25,"./src/notification/Notification":26,"./src/progress/ProgressFull":27,"./src/progress/ProgressLight":28,"./src/search/SearchInput":29,"./src/table/Table":30,"./src/toolbar/Toolbar":31}],2:[function(require,module,exports){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * modernizr v3.5.0
 * Build https://modernizr.com/download?-hiddenscroll-touchevents-setclasses-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function (window, document, undefined) {
  var tests = [];

  /**
   *
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */

  var ModernizrProto = {
    // The current version, dummy
    _version: '3.5.0',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix': '',
      'enableClasses': true,
      'enableJSClass': true,
      'usePrefixes': true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function on(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function () {
        cb(self[test]);
      }, 0);
    },

    addTest: function addTest(name, fn, options) {
      tests.push({ name: name, fn: fn, options: options });
    },

    addAsyncTest: function addAsyncTest(fn) {
      tests.push({ name: null, fn: fn });
    }
  };

  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function Modernizr() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();

  var classes = [];

  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */

  function is(obj, type) {
    return (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === type;
  }
  ;

  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */

  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;

        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already
            if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  ;

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */

  var docElement = document.documentElement;

  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */

  var isSVG = docElement.nodeName.toLowerCase() === 'svg';

  /**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */

  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses(classes) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    if (isSVG) {
      className = className.baseVal;
    }

    // Change `no-js` to `js` (independently of the `enableClasses` option)
    // Handle classPrefix on this too
    if (Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
      className = className.replace(reJS, '$1' + classPrefix + 'js$2');
    }

    if (Modernizr._config.enableClasses) {
      // Add the new classes
      className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      if (isSVG) {
        docElement.className.baseVal = className;
      } else {
        docElement.className = className;
      }
    }
  }

  ;

  /**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */

  function createElement() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else if (isSVG) {
      return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  }

  ;

  /**
   * getBody returns the body of a document, or an element that can stand in for
   * the body if a real body does not exist
   *
   * @access private
   * @function getBody
   * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
   * artificially created element that stands in for the body
   */

  function getBody() {
    // After page load injecting a fake body doesn't work so check if body exists
    var body = document.body;

    if (!body) {
      // Can't use the real body create a fake one.
      body = createElement(isSVG ? 'svg' : 'body');
      body.fake = true;
    }

    return body;
  }

  ;

  /**
   * injectElementWithStyles injects an element with style element and some CSS rules
   *
   * @access private
   * @function injectElementWithStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   */

  function injectElementWithStyles(rule, callback, nodes, testnames) {
    var mod = 'modernizr';
    var style;
    var ret;
    var node;
    var docOverflow;
    var div = createElement('div');
    var body = getBody();

    if (parseInt(nodes, 10)) {
      // In order not to give false positives we create a node for each test
      // This also allows the method to scale for unspecified uses
      while (nodes--) {
        node = createElement('div');
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
        div.appendChild(node);
      }
    }

    style = createElement('style');
    style.type = 'text/css';
    style.id = 's' + mod;

    // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
    // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
    (!body.fake ? div : body).appendChild(style);
    body.appendChild(div);

    if (style.styleSheet) {
      style.styleSheet.cssText = rule;
    } else {
      style.appendChild(document.createTextNode(rule));
    }
    div.id = mod;

    if (body.fake) {
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = 'hidden';
      docOverflow = docElement.style.overflow;
      docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    ret = callback(div, rule);
    // If this is done after page load we don't want to remove the body so check if body exists
    if (body.fake) {
      body.parentNode.removeChild(body);
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      // eslint-disable-next-line
      docElement.offsetHeight;
    } else {
      div.parentNode.removeChild(div);
    }

    return !!ret;
  }

  ;

  /**
   * testStyles injects an element with style element and some CSS rules
   *
   * @memberof Modernizr
   * @name Modernizr.testStyles
   * @optionName Modernizr.testStyles()
   * @optionProp testStyles
   * @access public
   * @function testStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   * @example
   *
   * `Modernizr.testStyles` takes a CSS rule and injects it onto the current page
   * along with (possibly multiple) DOM elements. This lets you check for features
   * that can not be detected by simply checking the [IDL](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Interface_development_guide/IDL_interface_rules).
   *
   * ```js
   * Modernizr.testStyles('#modernizr { width: 9px; color: papayawhip; }', function(elem, rule) {
   *   // elem is the first DOM node in the page (by default #modernizr)
   *   // rule is the first argument you supplied - the CSS rule in string form
   *
   *   addTest('widthworks', elem.style.width === '9px')
   * });
   * ```
   *
   * If your test requires multiple nodes, you can include a third argument
   * indicating how many additional div elements to include on the page. The
   * additional nodes are injected as children of the `elem` that is returned as
   * the first argument to the callback.
   *
   * ```js
   * Modernizr.testStyles('#modernizr {width: 1px}; #modernizr2 {width: 2px}', function(elem) {
   *   document.getElementById('modernizr').style.width === '1px'; // true
   *   document.getElementById('modernizr2').style.width === '2px'; // true
   *   elem.firstChild === document.getElementById('modernizr2'); // true
   * }, 1);
   * ```
   *
   * By default, all of the additional elements have an ID of `modernizr[n]`, where
   * `n` is its index (e.g. the first additional, second overall is `#modernizr2`,
   * the second additional is `#modernizr3`, etc.).
   * If you want to have more meaningful IDs for your function, you can provide
   * them as the fourth argument, as an array of strings
   *
   * ```js
   * Modernizr.testStyles('#foo {width: 10px}; #bar {height: 20px}', function(elem) {
   *   elem.firstChild === document.getElementById('foo'); // true
   *   elem.lastChild === document.getElementById('bar'); // true
   * }, 2, ['foo', 'bar']);
   * ```
   *
   */

  var testStyles = ModernizrProto.testStyles = injectElementWithStyles;

  /*!
  {
    "name": "Hidden Scrollbar",
    "property": "hiddenscroll",
    "authors": ["Oleg Korsunsky"],
    "tags": ["overlay"],
    "notes": [{
      "name": "Overlay Scrollbar description",
      "href": "https://developer.apple.com/library/mac/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_7.html#//apple_ref/doc/uid/TP40010355-SW39"
    },{
      "name": "Video example of overlay scrollbars",
      "href": "https://gfycat.com/FoolishMeaslyAtlanticsharpnosepuffer"
    }]
  }
  !*/
  /* DOC
  Detects overlay scrollbars (when scrollbars on overflowed blocks are visible). This is found most commonly on mobile and OS X.
  */

  Modernizr.addTest('hiddenscroll', function () {
    return testStyles('#modernizr {width:100px;height:100px;overflow:scroll}', function (elem) {
      return elem.offsetWidth === elem.clientWidth;
    });
  });

  /**
   * List of property values to set for css tests. See ticket #21
   * http://git.io/vUGl4
   *
   * @memberof Modernizr
   * @name Modernizr._prefixes
   * @optionName Modernizr._prefixes
   * @optionProp prefixes
   * @access public
   * @example
   *
   * Modernizr._prefixes is the internal list of prefixes that we test against
   * inside of things like [prefixed](#modernizr-prefixed) and [prefixedCSS](#-code-modernizr-prefixedcss). It is simply
   * an array of kebab-case vendor prefixes you can use within your code.
   *
   * Some common use cases include
   *
   * Generating all possible prefixed version of a CSS property
   * ```js
   * var rule = Modernizr._prefixes.join('transform: rotate(20deg); ');
   *
   * rule === 'transform: rotate(20deg); webkit-transform: rotate(20deg); moz-transform: rotate(20deg); o-transform: rotate(20deg); ms-transform: rotate(20deg);'
   * ```
   *
   * Generating all possible prefixed version of a CSS value
   * ```js
   * rule = 'display:' +  Modernizr._prefixes.join('flex; display:') + 'flex';
   *
   * rule === 'display:flex; display:-webkit-flex; display:-moz-flex; display:-o-flex; display:-ms-flex; display:flex'
   * ```
   */

  // we use ['',''] rather than an empty array in order to allow a pattern of .`join()`ing prefixes to test
  // values in feature detects to continue to work
  var prefixes = ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['', ''];

  // expose these for the plugin API. Look in the source for how to join() them against your input
  ModernizrProto._prefixes = prefixes;

  /*!
  {
    "name": "Touch Events",
    "property": "touchevents",
    "caniuse" : "touch",
    "tags": ["media", "attribute"],
    "notes": [{
      "name": "Touch Events spec",
      "href": "https://www.w3.org/TR/2013/WD-touch-events-20130124/"
    }],
    "warnings": [
      "Indicates if the browser supports the Touch Events spec, and does not necessarily reflect a touchscreen device"
    ],
    "knownBugs": [
      "False-positive on some configurations of Nokia N900",
      "False-positive on some BlackBerry 6.0 builds – https://github.com/Modernizr/Modernizr/issues/372#issuecomment-3112695"
    ]
  }
  !*/
  /* DOC
  Indicates if the browser supports the W3C Touch Events API.
  
  This *does not* necessarily reflect a touchscreen device:
  
  * Older touchscreen devices only emulate mouse events
  * Modern IE touch devices implement the Pointer Events API instead: use `Modernizr.pointerevents` to detect support for that
  * Some browsers & OS setups may enable touch APIs when no touchscreen is connected
  * Future browsers may implement other event models for touch interactions
  
  See this article: [You Can't Detect A Touchscreen](http://www.stucox.com/blog/you-cant-detect-a-touchscreen/).
  
  It's recommended to bind both mouse and touch/pointer events simultaneously – see [this HTML5 Rocks tutorial](http://www.html5rocks.com/en/mobile/touchandmouse/).
  
  This test will also return `true` for Firefox 4 Multitouch support.
  */

  // Chrome (desktop) used to lie about its support on this, but that has since been rectified: http://crbug.com/36415
  Modernizr.addTest('touchevents', function () {
    var bool;
    if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
      bool = true;
    } else {
      // include the 'heartz' as a way to have a non matching MQ to help terminate the join
      // https://git.io/vznFH
      var query = ['@media (', prefixes.join('touch-enabled),('), 'heartz', ')', '{#modernizr{top:9px;position:absolute}}'].join('');
      testStyles(query, function (node) {
        bool = node.offsetTop === 9;
      });
    }
    return bool;
  });

  // Run each test
  testRunner();

  // Remove the "no-js" class if it exists
  setClasses(classes);

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  window.Modernizr = Modernizr;

  ;
})(window, document);

},{"babel-runtime/helpers/typeof":49}],3:[function(require,module,exports){
"use strict";

try {
  Object.defineProperty(HTMLSelectElement.prototype, "selectedOptions", {
    get: function () {
      try {
        document.querySelector(":checked");
        return function () {
          return this.querySelectorAll(":checked");
        };
      } catch (e) {
        return function () {
          if (!this.multiple) {
            return this.selectedIndex >= 0 ? [this.options[this.selectedIndex]] : [];
          }
          for (var i = 0, a = []; i < this.options.length; i++) {
            if (this.options[i].selected) a.push(this.options[i]);
          }return a;
        };
      }
    }()
  });
} catch (e) {
  // Ignore errors with Object.defineProperty on Safari
  // as detection with Object.isExtensible() is not reliable.
}

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _DomFunctions = require("./DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global htmlEvents:true */

/**
 * A wrapper class for DOM Elements.
 */
var DomElement = function () {
  /**
   * Creates a new instance.
   * @param {Element} - The element to wrap.
   * @param {String} - The DOM element to create.
   */
  function DomElement(element) {
    (0, _classCallCheck3.default)(this, DomElement);

    if (typeof element === "string") {
      this.element = document.createElement(element);
    } else {
      this.element = element;
    }
  }

  /**
   * Adds the specified CSS class to the element.
   * @param {String} - The class name to add.
   * @return {DomElement} Returns the current instance for fluent chaining of calls.
   */


  (0, _createClass3.default)(DomElement, [{
    key: "addClass",
    value: function addClass(name) {
      Dom.addClass(this.element, name);
      return this;
    }

    /**
     * Removes the specified CSS class from the element.
     * @param {String} - The class name to remove.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */

  }, {
    key: "removeClass",
    value: function removeClass(name) {
      Dom.removeClass(this.element, name);
      return this;
    }
  }, {
    key: "hasClass",
    value: function hasClass(name) {
      return Dom.hasClass(this.element, name);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(name) {
      Dom.toggleClass(this.element, name);
      return this;
    }
  }, {
    key: "setId",
    value: function setId(id) {
      this.element.setAttribute("id", id);
      return this;
    }
  }, {
    key: "setHtml",
    value: function setHtml(value) {
      if (typeof value !== "string") {
        throw new Error("Expected HTML string");
      }

      this.element.innerHTML = value;
      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      return this.element.getAttribute(name);
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      this.element.setAttribute(name, value);
      return this;
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(name, event) {
      this.element.addEventListener(name, event);
    }
  }, {
    key: "appendChild",
    value: function appendChild(newChild) {
      if (!(newChild instanceof DomElement)) {
        throw new Error("Only other DomElements can be added as children");
      }

      this.element.appendChild(newChild.element);
      return this;
    }
  }, {
    key: "prependChild",
    value: function prependChild(newChild) {
      if (!(newChild instanceof DomElement)) {
        throw new Error("Only other DomElements can be added as children");
      }

      this.element.insertBefore(newChild.element, this.element.firstChild);
      return this;
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newChild) {
      if (!(newChild instanceof DomElement)) {
        throw new Error("Only other DomElements can be added as children");
      }

      this.element.parentNode.insertBefore(newChild.element, this.element);
      return this;
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(newChild) {
      if (!(newChild instanceof DomElement)) {
        throw new Error("Only other DomElements can be added as children");
      }

      this.element.parentNode.insertBefore(newChild.element, this.element.nextSibling);
      return this;
    }
  }, {
    key: "removeChild",
    value: function removeChild(oldChild) {
      if (!(oldChild instanceof DomElement)) {
        throw new Error("Only a DomElements child can be removed");
      }

      this.element.removeChild(oldChild.element);
    }
  }, {
    key: "find",
    value: function find(selectors) {
      var e = this.element.querySelector(selectors);
      if (e) {
        return new DomElement(e);
      }

      return undefined;
    }
  }, {
    key: "wrapWithElement",
    value: function wrapWithElement(wrapperElement) {
      this.element.parentNode.replaceChild(wrapperElement.element, this.element);
      wrapperElement.element.appendChild(this.element);

      return this;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(eventName) {
      var event = void 0;
      var el = this.element;

      if (document.createEvent) {
        event = document.createEvent("HTMLEvents");
        event.initEvent(eventName, true, true);
      } else if (document.createEventObject) {
        // IE < 9
        event = document.createEventObject();
        event.eventType = eventName;
      }
      event.eventName = eventName;
      if (el.dispatchEvent) {
        el.dispatchEvent(event);
      } else if (el.fireEvent && htmlEvents["on" + eventName]) {
        // IE < 9
        el.fireEvent("on" + event.eventType, event); // can trigger only real event (e.g. 'click')
      } else if (el[eventName]) {
        el[eventName]();
      } else if (el["on" + eventName]) {
        el["on" + eventName]();
      }
    }
  }, {
    key: "css",
    value: function css(property) {
      return Dom.css(this.element, property);
    }

    /**
     * Removes all child nodes of the current DomElement.
     */

  }, {
    key: "empty",
    value: function empty() {
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
    }
  }, {
    key: "classes",
    get: function get() {
      return this.element.classList;
    }
  }, {
    key: "innerText",
    get: function get() {
      return Dom.text(this.element);
    }
  }, {
    key: "innerHtml",
    get: function get() {
      return this.element.innerHTML;
    }
  }]);
  return DomElement;
}();

exports.default = DomElement;

},{"./DomFunctions":5,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.hasClass = hasClass;
exports.toggleClass = toggleClass;
exports.isHidden = isHidden;
exports.text = text;
exports.parentWithClass = parentWithClass;
exports.textWidth = textWidth;
exports.css = css;
exports.getAttributeReference = getAttributeReference;
exports.getRootElement = getRootElement;
exports.empty = empty;
function addClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.add(name);
}

function removeClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.remove(name);
}

function hasClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  return element.classList.contains(name);
}

function toggleClass(element, name) {
  if (typeof name !== "string") {
    throw new Error("Expected string class name");
  }

  element.classList.toggle(name);
}

/**
 * Determines if the given element is hidden from view.
 * @param {Element} Element The dom element to check.
 * @param {boolean} includeParents If set to `true` searches up the DOM and checks parent visibility as well. Defaults to `false`.
 */
function isHidden(element) {
  var includeParents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (includeParents === false) {
    var style = window.getComputedStyle(element);
    return style.display === "none" || element.offsetLeft < 0;
  }

  var result = void 0;
  while ((result = isHidden(element, false)) === false && element.parentElement) {
    element = element.parentElement;
  }

  return result;
}

/**
 * Gets the text of an element an makes sure this works on all browsers.
 */
function text(element) {
  return element.textContent || element.innerText;
}

function parentWithClass(element, className) {
  var current = element;

  while (!hasClass(current, className) && current.parentElement) {
    current = current.parentElement;
  }

  if (hasClass(current, className)) {
    return current;
  }

  return undefined;
}

function textWidth(text, font) {
  // NOTE: this width measuring algorithm is a lot faster
  // but does unfortunately not work on IE 10...

  // let canvas = document.createElement("canvas")
  // let context = canvas.getContext("2d")
  // context.font = font
  // let metrics = context.measureText(text)
  // return Math.round(metrics.width)

  var div = document.createElement("div");
  div.innerHTML = text;

  div.style.font = font;
  div.style.position = "absolute";
  div.style.left = -10000;
  div.style.right = -10000;
  div.style.visibility = "hidden";

  document.body.appendChild(div);

  var result = div.offsetWidth;
  document.body.removeChild(div);

  return result;
}

function css(element, property) {
  return window.getComputedStyle(element, null).getPropertyValue(property);
}

/**
 * Gets the single element referenced in an items data-* attribute.
 * @param {DomElement} element - The element containing the reference attribute.
 * @param {string} attribute - The name of the reference attribute.
 * @returns {DomElement} The referenced element; or `undefined` if the reference is invalid
 * or the attribute could not be found.
 */
function getAttributeReference(element, attribute) {
  var attrValue = element.getAttribute(attribute);

  if (!attrValue || attrValue === "") {
    return undefined;
  }

  return document.querySelector(attrValue);
}

/**
 * Gets the document root element (normally the body element)
 * If the document uses a sdx-container wrapper this is returned instead.
 * @returns {Element} The root dom element.
 */
function getRootElement() {
  var element = document.querySelector(".sdx-container");
  if (!element) {
    element = document.body;
  }

  return element;
}

/**
 * Removes all child nodes from the provided element.
 * @param {Element} element The Dom element
 */
function empty(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* Keyboard input keycode definitions */

var KEY_ENTER = exports.KEY_ENTER = 13;
var KEY_ESCAPE = exports.KEY_ESCAPE = 27;

// Arrow keys
var KEY_ARROW_UP = exports.KEY_ARROW_UP = 38;
var KEY_ARROW_DOWN = exports.KEY_ARROW_DOWN = 40;
var KEY_ARROW_LEFT = exports.KEY_ARROW_LEFT = 37;
var KEY_ARROW_RIGHT = exports.KEY_ARROW_RIGHT = 39;

// Page keys
var KEY_PAGE_UP = exports.KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = exports.KEY_PAGE_DOWN = 34;

// Numbers
var KEY_NR_0 = exports.KEY_NR_0 = 48;
var KEY_NR_1 = exports.KEY_NR_1 = 49;
var KEY_NR_9 = exports.KEY_NR_9 = 57;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

exports.onDocumentReady = onDocumentReady;
exports.eachElement = eachElement;
exports.searchAndInitialize = searchAndInitialize;
exports.clamp = clamp;
exports.preventDefault = preventDefault;
exports.remove = remove;
exports.find = find;
exports.msIEVersion = msIEVersion;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Calls the callback function when the document has been completely parsed.
 * @param {callback} value The callback function to execute.
 */
function onDocumentReady(callback) {
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed, false);
    window.removeEventListener("load", completed, false);
    callback();
  }

  if (document.readyState === "complete") {
    setTimeout(callback);
  } else {

    document.addEventListener("DOMContentLoaded", completed, false);

    // A fallback to window.onload, that will always work
    window.addEventListener("load", completed, false);
  }
}

function eachElement(selectors, callback) {
  if (!callback) {
    throw new Error("The callback cannot be undefined");
  }

  var elements = (0, _from2.default)(document.querySelectorAll(selectors));

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(elements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var e = _step.value;

      callback(e);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

/**
 * Searches for elements with the given selector and calls the callback
 * function if the `data-init` attribute is present on the element.
 * @param {selector} value The query.
 * @param {callback} value The callback function to initialize the element.
 * @param {function} initSelector The inititalization element selector function.
 */
function searchAndInitialize(selector, callback) {
  var initSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  if (!callback) {
    throw new Error("The callback cannot be undefined");
  }

  var elements = (0, _from2.default)(document.querySelectorAll(selector));

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)(elements), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var e = _step2.value;


      var initElement = e;

      if (initSelector) {
        initElement = initSelector(e);
      }

      if (initElement.getAttribute("data-init") === "auto") {
        callback(e);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

/**
 * Returns a number whose value is limited to the given range.
 *
 * Example: limit the output of this computation to between 0 and 255
 * Utils.clamp(number, 0, 255)
 *
 * @param {Number} value The number to clamp
 * @param {Number} min The lower boundary of the output range
 * @param {Number} max The upper boundary of the output range
 * @returns A number in the range [min, max]
 * @type Number
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * A polyfill for Event.preventDefault().
 * @param {Event} event - The event to prevent the default action.
 */
function preventDefault(event) {
  if (event.preventDefault) {
    event.preventDefault();
  } else {
    event.returnValue = false;
  }
}

/**
 * A polyfill for Node.remove().
 * @param {Node} node - The node to remove.
 */
function remove(node) {
  if (!node || !node.parentNode) {
    return;
  }

  node.parentNode.removeChild(node);
}

/**
 * A simple polyfill for the Array.find() method.
 * @param {Array} array - The array to search in.
 * @param {function} expression - The expresstion to evaluate. Must return true if the element matches.
 */
function find(array, expression) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (expression(item) === true) {
      return item;
    }
  }

  return undefined;
}

/**
 * Checks the useragent and returns the Microsoft Internet Explorer / Edge version.
 * If another browser is detected 0 is returned.
 */
function msIEVersion() {
  var userAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

  // see http://stackoverflow.com/questions/19999388/check-if-user-is-using-ie-with-jquery
  var ua = userAgent || window.navigator.userAgent;

  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }

  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }

  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    // Edge (IE 12+) => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }

  // other browser
  return 0;
}

},{"babel-runtime/core-js/array/from":32,"babel-runtime/core-js/get-iterator":33}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_TOGGLE = ".accordion__toggle";
var QUERY_OPEN_SECTION = ".accordion__item.is-open";
var QUERY_COLLAPSE = ".accordion__collapse";

var CLASS_ITEM = "accordion__item";
var CLASS_OPEN = "is-open";

var REGEX_HIDDEN = /accordion--hidden-.*/;

var ANIMATION_OPEN = 0.3;

var ANIMATION_DELAY_OPEN = 0.2;
var ANIMATION_VISIBLE_OPEN = 0.5;

var ANIMATION_VISIBLE_CLOSE = 0.1;

/**
 * The Accordion component
 */

var Accordion = function (_DomElement) {
  (0, _inherits3.default)(Accordion, _DomElement);

  /**
   * Creates and initializes the Accordion component.
   * @param {DomElement} - The root element of the Accordion component.
   */
  function Accordion(element) {
    (0, _classCallCheck3.default)(this, Accordion);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Accordion.__proto__ || (0, _getPrototypeOf2.default)(Accordion)).call(this, element));

    _this._sectionClickHandler = _this._handleSectionClick.bind(_this);
    _this._initialize();
    return _this;
  }

  /**
   * Initializes the Accordion component.
   * @private
   */


  (0, _createClass3.default)(Accordion, [{
    key: "_initialize",
    value: function _initialize() {
      if (this.element.className.split(" ").some(function (c) {
        return REGEX_HIDDEN.test(c);
      })) {
        var indicator = new _DomElement3.default("input").setAttribute("type", "hidden").addClass("js-hidden");

        this.appendChild(indicator);
        this._hiddenIndicator = indicator.element;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_TOGGLE)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var toggle = _step.value;

          toggle.addEventListener("click", this._sectionClickHandler);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_handleSectionClick",
    value: function _handleSectionClick(event) {
      if (this._hiddenIndicator) {
        var style = window.getComputedStyle(this._hiddenIndicator, null);

        if (style.visibility !== "visible") {
          return;
        }
      }

      var navSection = event.target.parentElement;

      while (!Dom.hasClass(navSection, CLASS_ITEM) && navSection.parentElement) {
        navSection = navSection.parentElement;
      }

      var prevSection = this.element.querySelector(QUERY_OPEN_SECTION);

      if (prevSection && prevSection !== navSection) {
        this._toggleSection(prevSection);
      }

      this._toggleSection(navSection);
    }
  }, {
    key: "_toggleSection",
    value: function _toggleSection(accSection) {
      var collapseElement = accSection.querySelector(QUERY_COLLAPSE);

      if (Dom.hasClass(accSection, CLASS_OPEN)) {
        Dom.removeClass(accSection, CLASS_OPEN);
        this._closeCollapseSection(collapseElement);
      } else {
        Dom.addClass(accSection, CLASS_OPEN);
        this._openCollapseSection(collapseElement);
      }
    }
  }, {
    key: "_openCollapseSection",
    value: function _openCollapseSection(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.set(el, {
        display: "block"
      });

      _gsap.TweenLite.to(el, ANIMATION_OPEN, {
        className: "+=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      _gsap.TweenLite.to(el, ANIMATION_VISIBLE_OPEN, {
        autoAlpha: 1,
        delay: ANIMATION_DELAY_OPEN
      });

      // set aria expanded
      el.setAttribute("aria-expanded", true);
    }
  }, {
    key: "_closeCollapseSection",
    value: function _closeCollapseSection(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.to(el, ANIMATION_VISIBLE_CLOSE, {
        autoAlpha: 0
      });

      _gsap.TweenLite.to(el, ANIMATION_OPEN, {
        className: "-=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut],
        onComplete: function onComplete() {
          _gsap.TweenLite.set(el, {
            clearProps: "display, visibility, opacity"
          });
        }
      });

      // set aria expanded
      el.setAttribute("aria-expanded", false);
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_TOGGLE)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var toggle = _step2.value;

          toggle.removeEventListener("click", this._sectionClickHandler);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._sectionClickHandler = null;
      this.element = null;
    }
  }]);
  return Accordion;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".accordion", function (e) {
    new Accordion(e);
  });
}

exports.default = Accordion;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _trunc = require("babel-runtime/core-js/math/trunc");

var _trunc2 = _interopRequireDefault(_trunc);

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_SLIDER = ".carousel__container";
var QUERY_SLIDE_AREA = ".carousel__slider";
var QUERY_WRAPPER = ".carousel__slider-wrapper";

var QUERY_PAGINATION = ".carousel__pagination";

var CLASS_ACTIVE = "slide--active";
var CLASS_PREV = "slide--prev";
var CLASS_NEXT = "slide--next";

var CLASS_BULLET = "pagination-bullet";
var CLASS_BULLET_ACTIVE = "pagination-bullet--active";

var QUERY_BTN_PREV = ".carousel__button-prev";
var QUERY_BTN_NEXT = ".carousel__button-next";
var QUERY_BTN_WRAPPER = ".carousel__button-wrapper";

var ATTRIBUTE_INDEX = "js-index";

var ANIMATION_DURATION = 350;
var ANIMATION_EASING = "ease-in-out";

var TOUCH_DURATION = 300;
var TOUCH_DELTA_MIN = 25;

/**
 * The carousel component definition.
 */

var Carousel = function (_DomElement) {
  (0, _inherits3.default)(Carousel, _DomElement);

  /**
   * Creates and initializes the carousel component.
   * @param {DomElement} element - The root element of the Carousel component.
   * @param {index} - The initial index.
   */
  function Carousel(element) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck3.default)(this, Carousel);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Carousel.__proto__ || (0, _getPrototypeOf2.default)(Carousel)).call(this, element));

    _this._breakpoint = undefined;
    _this._slider = _this.element.querySelector(QUERY_SLIDER);
    _this._wrapper = _this._slider.querySelector(QUERY_WRAPPER);
    _this._pagination = _this._slider.querySelector(QUERY_PAGINATION);
    _this._slideArea = _this._slider.querySelector(QUERY_SLIDE_AREA);

    _this._btnWrapper = _this.element.querySelector(QUERY_BTN_WRAPPER);
    _this._prevCtrl = _this.element.querySelector(QUERY_BTN_PREV);
    _this._nextCtrl = _this.element.querySelector(QUERY_BTN_NEXT);

    _this._container = _this.element.querySelector(QUERY_SLIDER);
    _this._slides = [];

    _this._index = index || 0;
    _this._slidesPerGroup = 1;

    _this._sliderWrapper = new SliderWrapper(_this._wrapper, _this._slideArea, _this.element);
    _this._sliderWrapper._index = _this._index;
    _this._additionalSlideMargin = 0;

    _this._resizeHandler = _this._onresize.bind(_this);
    _this._prevHandler = _this.prev.bind(_this);
    _this._nextHandler = _this.next.bind(_this);
    _this._paginationClickHandler = _this._handlePaginationClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);

    _this._handleTouchstart = _this._onTouchstart.bind(_this);
    _this._handleTouchmove = _this._onTouchmove.bind(_this);
    _this._handleTouchend = _this._onTouchend.bind(_this);

    _this._initialize();
    _this.slide(_this._index, 0, false);

    _this._updateCtrlOffsets();
    return _this;
  }

  /**
   * Initializes the carousel component.
   * @private
   */


  (0, _createClass3.default)(Carousel, [{
    key: "_initialize",
    value: function _initialize() {
      // responsive helpers
      this._breakpointPhone = new _DomElement3.default("div").addClass("js-phone").element;

      this._breakpointTablet = new _DomElement3.default("div").addClass("js-tablet").element;

      this._breakpointDesktop = new _DomElement3.default("div").addClass("js-desktop").element;

      this.element.appendChild(this._breakpointPhone);
      this.element.appendChild(this._breakpointTablet);
      this.element.appendChild(this._breakpointDesktop);

      if (this._prevCtrl && this._nextCtrl) {
        this._prevCtrl.addEventListener("click", this._prevHandler);
        this._nextCtrl.addEventListener("click", this._nextHandler);
      }

      if (this._pagination) {
        this._pagination.addEventListener("click", this._paginationClickHandler);
      }

      this._slides = (0, _from2.default)(this._wrapper.children);
      if (this._slides.length === 0) {
        throw Error("Provide at least one slide to the slider");
      }

      for (var i = 0; i < this._slides.length; i++) {
        var slide = this._slides[i];
        slide.setAttribute(ATTRIBUTE_INDEX, i);
      }

      this._updateResponsiveOptions();
      this._sliderWrapper.initialize();

      this.reset();

      this.element.addEventListener("keydown", this._keydownHandler);

      this._slideArea.addEventListener("mousedown", this._handleTouchstart);
      this._slideArea.addEventListener("touchstart", this._handleTouchstart);

      window.addEventListener("resize", this._resizeHandler);
      window.addEventListener("orientationchange", this._resizeHandler);
    }
  }, {
    key: "_isBreakpointActive",
    value: function _isBreakpointActive(breakpoint) {
      var style = window.getComputedStyle(breakpoint, null);
      return style.visibility === "visible";
    }
  }, {
    key: "_onresize",
    value: function _onresize() {
      this.reset();
      this._updateCtrlOffsets();
    }

    /**
     * Makes sure the index is always in the range of available slide
     * In case it's to high or to low it is wrapped around
     * @param {Number} index - The index to adjust and sanitize
     * @returns {Number} The adjusted index
     * @private
     */

  }, {
    key: "_adjustIndex",
    value: function _adjustIndex(index) {
      if (typeof index !== "number") {
        index = 0;
      }

      if (index < 0) {
        index = this._wrapround(index, 0, this._slides.length);
      } else if (index >= this._slides.length) {
        index %= this._slides.length;
      }

      return Math.floor(index / this._slidesPerGroup) * this._slidesPerGroup;
    }
  }, {
    key: "_wrapround",
    value: function _wrapround(n, min, max) {
      if (n >= max) {
        return min;
      }

      if (n < min) {
        return max - 1;
      }

      return n;
    }
  }, {
    key: "_wraproundCount",
    value: function _wraproundCount(a, b, min, max, direction) {
      if (direction === 0) {
        return 0;
      }

      if (a < min || a >= max) {
        throw new Error("Argument 'a' is out of range, Value: " + a + " Min: " + min + ", Max: " + max);
      }

      if (b < min || b >= max) {
        throw new Error("Argument 'b' is out of range, Value: " + b + " Min: " + min + ", Max: " + max);
      }

      var i = 0;
      while (a !== b) {
        i++;
        a = this._wrapround(a + direction, min, max);
      }

      return i;
    }
  }, {
    key: "_updateCtrlOffsets",
    value: function _updateCtrlOffsets() {
      if (!this._nextCtrl || !this._prevCtrl || !this._btnWrapper) {
        return;
      }

      var prevCtrlMargin = 0;
      var nextCtrlMargin = 0;

      if (this._slidesPerGroup > 1) {
        var wrapperRect = this._btnWrapper.getBoundingClientRect();

        var prevSlideCount = Math.floor(0.5 * this._slidesPerGroup);
        var rightIndex = this._sliderWrapper.index + prevSlideCount + 1;

        var leftIndex = this._sliderWrapper.index - 1;
        if (this._slidesPerGroup % 2 !== 0) {
          leftIndex -= prevSlideCount;
        }

        if (leftIndex >= 0 && leftIndex < this._wrapper.children.length && rightIndex >= 0 && rightIndex < this._wrapper.children.length) {
          var leftSlide = this._sliderWrapper.getSlideProperties(leftIndex);
          var rightSlide = this._sliderWrapper.getSlideProperties(rightIndex);

          var btnWidth = this._prevCtrl.offsetWidth;
          if (btnWidth <= 0) {
            btnWidth = 60;
          }

          prevCtrlMargin = leftSlide.right - wrapperRect.left - btnWidth;
          nextCtrlMargin = wrapperRect.right - rightSlide.left - btnWidth;
        }
      }

      var left = prevCtrlMargin !== 0 ? prevCtrlMargin + "px" : "";
      this._prevCtrl.style.left = left;

      var right = nextCtrlMargin !== 0 ? nextCtrlMargin + "px" : "";
      this._nextCtrl.style.right = right;
    }
  }, {
    key: "_updateActiveSlides",
    value: function _updateActiveSlides(nextIndex) {
      var prevSlideCount = Math.floor(0.5 * (this._slidesPerGroup - 1));
      var evenGroup = this._slidesPerGroup % 2 === 0;

      for (var i = 0; i < this._wrapper.children.length; i++) {
        var slide = this._wrapper.children[i];

        if (i === nextIndex || evenGroup && i === nextIndex + 1) {
          Dom.addClass(slide, CLASS_ACTIVE);
        } else {
          Dom.removeClass(slide, CLASS_ACTIVE);
        }

        if (i < nextIndex && i >= nextIndex - prevSlideCount) {
          Dom.addClass(slide, CLASS_PREV);
        } else {
          Dom.removeClass(slide, CLASS_PREV);
        }

        if (i > nextIndex && (i <= nextIndex + prevSlideCount || evenGroup && i <= nextIndex + 1 + prevSlideCount)) {
          Dom.addClass(slide, CLASS_NEXT);
        } else {
          Dom.removeClass(slide, CLASS_NEXT);
        }
      }
    }

    /**
     * Updates and creates the pagination bullets.
     * @private
     */

  }, {
    key: "_updatePagination",
    value: function _updatePagination() {
      if (!this._pagination) {
        return;
      }

      var to = this._index;

      var bullets = this._pagination.children;
      var totalItems = Math.max(this._slides.length, bullets.length);
      var slideCount = Math.ceil(this._slides.length / this._slidesPerGroup);
      var activeSlideIndex = Math.floor(to / this._slidesPerGroup);

      for (var i = 0; i < totalItems; i++) {
        var bullet = void 0;

        if (bullets.length > i) {
          if (bullets.length <= slideCount) {
            bullet = bullets[i];
          } else {
            (0, _Utils.remove)(bullets[i]);
          }
        } else if (i < slideCount) {
          bullet = new _DomElement3.default("div").addClass(CLASS_BULLET).element;
          this._pagination.appendChild(bullet);
        }

        if (bullet && i < slideCount) {
          if (i === activeSlideIndex) {
            Dom.addClass(bullet, CLASS_BULLET_ACTIVE);
          } else {
            Dom.removeClass(bullet, CLASS_BULLET_ACTIVE);
          }
        }
      }
    }
  }, {
    key: "_handlePaginationClick",
    value: function _handlePaginationClick(e) {
      if (!Dom.hasClass(e.target, CLASS_BULLET)) {
        return;
      }

      var index = (0, _from2.default)(this._pagination.children).indexOf(e.target);
      var slideNumber = index * this._slidesPerGroup;

      this.slideTo(slideNumber);
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = evt || window.event;
      var keycode = event.which || event.keyCode;

      switch (keycode) {
        case Inputs.KEY_ARROW_LEFT:
          this.prev();
          break;
        case Inputs.KEY_ARROW_RIGHT:
          this.next();
          break;
        case Inputs.KEY_ESCAPE:
          this.element.blur();
          break;
        default:
      }
    }
  }, {
    key: "_onTouchstart",
    value: function _onTouchstart(event) {
      var touches = event.touches ? event.touches[0] : event;

      this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
      this._slideArea.removeEventListener("touchstart", this._handleTouchstart);

      this._sliderWrapper.beginDrag();
      var pageX = touches.pageX;


      this._touchOffset = {
        x: pageX,
        time: Date.now()
      };

      this._delta = {
        lastMove: pageX
      };

      document.addEventListener("mousemove", this._handleTouchmove);
      document.addEventListener("touchmove", this._handleTouchmove);

      document.addEventListener("mouseup", this._handleTouchend);
      document.addEventListener("mouseleave", this._handleTouchend);
      document.addEventListener("touchend", this._handleTouchend);
    }
  }, {
    key: "_onTouchmove",
    value: function _onTouchmove(event) {
      var touches = event.touches ? event.touches[0] : event;
      var pageX = touches.pageX;


      var deltaMove = pageX - this._delta.lastMove;

      this._delta = {
        x: pageX - this._touchOffset.x,
        lastMove: pageX
      };

      if (this._touchOffset) {
        (0, _Utils.preventDefault)(event);

        this._sliderWrapper.move(deltaMove);
        this._cloneSlidesToFitWrapper(false, deltaMove);
      }
    }
  }, {
    key: "_onTouchend",
    value: function _onTouchend() {
      var duration = this._touchOffset ? Date.now() - this._touchOffset.time : undefined;

      var isValid = Number(duration) < TOUCH_DURATION && Math.abs(this._delta.x) > TOUCH_DELTA_MIN || Math.abs(this._delta.x) > this._frameWidth / 3;

      if (isValid) {
        var direction = (0, _Utils.clamp)(this._delta.x, -1, 1) * -1;
        this.slide(false, direction, true);

        this._sliderWrapper.endDrag();
      } else {
        // Slide back to the starting point of the drag operation
        this._sliderWrapper.cancelDrag();
      }

      this._touchOffset = undefined;

      this._slideArea.addEventListener("mousedown", this._handleTouchstart);
      this._slideArea.addEventListener("touchstart", this._handleTouchstart);

      document.removeEventListener("mousemove", this._handleTouchmove);
      document.removeEventListener("mouseup", this._handleTouchend);
      document.removeEventListener("mouseleave", this._handleTouchend);
      document.removeEventListener("touchmove", this._handleTouchmove);
      document.removeEventListener("touchend", this._handleTouchend);
    }

    /**
     * Updated parameters in regard to the currently active responsive
     * breakpoint.
     * @private
     */

  }, {
    key: "_updateResponsiveOptions",
    value: function _updateResponsiveOptions() {
      if (this._isBreakpointActive(this._breakpointPhone)) {
        this._slidesPerGroup = 1;
      }

      if (this._isBreakpointActive(this._breakpointTablet)) {
        this._slidesPerGroup = 2;
      }

      if (this._isBreakpointActive(this._breakpointDesktop)) {
        this._slidesPerGroup = 3;
      }

      this._groupSlidesEven = this._slidesPerGroup % 2 === 0;
      this._sliderWrapper.slidesPerGroup = this._slidesPerGroup;
    }

    /**
     * Clones the requested slide and adds it to the slider.
     * @param {Number} index - The original slide index of the template slide
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */

  }, {
    key: "_cloneSlide",
    value: function _cloneSlide(index, direction) {
      var clone = this._slides[index].cloneNode(true);
      Dom.removeClass(clone, CLASS_ACTIVE);
      Dom.removeClass(clone, CLASS_PREV);
      Dom.removeClass(clone, CLASS_NEXT);

      this._sliderWrapper.addSlide(clone, direction);

      var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
      clone.style.marginLeft = slideMargin;
      clone.style.marginRight = slideMargin;

      return clone.offsetWidth;
    }

    /**
     * Clones and adds the requested ammount of slides.
     * @param {Number} slideCount - The number of slides to add
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */

  }, {
    key: "_cloneSlidesByCount",
    value: function _cloneSlidesByCount(slideCount, direction) {
      var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
      var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);

      while (slideCount > 0) {
        index = this._wrapround(index + direction, 0, this._slides.length);
        this._cloneSlide(index, direction);
        slideCount--;
      }
    }

    /**
     * Calculates the scroll clount and inserts the required ammount of slides
     * in the apropriate direction.
     * @param {Number} nextIndex - The slide to scroll to
     * @param {Number} direction - The direction of the scroll
     * @private
     */

  }, {
    key: "_cloneSlidesByScrollCount",
    value: function _cloneSlidesByScrollCount(nextIndex, direction) {
      var scrollCount = this._wraproundCount(this._index, nextIndex, 0, this._slides.length, direction);

      var outerSlideProps = this._sliderWrapper.getSlideProperties(direction > 0 ? this._wrapper.children.length - 1 : 0);
      var indexToOuterSlideCount = this._wraproundCount(this._index, outerSlideProps.index, 0, this._slides.length, direction);

      var slidesToInsert = scrollCount - indexToOuterSlideCount;
      if (slidesToInsert > 0) {
        this._cloneSlidesByCount(slidesToInsert, direction);
      }
    }
  }, {
    key: "_cloneSlidesByToFill",
    value: function _cloneSlidesByToFill(spaceToFill, direction) {
      var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
      var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);

      while (spaceToFill > 0) {
        index = this._wrapround(index + direction, 0, this._slides.length);
        spaceToFill -= this._cloneSlide(index, direction);
      }
    }
  }, {
    key: "_cloneSlidesToFitWrapper",
    value: function _cloneSlidesToFitWrapper(cleanup) {
      var slideDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var realIndex = this._sliderWrapper.index;
      var first = void 0,
          last = void 0;

      if (cleanup === false) {
        first = this._sliderWrapper.getSlideProperties(0);
        last = this._sliderWrapper.getSlideProperties(this._wrapper.children.length - 1);
      } else {
        var result = this._sliderWrapper.getRemovableSlides(slideDelta);
        first = result.first;
        last = result.last;

        // Remove the slides from view
        for (var i = result.slides.length - 1; i >= 0; i--) {
          if (result.slides[i] === true) {
            this._sliderWrapper.removeSlide(i);
          }
        }
      }

      var spaceToFill = this._sliderWrapper.getEmptySpace(first.left, last.right);

      // Check if additional slides are required on the left
      if (first.visible === true && spaceToFill.left > 0) {
        this._cloneSlidesByToFill(spaceToFill.left, -1);
      }

      // Check if additional slides are required on the right
      if (last.visible === true && spaceToFill.right > 0) {
        this._cloneSlidesByToFill(spaceToFill.right, 1);
      }

      return realIndex - this._sliderWrapper.index;
    }

    /**
     * Gets the real (wrapper) index for the slide with the given original index
     * @param {Number} index - The index to search for
     * @param {Number} direction - The direction in which to search
     * @returns {Number} The wrapper index
     * @private
     */

  }, {
    key: "_getRealIndexFor",
    value: function _getRealIndexFor(index, direction) {
      var i = this._sliderWrapper.index;
      while (i >= 0 && i < this._wrapper.children.length) {
        var slideIndex = parseInt(this._wrapper.children[i].getAttribute(ATTRIBUTE_INDEX), 10);
        if (slideIndex === index) {
          return i;
        }

        i += direction;
      }

      throw new Error("Cloud not find real index for slide " + index + " in direction " + direction);
    }

    /**
     * Gets the index of the current active slide. If the slides are grouped evenly
     * the active slide is always the first in the group.
     * @returns {Number} The index of the active slide.
     */

  }, {
    key: "reset",
    value: function reset() {
      this._frameWidth = this._slider.getBoundingClientRect().width || this._slider.offsetWidth;

      this._updateResponsiveOptions();

      if (this._nextCtrl) {
        this._nextCtrl.disabled = false;
      }

      if (this._prevCtrl) {
        this._prevCtrl.disabled = false;
      }

      if (this._slidesPerGroup === 1) {
        var style = window.getComputedStyle(this._slider.parentElement);
        var parentWidth = this._slider.parentElement.clientWidth + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);

        var outerMargin = Math.ceil(parentWidth - this._frameWidth);
        this._additionalSlideMargin = Math.ceil(outerMargin * 0.5) + 1;
      } else {
        this._additionalSlideMargin = 0;
      }

      var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
      for (var i = 0; i < this._wrapper.children.length; i++) {
        var slide = this._wrapper.children[i];
        slide.style.marginLeft = slideMargin;
        slide.style.marginRight = slideMargin;
      }

      this._sliderWrapper.onresize();
      this._cloneSlidesToFitWrapper(false);
      this._sliderWrapper.moveTo(this._sliderWrapper.index);

      this._updatePagination();
      this._updateActiveSlides(this._sliderWrapper.index);
    }

    /**
     * Moves the slider to the next item.
     */

  }, {
    key: "prev",
    value: function prev() {
      this.slide(false, -1);
    }

    /**
     * Moves the slider to the previous item.
     */

  }, {
    key: "next",
    value: function next() {
      this.slide(false, 1);
    }
  }, {
    key: "slide",
    value: function slide(nextIndex, direction) {
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (typeof nextIndex !== "number") {
        if (direction > 0) {
          nextIndex = this._index + this._slidesPerGroup;
          direction = 1;
        } else {
          nextIndex = this._index - this._slidesPerGroup;
          direction = -1;
        }
      }

      nextIndex = this._adjustIndex(nextIndex);

      if (!direction) {
        direction = (0, _Utils.clamp)(nextIndex - this._index, -1, 1);
      }

      // Make sure there are enought slides on screen
      this._cloneSlidesToFitWrapper(false);

      // Make sure there are enough slides for the scroll operation
      this._cloneSlidesByScrollCount(nextIndex, direction);

      var realIndex = this._getRealIndexFor(nextIndex, direction);
      var slideDelta = this._sliderWrapper.getSlideDelta(realIndex);
      realIndex = Math.max(realIndex - this._cloneSlidesToFitWrapper(true, slideDelta), 0);

      this._sliderWrapper.moveTo(realIndex, undefined, animate);

      // Update the active index
      this._index = nextIndex;

      // Mark slides as active
      this._updatePagination();
      this._updateActiveSlides(realIndex);

      // console.log(`Performed slide to ${this._index}, realIndex: ${this._sliderWrapper.index}`)
    }

    /**
     * Moves the slider to the selected slide.
     * @param {Number} index - The index of the slide to slide to.
     * @param {Boolean} animate - `True` if the slide should be animated; otherwise `false`. Defaults to `true`.
     */

  }, {
    key: "slideTo",
    value: function slideTo(index) {
      var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.slide(index, undefined, animate);
    }

    /**
     * Destorys the components and frees all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener("resize", this._resizeHandler);
      window.removeEventListener("orientationchange", this._resizeHandler);

      this.element.removeEventListener("keydown", this._keydownHandler);
      this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
      this._slideArea.removeEventListener("touchstart", this._handleTouchstart);

      this._breakpointPhone.remove();
      this._breakpointTablet.remove();
      this._breakpointDesktop.remove();

      if (this._prevCtrl && this._nextCtrl) {
        this._prevCtrl.removeEventListener("click", this._prevHandler);
        this._nextCtrl.removeEventListener("click", this._nextHandler);
      }

      this._prevCtrl = undefined;
      this._nextCtrl = undefined;

      if (this._pagination) {
        this._pagination.removeEventListener("click", this._paginationClickHandler);
        this._pagination = undefined;
      }

      this._sliderWrapper.destory();
      this._sliderWrapper = undefined;
    }
  }, {
    key: "index",
    get: function get() {
      return this._index;
    }
  }]);
  return Carousel;
}(_DomElement3.default);

var SliderWrapper = function () {
  function SliderWrapper(wrapperElement, slideAreaElement, carouselElement) {
    (0, _classCallCheck3.default)(this, SliderWrapper);

    this._wrapperElement = wrapperElement;
    this._slideAreaElement = slideAreaElement;
    this._carouselElement = carouselElement;

    this._position = 0;
    this._translate = 0;
    this._index = 0;
    this._isdragging = false;
  }

  (0, _createClass3.default)(SliderWrapper, [{
    key: "_getSlide",
    value: function _getSlide(index) {
      if (index < 0 || index >= this._wrapperElement.children.length) {
        throw new Error("Argument 'index' is out of range, Value: " + index + " Min: 0, Max: " + (this._wrapperElement.children.length - 1));
      }

      return this._wrapperElement.children[index];
    }
  }, {
    key: "_setTransform",
    value: function _setTransform(targetPosition) {
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ANIMATION_DURATION;
      var ease = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ANIMATION_EASING;

      if (animated === false) {
        duration = 0;
      }

      var style = this._wrapperElement.style;
      if (style) {
        style[this._prefixes.duration] = duration + "ms";
        style[this._prefixes.timing] = ease;

        // No sub pixel transitions.
        targetPosition = Math.floor(targetPosition);

        style[this._prefixes.transform] = "translate(" + targetPosition + "px, 0)";
        this._position = targetPosition;
      }
    }
  }, {
    key: "_getWrapperSlidePosition",
    value: function _getWrapperSlidePosition(index) {
      var wrapperCenter = 0.5 * this._wrapperElement.offsetWidth;
      var slide = this._getSlide(index);

      var result = 0;
      // Calculate the position of the slide (centered)
      if (this._slidesPerGroup % 2 === 0) {
        var slideStyle = window.getComputedStyle(slide, null);
        var slideMargin = slideStyle ? parseInt(slideStyle.marginRight, 10) : 0;
        // Centered to the space between the two center slides of the group
        result = -slide.offsetLeft - slide.clientWidth + wrapperCenter - slideMargin;
      } else {
        result = -slide.offsetLeft - 0.5 * slide.clientWidth + wrapperCenter;
      }

      return result;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this._prefixes = {
        transition: "transition",
        transform: "transform",
        duration: "transition-duration",
        timing: "transition-timing-function"
      };

      this.onresize();
    }
  }, {
    key: "onresize",
    value: function onresize() {
      // update the area offset for slide position calculation
      this._areaOffset = this._slideAreaElement.getBoundingClientRect().left;

      // Get the container dimensions
      var containerRect = this._carouselElement.getBoundingClientRect();
      this._containerMin = containerRect.left;
      this._containerMax = containerRect.right;
      this._containerCenter = 0.5 * (this._containerMax - this._containerMin);
    }
  }, {
    key: "beginDrag",
    value: function beginDrag() {
      this._isdragging = true;
      this._dragStartPosition = this._position;
      this._dragStartIndex = this._index;
    }
  }, {
    key: "cancelDrag",
    value: function cancelDrag() {
      this._isdragging = false;
      this._setTransform(this._dragStartPosition, true, ANIMATION_DURATION, ANIMATION_EASING);

      this._dragStartPosition = undefined;
      this._dragStartIndex = undefined;
    }
  }, {
    key: "endDrag",
    value: function endDrag() {
      this._isdragging = false;
      this._dragStartPosition = undefined;
      this._dragStartIndex = undefined;
    }
  }, {
    key: "move",
    value: function move(delta) {
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ANIMATION_DURATION;
      var ease = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ANIMATION_EASING;

      delta = (0, _trunc2.default)(delta);
      if (Math.abs(delta) <= 0) {
        return;
      }

      var targetPosition = this._position += delta;
      this._setTransform(targetPosition, animated, duration, ease);
    }
  }, {
    key: "moveTo",
    value: function moveTo(index) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var animated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var newPosition = 0;
      if (!delta) {
        newPosition = this._getWrapperSlidePosition(index);
      } else {
        newPosition = this._position += delta;
      }

      this._index = index;
      this._setTransform(newPosition, animated);
    }
  }, {
    key: "addSlide",
    value: function addSlide(slide, position) {
      if (!slide) {
        throw new Error("Cannot add an undefined slide");
      }

      if (position !== -1 && position !== 1) {
        throw new Error("Argument out of range, 'position' must be either 1 or -1. Value " + position);
      }

      if (position > 0) {
        this._wrapperElement.appendChild(slide);
      } else {
        this._wrapperElement.insertBefore(slide, this._wrapperElement.children[0]);
        this._index++;
      }

      if (position < 0) {
        var width = slide.offsetWidth;

        var style = window.getComputedStyle(slide, null);
        var marginLeft = style ? parseInt(style.marginLeft, 10) : 0;
        var marginRight = style ? parseInt(style.marginRight, 10) : 0;

        this.move(-(width + marginLeft + marginRight));
      }
    }
  }, {
    key: "removeSlide",
    value: function removeSlide(index) {
      var slide = this._getSlide(index);
      var width = slide.offsetWidth;

      if (index <= this._index) {
        width *= -1;
        this._index--;
      }

      (0, _Utils.remove)(slide);

      if (width < 0) {
        this.move(-width);
      }
    }
  }, {
    key: "getSlideDelta",
    value: function getSlideDelta(index) {
      var currentPosition = this._position;
      if (this._isdragging === true) {
        currentPosition = this._dragStartPosition - this._position;
      }

      var newPosition = this._getWrapperSlidePosition(index);
      return newPosition - currentPosition;
    }
  }, {
    key: "getSlideProperties",
    value: function getSlideProperties(index) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      delta = delta || 0;
      var currentOffset = this._areaOffset + this._position + delta;
      var currentLeft = currentOffset;
      var currentRight = currentOffset;
      var _ = 0,
          currentMarginLeft = _.currentMarginLeft,
          currentMarginRight = _.currentMarginRight;


      var slide = this._getSlide(index);
      var slideIndex = parseInt(slide.getAttribute(ATTRIBUTE_INDEX), 10);

      for (var i = 0; i <= index; i++) {
        slide = this._getSlide(i);
        var slideStyle = window.getComputedStyle(slide);

        currentMarginLeft = parseInt(slideStyle.marginLeft, 10);
        currentMarginRight = parseInt(slideStyle.marginRight, 10);

        currentOffset += currentMarginLeft;
        currentLeft = currentOffset;
        currentRight = currentLeft + slide.offsetWidth;

        if (i < index) {
          currentOffset = currentRight + currentMarginRight;
        }
      }

      var visible = false;
      if (currentLeft > this._containerMin && currentLeft < this._containerMax || currentRight > this._containerMin && currentRight < this._containerMax) {
        visible = true;
      }

      return {
        visible: visible,
        index: slideIndex,
        left: currentLeft,
        right: currentRight,
        width: currentRight - currentLeft,
        marginLeft: currentMarginLeft,
        marginRight: currentMarginRight
      };
    }
  }, {
    key: "getRemovableSlides",
    value: function getRemovableSlides(delta) {
      var slides = [];
      var first = void 0,
          last = void 0;

      var index = this._wrapperElement.children.length;
      while (index > 0) {
        index--;

        var propsNow = this.getSlideProperties(index);
        var propsNew = this.getSlideProperties(index, delta);

        if (index === this._wrapperElement.children.length - 1) {
          last = propsNew;
        }

        if (index === 0) {
          first = propsNew;
        }

        if (propsNow.visible === false && propsNew.visible === false && index !== this._index && this._isdragging === false) {
          slides.push(true);
        } else {
          slides.push(false);
        }
      }

      slides.reverse();

      var firstToKeep = slides.indexOf(false);
      var lastToKeep = slides.lastIndexOf(false);

      for (var i = firstToKeep; i < lastToKeep; i++) {
        slides[i] = false;
      }

      // let log1 = ""
      // let log2 = ""
      // for (let i = 0; i < slides.length; i++) {
      //   let addon = i > 9 ? " " : ""
      //   log1 += `${addon} ${i}`
      //   log2 += `${addon}${addon} ${slides[i] === true ? "X" : "-"}`
      // }

      // console.log(log1)
      // console.log(log2)

      return {
        slides: slides,
        first: first,
        last: last
      };
    }
  }, {
    key: "getEmptySpace",
    value: function getEmptySpace(left, right) {
      return {
        left: Math.max(Math.ceil(left - this._containerMin), 0),
        right: Math.max(Math.ceil(this._containerMax - right), 0)
      };
    }
  }, {
    key: "destory",
    value: function destory() {
      this._wrapperElement = null;
      this._slideAreaElement = null;
      this._carouselElement = null;

      this._prefixes = null;
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
  }, {
    key: "index",
    get: function get() {
      return this._index;
    }
  }, {
    key: "slidesPerGroup",
    set: function set(value) {
      this._slidesPerGroup = value;
    }
  }]);
  return SliderWrapper;
}();

function init() {
  (0, _Utils.searchAndInitialize)(".carousel", function (e) {
    new Carousel(e);
  });
}

exports.default = Carousel;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/array/from":32,"babel-runtime/core-js/math/trunc":35,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _gsap = require("gsap");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_INDICATOR = ".bar-chart__progress";
var QUERY_DETAIL_RIGHT = ".detail-right";
var QUERY_DETAIL_BOTTOM = ".detail-bottom";
var QUERY_PROGRESS = ".bar-chart__progress";

var CLASS_UNLIMITED = "bar-chart-horizontal--unlimited";
var CLASS_LIMITED = "bar-chart-horizontal--limited";

var CLASS_DETAIL_VALUE = "value";
var CLASS_DETAIL_UNIT = "unit";

var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";

var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";

var ANIMATION_DURATION = 0.5;

/**
 * Bar Chart Horizontal Component.
 */

var BarChartHorizontal = function (_DomElement) {
  (0, _inherits3.default)(BarChartHorizontal, _DomElement);

  /**
   * Creates and initializes the bar chart horizontal component.
   * @param {DomElement} - root element of the chart.
   */
  function BarChartHorizontal(element, data) {
    (0, _classCallCheck3.default)(this, BarChartHorizontal);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BarChartHorizontal.__proto__ || (0, _getPrototypeOf2.default)(BarChartHorizontal)).call(this, element));

    _this._data = data;

    _this._legendItems = [];

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(BarChartHorizontal, [{
    key: "_initialize",
    value: function _initialize() {
      this._indicatorWrapper = this.element.querySelector(QUERY_INDICATOR);

      this._unit = this.getAttribute("data-unit") || "";
      this._maxValue = parseFloat(this.getAttribute("data-max"));
      this._precision = parseInt(this.getAttribute("data-precision"), 10) || 0;

      this._isUnlimited = this.hasClass(CLASS_UNLIMITED);
      this._isLimited = this.hasClass(CLASS_LIMITED);

      this._progessWrapper = this.element.querySelector(QUERY_PROGRESS);

      if (this._isLimited === true) {
        this._detailRight = this.element.querySelector(QUERY_DETAIL_BOTTOM);
      } else {
        this._detailRight = this.element.querySelector(QUERY_DETAIL_RIGHT);
      }

      if (this._isUnlimited === false && this._isLimited === false) {
        this._legend = (0, _DomFunctions.getAttributeReference)(this.element, "data-legend");
      }

      if (!this._data) {
        this._data = (0, _ChartFunctions.tryGetData)(this.element);
      }

      this._render();
    }
  }, {
    key: "_render",
    value: function _render() {
      var dataOne = this._data[0];
      var dataTwo = this._data[1];

      var tl = new _gsap.TimelineLite();
      var tooltip = this._isLimited === false ? this._getTooltipContent(this._data) : undefined;

      var animatedValueElement = void 0;

      // Cleanup
      (0, _ChartFunctions.removeAllChildren)(this._detailRight);
      (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);

      // Clear only own legend items
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this._legendItems), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;

          (0, _Utils.remove)(item);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._legendItems = [];

      if (dataOne) {
        if (this._isUnlimited === false || this._isUnlimited === true && !dataTwo) {

          var valElement = animatedValueElement = this._createValueElement(dataOne);
          this._detailRight.appendChild(valElement);

          if (this._isLimited === false) {
            var separatorElement = new _DomElement3.default("div").addClass(CLASS_DETAIL_UNIT).setHtml(" " + this._unit).element;

            this._detailRight.appendChild(separatorElement);
          }
        }

        // Add the indicator
        var indicator = this._addIndicator(dataOne, tooltip);

        tl.from(indicator, ANIMATION_DURATION, {
          width: 0,
          ease: _gsap.Power4.easeInOut
        });

        // Animate the value if required
        if (animatedValueElement && this._isLimited === true) {
          var counter = { var: 0 };
          tl.to(counter, ANIMATION_DURATION, {
            var: dataOne.value,
            roundProps: "var",
            onUpdate: function onUpdate() {
              animatedValueElement.innerHTML = "" + counter.var;
            },
            ease: _gsap.Power4.easeOut
          }, "-=" + ANIMATION_DURATION);
        }

        // Add the legend
        if (this._legend) {
          var legendItem = (0, _ChartFunctions.createLegendItem)(dataOne);
          this._legend.appendChild(legendItem);
          this._legendItems.push(legendItem);

          tl.from(legendItem, ANIMATION_DURATION, {
            opacity: 0,
            ease: _gsap.Power4.easeInOut
          }, "-=" + ANIMATION_DURATION);
        }
      }

      if (dataTwo) {
        var _valElement = this._createValueElement(dataTwo);

        var unitElement = new _DomElement3.default("div").addClass(CLASS_DETAIL_UNIT).setHtml(" " + this._unit).element;

        this._detailRight.appendChild(_valElement);
        this._detailRight.appendChild(unitElement);

        // Add the indicator
        var _indicator = this._addIndicator(dataTwo, tooltip);
        tl.from(_indicator, ANIMATION_DURATION, {
          width: 0,
          ease: _gsap.Power4.easeInOut
        });

        // Add the legend
        if (this._legend) {
          var _legendItem = (0, _ChartFunctions.createLegendItem)(dataTwo);
          this._legend.appendChild(_legendItem);
          this._legendItems.push(_legendItem);

          tl.from(_legendItem, ANIMATION_DURATION, {
            opacity: 0,
            ease: _gsap.Power4.easeInOut
          }, "-=" + ANIMATION_DURATION);
        }
      }

      if (this._isLimited === true) {
        var _valElement2 = this._createValueElement({ value: this._maxValue });

        var _unitElement = new _DomElement3.default("div").addClass(CLASS_DETAIL_UNIT).setHtml(" " + this._unit).element;

        this._detailRight.appendChild(_valElement2);
        this._detailRight.appendChild(_unitElement);
      }
    }
  }, {
    key: "_createValueElement",
    value: function _createValueElement(data) {
      var unlimitedPrefix = "";

      if (this._isUnlimited === true) {
        unlimitedPrefix = "+";
      }

      var value = parseFloat(data.value);
      if (value <= 0) {
        value = ".00";
      } else {
        value = value.toFixed(this._precision);
      }

      return new _DomElement3.default("div").addClass(CLASS_DETAIL_VALUE).setHtml("" + unlimitedPrefix + value).element;
    }
  }, {
    key: "_addIndicator",
    value: function _addIndicator(data, tooltip) {
      var width = 99.8 / this._maxValue * data.value;

      var indicator = new _DomElement3.default("div").addClass(CLASS_INDICATOR);

      if ((0, _ChartFunctions.isColor)(data.color) === true) {
        indicator.setAttribute("style", "background-color: " + data.color + ";");
      } else {
        indicator.addClass(data.color);
      }

      var indicatorWrapper = new _DomElement3.default("div").addClass(CLASS_INDICATOR_WRAPPER).setAttribute("style", "width: " + width + "%").appendChild(indicator).setAttribute("onclick", "void(0)");

      if (tooltip && tooltip !== "") {
        indicatorWrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_MULTILINE).setAttribute("aria-label", tooltip);
      }

      this._progessWrapper.appendChild(indicatorWrapper.element);
      return indicatorWrapper.element;
    }
  }, {
    key: "_getTooltipContent",
    value: function _getTooltipContent(dataList) {
      var tooltip = "";
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(dataList), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var data = _step2.value;

          tooltip += data.title + ": " + data.value + " " + this._unit + "\n";
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return tooltip.trim();
    }

    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */

  }, {
    key: "update",
    value: function update(data) {
      if (data) {
        this._data = data;
      }

      this._render();
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destory",
    value: function destory() {
      this._data = undefined;

      (0, _ChartFunctions.removeAllChildren)(this._detailRight);
      (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);

      this._detailRight = undefined;
      this._progessWrapper = undefined;

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)(this._legendItems), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var item = _step3.value;

          (0, _Utils.remove)(item);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._legendItems = undefined;
      this._legend = undefined;
    }
  }]);
  return BarChartHorizontal;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".bar-chart-horizontal", function (e) {
    new BarChartHorizontal(e);
  });
}

exports.default = BarChartHorizontal;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"./ChartFunctions":12,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _gsap = require("gsap");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_DATA_CATEGORIES = ".js-data-list .js-category";
var QUERY_DATA_ITEMS = ".js-data-list .js-data";
var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".bar-chart__legend";

var CLASS_INDICATOR = "indicator";
var CLASS_LABEL_X = "axis-x-label";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_INDICATOR_INNER_WRAPPER = "indicator-wrapper-inner";
var CLASS_INDICATOR_EMPTY = "empty";

var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_RIGHT = "tooltip--right";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";

var ANIMATION_DURATION = 0.5;

/**
 * Bar Chart Horizontal Component.
 */

var BarChartVertical = function (_DomElement) {
  (0, _inherits3.default)(BarChartVertical, _DomElement);

  /**
   * Creates and initializes the bar chart horizontal component.
   * @param {DomElement} - root element of the chart.
   */
  function BarChartVertical(element, data) {
    (0, _classCallCheck3.default)(this, BarChartVertical);

    var _this = (0, _possibleConstructorReturn3.default)(this, (BarChartVertical.__proto__ || (0, _getPrototypeOf2.default)(BarChartVertical)).call(this, element));

    _this._data = data;

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(BarChartVertical, [{
    key: "_initialize",
    value: function _initialize() {
      this._unit = this.getAttribute("data-unit") || "";

      this._minValue = parseFloat(this.getAttribute("data-min")) || 0;
      this._maxValue = parseFloat(this.getAttribute("data-max")) || 100;

      this._chart = this.element.querySelector(QUERY_CHART);
      this._legend = this.element.querySelector(QUERY_LEGEND);

      if (!this._data) {
        this._data = this._tryGetData(this.element);
      }

      this._render();
    }
  }, {
    key: "_tryGetData",
    value: function _tryGetData(element) {
      var data = {
        categories: [],
        items: []
      };

      var categories = element.querySelectorAll(QUERY_DATA_CATEGORIES);
      var items = element.querySelectorAll(QUERY_DATA_ITEMS);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(categories), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var category = _step.value;

          data.categories.push({
            title: (0, _DomFunctions.text)(category),
            color: category.getAttribute("data-color")
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(items), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;

          var dataEnty = {
            title: (0, _DomFunctions.text)(item),
            class: item.getAttribute("data-class"),
            values: []
          };

          var vals = item.getAttribute("data-value");
          if (vals) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = (0, _getIterator3.default)(vals.split(",")), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var val = _step3.value;

                dataEnty.values.push(parseFloat(val));
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }

          data.items.push(dataEnty);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return data;
    }
  }, {
    key: "_getTooltipContent",
    value: function _getTooltipContent(entry, categories) {
      var tooltip = "";
      for (var i = 0; i < entry.values.length; i++) {
        tooltip += categories[i].title + ": " + entry.values[i] + " " + this._unit + "\n";
      }

      return tooltip.trim();
    }
  }, {
    key: "_render",
    value: function _render() {
      if (this._legend) {
        (0, _ChartFunctions.removeAllChildren)(this._legend);

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _getIterator3.default)(this._data.categories), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var category = _step4.value;

            var legendItem = (0, _ChartFunctions.createLegendItem)(category);
            this._legend.appendChild(legendItem);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      (0, _ChartFunctions.removeAllChildren)(this._chart);

      var animationStages = [];

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)(this._data.items), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var item = _step5.value;

          var element = new _DomElement3.default("li");

          if (item.class && item.class !== "") {
            element.addClass(item.class);
          }

          var listElement = new _DomElement3.default("ul").addClass(CLASS_INDICATOR_WRAPPER);

          var wrapper = new _DomElement3.default("div").addClass(CLASS_INDICATOR_INNER_WRAPPER);
          listElement.appendChild(wrapper);

          element.appendChild(listElement);

          var tooltip = this._getTooltipContent(item, this._data.categories);
          if (tooltip && tooltip !== "") {
            wrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_RIGHT).setAttribute("aria-label", tooltip);

            if (item.values.length > 1) {
              wrapper.addClass(CLASS_TOOLTIP_MULTILINE);
            }
          }

          for (var _i = 0; _i < item.values.length; _i++) {
            var height = this._chart.offsetHeight / this._maxValue * item.values[_i];

            var indicator = new _DomElement3.default("li").addClass(CLASS_INDICATOR).setAttribute("style", "height: " + height + "px;");

            if (height > 0) {
              var color = this._data.categories[_i].color;
              if ((0, _ChartFunctions.isColor)(color) === true) {
                indicator.setAttribute("style", "background-color: " + color + ";");
              } else {
                indicator.addClass(color);
              }

              if (animationStages.length <= _i) {
                animationStages.push([]);
              }

              animationStages[_i].push(indicator.element);
            } else {
              indicator.addClass(CLASS_INDICATOR_EMPTY);
            }

            wrapper.appendChild(indicator);
          }

          element.appendChild(new _DomElement3.default("div").addClass(CLASS_LABEL_X).setHtml(item.title));

          this._chart.appendChild(element.element);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var tl = new _gsap.TimelineLite();
      for (var i = 0; i < animationStages.length; i++) {
        tl.from(animationStages[i], ANIMATION_DURATION, {
          height: 0,
          ease: _gsap.Power4.easeInOut,
          autoRound: false
        });

        if (this._legend) {
          tl.from(this._legend.children[i], ANIMATION_DURATION, {
            opacity: 0,
            ease: _gsap.Power4.easeInOut
          }, "-=" + ANIMATION_DURATION);
        }
      }
    }

    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */

  }, {
    key: "update",
    value: function update(data) {
      if (data) {
        this._data = data;
      }

      this._render();
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destory",
    value: function destory() {
      this._data = undefined;

      if (this._legend) {
        (0, _ChartFunctions.removeAllChildren)(this._legend);
        this._legend = undefined;
      }
    }
  }]);
  return BarChartVertical;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".bar-chart-vertical", function (e) {
    new BarChartVertical(e);
  });
}

exports.default = BarChartVertical;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"./ChartFunctions":12,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.tryGetData = tryGetData;
exports.removeAllChildren = removeAllChildren;
exports.createLegendItem = createLegendItem;
exports.isColor = isColor;

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_DATA = ".js-data";

function tryGetData(element) {
  var data = [];
  var elements = element.querySelectorAll(QUERY_DATA);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(elements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var entry = _step.value;

      var value = parseFloat(entry.getAttribute("data-value"));
      var color = entry.getAttribute("data-color");
      var title = (0, _DomFunctions.text)(entry);

      var item = {
        title: title,
        value: value,
        color: color
      };

      data.push(item);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return data;
}

function removeAllChildren(node) {
  while (node.firstChild) {
    node.removeChild(node.firstChild);
  }
}

function createLegendItem(data) {
  var bullet = new _DomElement2.default("span").addClass("bullet");

  if (isColor(data.color) === true) {
    bullet.setAttribute("style", "background-color: " + data.color + ";");
  } else {
    bullet.addClass(data.color);
  }

  var caption = new _DomElement2.default("span").setHtml(data.title);

  return new _DomElement2.default("li").appendChild(bullet).appendChild(caption).element;
}

function isColor(str) {
  var pattern = /^#/i;
  return pattern.test(str);
}

},{"../DomElement":4,"../DomFunctions":5,"babel-runtime/core-js/get-iterator":33}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Utils = require("../Utils");

var _ChartFunctions = require("./ChartFunctions");

var _gsap = require("gsap");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".js-legend";

var DASH_SEPARATOR_WIDTH = 3;
var ANIMATION_DURATION = 1.5;

var QUERY_META_TITLE = ".meta .title";
var QUERY_META_SUBTITLE = ".meta .subtitle";

/**
 * Pie Chart Component.
 */

var PieChart = function (_DomElement) {
  (0, _inherits3.default)(PieChart, _DomElement);

  /**
   * Creates and initializes the Pie Chart component.
   * @param {DomElement} - root element of the chart.
   * @param {Array} - pie chart data definitions.
   */
  function PieChart(element) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
    (0, _classCallCheck3.default)(this, PieChart);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PieChart.__proto__ || (0, _getPrototypeOf2.default)(PieChart)).call(this, element));

    _this._data = data;

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(PieChart, [{
    key: "_initialize",
    value: function _initialize() {
      this._chart = this.element.querySelector(QUERY_CHART);
      this._legend = this.element.querySelector(QUERY_LEGEND);
      this._title = this.element.querySelector(QUERY_META_TITLE);
      this._subtitle = this.element.querySelector(QUERY_META_SUBTITLE);

      this._unit = this.getAttribute("data-unit") || "";

      if (!this._data) {
        this._data = (0, _ChartFunctions.tryGetData)(this.element);
      }

      this._render();
    }
  }, {
    key: "_render",
    value: function _render() {
      var _this2 = this;

      var total = this._data.reduce(function (a, b) {
        return a + b.value;
      }, 0);
      var r = 16;
      var dashTotal = 2 * r * Math.PI;

      var currentRotate = 9;

      // Cleanup
      (0, _ChartFunctions.removeAllChildren)(this._chart);

      if (this._legend) {
        (0, _ChartFunctions.removeAllChildren)(this._legend);
      }

      var tl = new _gsap.TimelineLite();

      var percentageAdjustTotal = 0;
      var percentageAdjust = 0;
      var separatorPercentage = DASH_SEPARATOR_WIDTH / 100;

      for (var i = 0; i < this._data.length; i++) {
        var entry = this._data[i];

        var percentage = entry.value / total;
        if (percentage < separatorPercentage) {
          percentageAdjustTotal += separatorPercentage - percentage;
          percentageAdjust++;
        }
      }

      if (percentageAdjust > 0) {
        percentageAdjust = percentageAdjustTotal / (this._data.length - percentageAdjust);
      }

      var _loop = function _loop(_i) {
        var entry = _this2._data[_i];

        var displayPercentage = entry.value / total;
        var percentage = Math.max(separatorPercentage, displayPercentage - percentageAdjust);

        var dashWidth = percentage * dashTotal - DASH_SEPARATOR_WIDTH;

        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", "0 0 34 34");
        svg.setAttribute("role", "img");
        svg.setAttribute("aria-labelledby", "title desc");

        var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
        title.setAttribute("id", "title");
        title.innerHTML = "Pie chart segment " + Math.floor(displayPercentage * 100) + "%";

        var description = document.createElementNS("http://www.w3.org/2000/svg", "desc");
        description.setAttribute("id", "desc");
        description.innerHTML = entry.title + ": " + entry.value;

        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", 17);
        circle.setAttribute("cy", 17);
        circle.setAttribute("r", r);
        circle.setAttribute("stroke-dasharray", dashWidth + " " + dashTotal);

        circle.setAttribute("style", "stroke-width: 0");

        if ((0, _ChartFunctions.isColor)(entry.color) === true) {
          circle.setAttribute("stroke", "" + entry.color);
        } else {
          circle.setAttribute("class", entry.color);
        }

        circle.setAttribute("role", "presentation");
        svg.setAttribute("style", "transform: rotate(" + currentRotate + "deg);");

        svg.appendChild(title);
        svg.appendChild(description);
        svg.appendChild(circle);
        _this2._chart.appendChild(svg);

        var duration = ANIMATION_DURATION * percentage;

        tl.set(circle, {
          clearProps: "strokeWidth"
        });

        if (circle.classList) {
          tl.from(circle, duration, {
            strokeDasharray: "0.5 100",
            ease: _gsap.Power4.ease
          });
        } else {
          // IE 10 & 11 fallback since animating stroke-dasharray does not work
          // we have to do it manualy

          var counter = { var: 0.5 };
          tl.to(counter, duration, {
            var: dashWidth,
            onUpdate: function onUpdate() {
              circle.setAttribute("stroke-dasharray", counter.var + " " + dashTotal);
            },
            ease: _gsap.Power4.ease
          });
        }

        // Legend
        if (_this2._legend && _this2._data.length > 1) {
          var bullet = new _DomElement3.default("span").addClass("bullet");

          if ((0, _ChartFunctions.isColor)(entry.color) === true) {
            bullet.setAttribute("style", "background-color: " + entry.color);
          } else {
            bullet.addClass(entry.color);
          }

          var caption = new _DomElement3.default("span").setHtml(entry.title);

          var legendItem = new _DomElement3.default("li").appendChild(bullet).appendChild(caption);

          _this2._legend.appendChild(legendItem.element);

          tl.from(legendItem.element, duration, {
            opacity: 0,
            ease: _gsap.Power4.easeInOut
          }, "-=" + duration);
        }

        currentRotate += 360 * percentage;

        if (_i === _this2._data.length - 1) {
          _this2._title.innerHTML = entry.value + " " + _this2._unit;
          _this2._subtitle.innerHTML = entry.title;
        }
      };

      for (var _i = 0; _i < this._data.length; _i++) {
        _loop(_i);
      }
    }

    /**
     * Updates the pie chart with the specified data definitions.
     * @param {Array} - pie chart data definitions.
     */

  }, {
    key: "update",
    value: function update(data) {
      if (data) {
        this._data = data;
      }

      this._render();
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destory",
    value: function destory() {
      this._data = undefined;
      this._title = undefined;
      this._subtitle = undefined;
      this._unit = undefined;

      (0, _ChartFunctions.removeAllChildren)(this._chart);
      this._chart = undefined;

      if (this._legend) {
        (0, _ChartFunctions.removeAllChildren)(this._legend);
        this._legend = undefined;
      }
    }
  }]);
  return PieChart;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".pie-chart", function (e) {
    new PieChart(e);
  });
}

exports.default = PieChart;

},{"../DomElement":4,"../Utils":7,"./ChartFunctions":12,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_OPEN = "is-open";

var ANIMATION_OPEN = 0.3;

/**
 * The Collapse component.
 */

var Collapse = function (_DomElement) {
  (0, _inherits3.default)(Collapse, _DomElement);

  /**
   * Creates and initializes the Collapse component.
   * @param {DomElement} - The root element of the Collapse component.
   */
  function Collapse(element) {
    (0, _classCallCheck3.default)(this, Collapse);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Collapse.__proto__ || (0, _getPrototypeOf2.default)(Collapse)).call(this, element));

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._initialize();
    return _this;
  }

  /**
   * Initializes the Collapse component.
   * @private
   */


  (0, _createClass3.default)(Collapse, [{
    key: "_initialize",
    value: function _initialize() {
      var dataTarget = this.element.getAttribute("data-target");
      if (dataTarget === null || dataTarget === "") {

        /* eslint-disable no-console */
        console.error("A collapsible element requires a 'data-target' that specifies the element to collapse");
        console.info(this.element);
        /* eslint-enable no-console */

        return;
      }

      var hiddenTarget = this.element.getAttribute("data-hidden");
      if (hiddenTarget !== null && hiddenTarget !== "") {
        this._hiddenIndicator = document.querySelector(hiddenTarget);
      }

      this._collapsibleElements = document.querySelectorAll(dataTarget);
      this.element.addEventListener("click", this._clickHandler);
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      (0, _Utils.preventDefault)(event);
      this.toggle();
    }

    /**
     * Toggles the collapseible.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
        return;
      }

      if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(this._collapsibleElements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var s = _step.value;

            this._openCollapse(s);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(this._collapsibleElements), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _s = _step2.value;

            this._closeCollapse(_s);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  }, {
    key: "_openCollapse",
    value: function _openCollapse(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.set(el, {
        display: "block"
      });

      _gsap.TweenLite.to(el, ANIMATION_OPEN, {
        className: "+=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      // set aria expanded
      el.setAttribute("aria-expanded", true);
    }
  }, {
    key: "_closeCollapse",
    value: function _closeCollapse(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.to(el, ANIMATION_OPEN, {
        className: "-=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut],
        onComplete: function onComplete() {
          _gsap.TweenLite.set(el, {
            clearProps: "display"
          });
        }
      });

      // set aria expanded
      el.setAttribute("aria-expanded", false);
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._collapsibleElements = null;

      if (this._clickHandler) {
        this.element.removeEventListener(this._clickHandler);
      }

      this.element = null;
    }
  }]);
  return Collapse;
}(_DomElement3.default);

function init() {
  var elements = document.querySelectorAll("[data-toggle='collapse']");
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = (0, _getIterator3.default)(elements), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var e = _step3.value;

      if (e.getAttribute("data-init") === "auto") {
        new Collapse(e);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
}

exports.default = Collapse;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_BORDER = "empty-state__border";
var CLASS_BORDER_MODAL = "empty-state__border--modal";
var CLASS_ACTIVE = "is-active";
var CLASS_HASFILES = "has-files";
var CLASS_MODAL = "empty-state--modal";
var CLASS_MODAL_CONTENT = "modal__content";

var QUERY_MODAL_BODY = ".modal__body";
var QUERY_FILE = "input[type='file']";

/**
 * Empty state pattern
 */

var EmptyState = function (_DomElement) {
  (0, _inherits3.default)(EmptyState, _DomElement);

  /**
   * Creates and initializes the Empty-State pattern component.
   * @param {DomElement} - root element of the empty-state pattern.
   */
  function EmptyState(element) {
    (0, _classCallCheck3.default)(this, EmptyState);

    var _this = (0, _possibleConstructorReturn3.default)(this, (EmptyState.__proto__ || (0, _getPrototypeOf2.default)(EmptyState)).call(this, element));

    _this._border = new _DomElement3.default("div").addClass(CLASS_BORDER);

    _this._fileInput = _this.element.querySelector(QUERY_FILE);
    _this._button = _this.element.querySelector("label");

    _this._fileChangedHandler = _this._handleFileChanged.bind(_this);
    _this._preventEventsHandler = _this._preventDragEvents.bind(_this);
    _this._dragEnterHandler = _this._handleDragEnter.bind(_this);
    _this._dragLeaveHandler = _this._handleDragLeave.bind(_this);
    _this._dropHandler = _this._handleDrop.bind(_this);

    _this._isDragging = false;

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(EmptyState, [{
    key: "_initialize",
    value: function _initialize() {
      if (this.hasClass(CLASS_MODAL)) {
        // handle modal dialogs
        this._dragArea = (0, _DomFunctions.parentWithClass)(this.element, CLASS_MODAL_CONTENT);
        var borderArea = this._dragArea.querySelector(QUERY_MODAL_BODY);
        borderArea.setAttribute("style", "pointer-events: none;");

        this._border = new _DomElement3.default("div").addClass(CLASS_BORDER).addClass(CLASS_BORDER_MODAL);

        borderArea.appendChild(this._border.element);
      } else {
        // normal modal dialog
        this._dragArea = this.element;
        var _borderArea = (0, _DomFunctions.getRootElement)();

        if (!_borderArea.querySelector("." + CLASS_BORDER)) {
          _borderArea.appendChild(this._border.element);
        }
      }

      var form = this.element.querySelector("form");

      var _arr = ["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"];
      for (var _i = 0; _i < _arr.length; _i++) {
        var event = _arr[_i];
        this.element.addEventListener(event, this._preventEventsHandler);
        form.addEventListener(event, this._preventEventsHandler);
        this._dragArea.addEventListener(event, this._preventEventsHandler);
      }

      this._dragArea.addEventListener("dragover", this._dragEnterHandler);
      this._dragArea.addEventListener("dragenter", this._dragEnterHandler);

      this._dragArea.addEventListener("dragleave", this._dragLeaveHandler);
      this._dragArea.addEventListener("dragend", this._dragLeaveHandler);
      this._dragArea.addEventListener("drop", this._dragLeaveHandler);

      this._dragArea.addEventListener("drop", this._dropHandler);
      this._fileInput.addEventListener("change", this._fileChangedHandler);
    }
  }, {
    key: "_preventDragEvents",
    value: function _preventDragEvents(e) {
      e.preventDefault();
      e.stopPropagation();

      return false;
    }
  }, {
    key: "_handleDragEnter",
    value: function _handleDragEnter() {
      if (this._isDragging === true) {
        return;
      }

      this._isDragging = true;
      this._button.setAttribute("style", "pointer-events: none;");

      this.addClass(CLASS_ACTIVE);
      this._border.addClass(CLASS_ACTIVE);
    }
  }, {
    key: "_handleDragLeave",
    value: function _handleDragLeave() {
      if (this._isDragging === false) {
        return;
      }

      this._isDragging = false;
      this._button.setAttribute("style", "");

      this.removeClass(CLASS_ACTIVE);
      this._border.removeClass(CLASS_ACTIVE);
    }
  }, {
    key: "_handleDrop",
    value: function _handleDrop(e) {
      this._fileInput.files = e.dataTransfer.files;
    }
  }, {
    key: "_handleFileChanged",
    value: function _handleFileChanged() {
      var files = this._fileInput.files;

      if (files && files.length > 0) {
        this.addClass(CLASS_HASFILES);
      } else {
        this.removeClass(CLASS_HASFILES);
      }
    }

    /**
     * Gets the currently selected files.
     */

  }, {
    key: "files",
    get: function get() {
      return this._fileInput.files;
    }
  }]);
  return EmptyState;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".empty-state", function (e) {
    new EmptyState(e);
  });
}

exports.default = EmptyState;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_DROPDOWN = ".js-autocomplete";
var CLASS_RESULT = "autocomplete__result";
var CLASS_OPEN = "is-open";
var CLASS_HOVER = "js-hover";
var ATTRIBUTE_VALUE = "data-value";

var TIMEOUT_BLUR = 400;

/**
 * Autocomplete component
 */

var Autocomplete = function (_DomElement) {
  (0, _inherits3.default)(Autocomplete, _DomElement);

  function Autocomplete(element, configuration) {
    (0, _classCallCheck3.default)(this, Autocomplete);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Autocomplete.__proto__ || (0, _getPrototypeOf2.default)(Autocomplete)).call(this, element));

    _this._input = _this.element.querySelector("input");
    _this._dropdown = _this.element.querySelector(QUERY_DROPDOWN);

    // Setup event context
    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);
    _this._keyUpHandler = _this._handleKeyUp.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);

    if (configuration) {
      _this._minChars = configuration.minChars;
      _this._source = configuration.source;
    }

    if (!_this._minChars || _this._minChars < 0) {
      _this._minChars = 2;
    }

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the Autocomplete component.
   * @private
   */


  (0, _createClass3.default)(Autocomplete, [{
    key: "_initialize",
    value: function _initialize() {
      this._clearSuggestions();

      if (this._input.getAttribute("disabled")) {
        this.disable();
      } else {
        this.enable();
      }

      // Disable browser autofill
      this._input.setAttribute("autocomplete", "off");
    }

    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Suggest
     * @property {String} term - The current search term.
     * @property {String[]} matches - The list of matching strings.
     */

    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Source
     * @property {String} term - The current search term.
     * @property {Autocomplete~Suggest} suggest - The autocomplete callback function to report the results.
     */

    /**
     * The Autocomplete component configuration object
     * @typedef {Object} Autocomplete~Config
     * @property {Number} minChars - The minimal required characters to start querying for autocomplete matches.
     * @property {Autocomplete~Source} source - The autocomplete source function.
     */

    /**
     * Updates the autocomplete component configuration for the current instance
     * @param {Autocomplete~Config} configuration The configuration object
     */

  }, {
    key: "configure",
    value: function configure(configuration) {
      if (!configuration) {
        return;
      }

      if (configuration.minChars) {
        this._minChars = Math.min(configuration.minChars, 1);
      }

      if (configuration.source) {
        this._source = configuration.source;
      }

      this._clearSuggestions();
    }

    /**
     * Sets the select control to the enabled state.
     */

  }, {
    key: "enable",
    value: function enable() {
      this._input.removeAttribute("disabled");

      this._input.addEventListener("keyup", this._keyUpHandler);
      this._input.addEventListener("blur", this._blurHandler);
    }

    /**
     * Sets the select control to the disabled state.
     */

  }, {
    key: "disable",
    value: function disable() {
      this._input.addAttribute("disabled");

      this._input.removeEventListener("keyup", this._keyUpHandler);
      this._input.removeEventListener("blur", this._blurHandler);

      this.close();
    }

    /**
     * Destroys the component and frees all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();

      this._keyUpHandler = undefined;
      this._windowClickHander = undefined;
      this._blurHandler = undefined;
    }

    /**
     * Closes the suggestions dropdown.
     */

  }, {
    key: "open",
    value: function open() {
      this._dropdown.addEventListener("click", this._clickHandler);
      window.addEventListener("click", this._windowClickHander);

      this.addClass(CLASS_OPEN);
    }

    /**
     * Opens the suggestions dropdown.
     */

  }, {
    key: "close",
    value: function close() {
      this._dropdown.removeEventListener("click", this._clickHandler);
      window.removeEventListener("click", this._windowClickHander);

      this.removeClass(CLASS_OPEN);
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      if (!this._isDropdownTarget(event.target)) {
        return;
      }

      var current = event.target;
      while (current.nodeName !== "LI" && current.parentNode) {
        current = current.parentNode;
      }

      if (current.nodeName === "LI") {
        (0, _Utils.preventDefault)(event);
        this._selectItem(current);
      }
    }
  }, {
    key: "_handleBlur",
    value: function _handleBlur() {
      var _this2 = this;

      setTimeout(function () {
        _this2.close();
      }, TIMEOUT_BLUR);
    }
  }, {
    key: "_handleKeyUp",
    value: function _handleKeyUp(event) {
      var evt = event || window.event;
      var keycode = event.which || event.keyCode;
      var isOpen = (0, _DomFunctions.hasClass)(this.element, CLASS_OPEN);

      if (keycode === Inputs.KEY_ESCAPE && isOpen === true) {
        // handle Escape key (ESC)
        this.close();
        (0, _Utils.preventDefault)(evt);
        return;
      }

      if (isOpen === true && (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN)) {
        // Up and down arrows

        var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
        if (focusedElement) {
          (0, _DomFunctions.removeClass)(focusedElement, CLASS_HOVER);

          var children = new (Function.prototype.bind.apply(Array, [null].concat((0, _toConsumableArray3.default)(this._suggestionList.childNodes))))();

          var totalNodes = children.length - 1;
          var direction = keycode === Inputs.KEY_ARROW_UP ? -1 : 1;

          var index = children.indexOf(focusedElement);

          index = Math.max(Math.min(index + direction, totalNodes), 0);
          focusedElement = this._suggestionList.childNodes[index];
        } else {
          focusedElement = this._suggestionList.querySelector("li");
        }

        (0, _DomFunctions.addClass)(focusedElement, CLASS_HOVER);
        (0, _Utils.preventDefault)(evt);
        return;
      }

      if (isOpen === true && keycode === Inputs.KEY_ENTER) {
        var _focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);

        (0, _Utils.preventDefault)(evt);
        this._selectItem(_focusedElement);
        return;
      }

      if (evt.currentTarget && evt.currentTarget.value && evt.currentTarget.value.length >= this._minChars) {
        this._getSuggestion(evt.currentTarget.value);
      } else {
        this.close();
      }
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      if (this._isDropdownTarget(event.target)) {
        return;
      }

      this.close();
    }
  }, {
    key: "_selectItem",
    value: function _selectItem(item) {
      if (!item) {
        return;
      }

      var text = item.getAttribute(ATTRIBUTE_VALUE);
      if (text) {
        this._input.value = text;
      }

      this.close();
    }
  }, {
    key: "_isDropdownTarget",
    value: function _isDropdownTarget(target) {
      var current = target;
      while (current !== this._dropdown && current.parentNode) {
        current = current.parentNode;
      }

      return current === this._dropdown;
    }
  }, {
    key: "_clearSuggestions",
    value: function _clearSuggestions() {
      // Clear the dropdown item
      (0, _DomFunctions.empty)(this._dropdown);

      this._suggestionList = document.createElement("ul");
      this._dropdown.appendChild(this._suggestionList);
    }
  }, {
    key: "_addSuggestion",
    value: function _addSuggestion(text, term) {
      var html = text.replace(new RegExp("(" + term + ")", "gi"), "<strong>$1</strong>");

      var textElement = new _DomElement3.default("span").setHtml(html);

      var innerElement = new _DomElement3.default("div").addClass(CLASS_RESULT).appendChild(textElement);

      var liElement = new _DomElement3.default("li").setAttribute(ATTRIBUTE_VALUE, text).appendChild(innerElement);

      this._suggestionList.appendChild(liElement.element);
    }
  }, {
    key: "_getSuggestion",
    value: function _getSuggestion(term) {
      var _this3 = this;

      if (!this._source) {
        throw new Error("The source function is undefined, cannot load suggestions");
      }

      this._source(term, function (matches, termused) {
        _this3._onMatchesReceived(matches, termused);
      });
    }
  }, {
    key: "_onMatchesReceived",
    value: function _onMatchesReceived(matches, term) {
      this._clearSuggestions();

      if (!matches || matches.length === 0) {
        this.close();
      } else {
        // Clear the dropdown item
        (0, _DomFunctions.empty)(this._suggestionList);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(matches), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var match = _step.value;

            this._addSuggestion(match, term);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.open();
      }
    }
  }]);
  return Autocomplete;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".input-field--autocomplete", function (e) {
    new Autocomplete(e);
  });
}

exports.default = Autocomplete;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"babel-runtime/helpers/toConsumableArray":48}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_HAS_VALUE = "is-fixed";
var CLASS_MESSAGE = ".message";

/**
 * Input field component
 */

var InputField = function (_DomElement) {
  (0, _inherits3.default)(InputField, _DomElement);

  function InputField(element) {
    (0, _classCallCheck3.default)(this, InputField);

    var _this = (0, _possibleConstructorReturn3.default)(this, (InputField.__proto__ || (0, _getPrototypeOf2.default)(InputField)).call(this, element));

    _this._changedHandler = _this.onValueChanged.bind(_this);
    _this._animationStartHandler = _this._onAnimationStart.bind(_this);
    _this._initialize();
    return _this;
  }

  /**
   * Initializes the input field component.
   * @private
   */


  (0, _createClass3.default)(InputField, [{
    key: "_initialize",
    value: function _initialize() {
      this.element.addEventListener("input", this._changedHandler);

      if (this.element.getAttribute("type") === "password") {
        this.element.addEventListener("animationstart", this._animationStartHandler);
      }

      this.onValueChanged();
    }
  }, {
    key: "_onAnimationStart",
    value: function _onAnimationStart(e) {
      if (e.animationName === "onAutoFillStart") {
        this.onValueChanged(true);
      }
    }

    /**
     * Notifies the input field component that it's value has been changed.
     */

  }, {
    key: "onValueChanged",
    value: function onValueChanged() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.element.value && this.element.value !== "" || force === true) {
        this.addClass(CLASS_HAS_VALUE);
      } else {
        this.removeClass(CLASS_HAS_VALUE);
        this.element.value = "";
      }
    }

    /**
     * Destroys the component and frees all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.element.removeEventListener("input", this._changedHandler);

      if (this.element.getAttribute("type") === "password") {
        this.element.removeEventListener("animationstart", this._animationStartHandler);
      }

      this._changedHandler = undefined;
      this._animationStartHandler = undefined;
    }

    /**
     * Displays the specified error text underneath the input field.
     * @param {text} text The error text/html to display; or undefined to hide the message.
     */

  }, {
    key: "showError",
    value: function showError(text) {
      var message = void 0;
      if (this.element.parentElement) {
        var _msg = this.element.parentElement.querySelector(CLASS_MESSAGE);

        if (_msg) {
          message = new _DomElement3.default(_msg);
        }
      }

      if (!text || text === "") {
        if (message) {
          (0, _Utils.remove)(message.element);
        }

        this.removeClass("invalid");
        return;
      }

      this.addClass("invalid");

      if (!message) {
        message = new _DomElement3.default("div").addClass("message");

        this.element.parentElement.appendChild(message.element);
      } else {
        message.empty();
      }

      var icon = new _DomElement3.default("i").addClass("icon").addClass("icon-026-exclamation-mark-circle").setAttribute("aria-hidden", true);

      var msg = new _DomElement3.default("span").setHtml(text);

      message.appendChild(icon);
      message.appendChild(msg);
    }
  }]);
  return InputField;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".input-field input", function (e) {
    new InputField(e);
  }, function (e) {
    return e.parentElement;
  });
}

exports.default = InputField;

},{"../DomElement":4,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _isNan = require("babel-runtime/core-js/number/is-nan");

var _isNan2 = _interopRequireDefault(_isNan);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _gsap = require("gsap");

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MARGIN_TICK = 32;
var CLASS_HTML5 = "html5";
var RANGE_LIGHT = "range--light";

var CLASS_CONTAINER = "range-container";
var CLASS_SLIDER = "range-slider";
var CLASS_ACTIVE = "range--active";

var CLASS_TRACK = "range-track";
var CLASS_TRACK_PROGRESS = "range-track__progress";

var CLASS_TICK = "range-tick";
var CLASS_TICK_LABEL = "range-tick__label";
var CLASS_TICK_ACTIVE = "range-tick--active";

var CLASS_THUMB = "range-thumb";
var CLASS_THUMB_VALUE = "range-thumb__value";
var CLASS_DISABLED = "range--disabled";

var CLASS_DRAGGING = "range--dragging";

/**
 * The range slider component definition.
 */

var Range = function (_DomElement) {
  (0, _inherits3.default)(Range, _DomElement);

  function Range(element) {
    (0, _classCallCheck3.default)(this, Range);

    // Setup event context
    var _this = (0, _possibleConstructorReturn3.default)(this, (Range.__proto__ || (0, _getPrototypeOf2.default)(Range)).call(this, element));

    _this._downHander = _this._handleDown.bind(_this);
    _this._moveHandler = _this._handleMove.bind(_this);
    _this._endHander = _this._handleEnd.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);

    _this._focusHandler = _this._handleFocus.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);
    _this._resizeHandler = _this.layout.bind(_this);

    _this._initialize();

    if (_this.element.disabled) {
      _this.disable();
    } else {
      _this.enable();
    }
    return _this;
  }

  /**
   * Initializes the range slider component.
   *
   * This method inspects the select definition and its options and
   * generates new stylable DOM elements around the original range input-element
   * definitions.
   * @private
   */


  (0, _createClass3.default)(Range, [{
    key: "_initialize",
    value: function _initialize() {

      if (this.hasClass(CLASS_HTML5)) {
        // This element uses HTML5 styling, do not touch it...
        return;
      }

      this._wrapperElement = new _DomElement3.default(this.element.parentNode);

      this._rangeContainer = new _DomElement3.default("div").addClass(CLASS_CONTAINER);

      this._rangeTrack = new _DomElement3.default("div").addClass(CLASS_TRACK);

      // check if range--light slider then add progress
      if (this._wrapperElement.hasClass(RANGE_LIGHT)) {
        this._rangeProgress = new _DomElement3.default("div").addClass(CLASS_TRACK_PROGRESS);

        this._rangeTrack.appendChild(this._rangeProgress);
      }

      this._rangeThumb = new _DomElement3.default("div").addClass(CLASS_THUMB);

      this._ticksWrapper = new _DomElement3.default("div").addClass(CLASS_SLIDER);

      this._rangeContainer.appendChild(this._rangeTrack);
      this._rangeContainer.appendChild(this._ticksWrapper);
      this._rangeContainer.appendChild(this._rangeThumb);

      // add container to wrapper
      this._wrapperElement.appendChild(this._rangeContainer);

      // get min & max definitions
      this._minValue = parseFloat(this.element.min) || 0;
      this._maxValue = parseFloat(this.element.max) || 1;

      // get the label/output format string
      this._formatter = window[this.getAttribute("formatter")];

      // get the output label and move it below the container
      if (this.element.id) {
        this._outputLabel = this._wrapperElement.find("output[for='" + this.element.id + "']");
        this._wrapperElement.appendChild(this._outputLabel);
      }

      if (!this.element.step) {
        // fix issues with float sliders if the step is undefined
        this.element.step = "any";
      }

      var options = this._getOptionsList();
      if (options && options.length > 1) {
        this._addTicks(options);
      }

      if (this._rangeContainer.element.querySelectorAll("." + CLASS_TICK_LABEL).length <= 1) {
        this._thumbValue = new _DomElement3.default("div").addClass(CLASS_THUMB_VALUE);

        this._rangeThumb.appendChild(this._thumbValue);
      }

      this._trackValueTotal = this._maxValue - this._minValue;
      this.layout();

      this._updateTickState();

      // Apply the tab index
      var tabIndex = this.element.getAttribute("tabindex");
      if (tabIndex) {
        this._rangeContainer.setAttribute("tabindex", tabIndex);
      }

      window.addEventListener("resize", this._resizeHandler);
      window.addEventListener("orientationchange", this._resizeHandler);
    }
  }, {
    key: "_getOptionsList",
    value: function _getOptionsList() {
      var options = [];

      var listId = this.getAttribute("list");
      if (listId) {
        var dataList = document.querySelector("#" + listId);
        if (dataList) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = (0, _getIterator3.default)(dataList.querySelectorAll("option")), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var entry = _step.value;

              var value = parseFloat(entry.innerText);
              var label = entry.getAttribute("label") || parseFloat(value.toFixed(2));

              options.push({
                value: value,
                label: label
              });
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      // Sort the list to enable snapping
      options = options.sort(function (a, b) {
        return a.value - b.value;
      });

      if (options.length > 1) {
        this._minValue = Number.MAX_VALUE;
        this._maxValue = Number.MIN_VALUE;

        for (var i = 0; i < options.length; i++) {
          this._minValue = Math.min(this._minValue, options[i].value);
          this._maxValue = Math.max(this._maxValue, options[i].value);
        }
      }

      return options;
    }
  }, {
    key: "_addTicks",
    value: function _addTicks(dataItems) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(dataItems), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;

          var tickElement = new _DomElement3.default("div").setAttribute("data-value", entry.value).addClass(CLASS_TICK);

          var tickLabel = new _DomElement3.default("span").addClass(CLASS_TICK_LABEL).setHtml(entry.label.toString());

          tickElement.appendChild(tickLabel);
          this._ticksWrapper.appendChild(tickElement);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "_isEventOnLabel",
    value: function _isEventOnLabel(event) {
      return event.target.classList.contains(CLASS_TICK_LABEL);
    }
  }, {
    key: "_handleDown",
    value: function _handleDown(event) {
      this._wrapperElement.addClass(CLASS_DRAGGING);

      this._rangeContainer.element.addEventListener("mouseup", this._endHander);
      document.addEventListener("mousemove", this._moveHandler);
      document.addEventListener("mouseup", this._endHander);

      this._rangeContainer.element.addEventListener("touchmove", this._moveHandler);
      document.addEventListener("touchend", this._endHander);

      // Ignore clicks directly on the thumb
      if (event.target !== this._rangeThumb.element && !this._isEventOnLabel(event)) {
        var pos = this._getRelativePosition(event);
        this._setPosition(pos, true, false, false);
      }
    }
  }, {
    key: "_handleMove",
    value: function _handleMove(event) {
      (0, _Utils.preventDefault)(event);
      this._unfocus();

      if (!this._isEventOnLabel(event)) {
        var pos = this._getRelativePosition(event);
        this._setPosition(pos, true, false, false);
      }
    }
  }, {
    key: "_handleEnd",
    value: function _handleEnd(event) {
      this._wrapperElement.removeClass(CLASS_DRAGGING);

      this._rangeContainer.element.removeEventListener("mouseup", this._endHander);
      document.removeEventListener("mouseup", this._endHander);
      document.removeEventListener("mousemove", this._moveHandler);

      this._rangeContainer.element.removeEventListener("touchmove", this._moveHandler);
      document.removeEventListener("touchend", this._endHander);

      var pos = this._getRelativePosition(event);
      this._setPosition(pos, true, true, true);
      this._handleBlur();
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = evt || window.event;
      var keycode = event.which || event.keyCode;

      if (keycode === Inputs.KEY_ESCAPE) {
        // handle Escape key (ESC)
        this._rangeContainer.element.blur();
        return;
      }

      var isUp = keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_RIGHT || keycode === Inputs.KEY_PAGE_UP;

      var isDown = keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_ARROW_LEFT || keycode === Inputs.KEY_PAGE_DOWN;

      if (isUp || isDown) {
        evt.preventDefault();

        var direction = isDown ? -1 : 1;

        // make a larger step if its the vertical arrow or page keys
        if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_PAGE_UP || keycode === Inputs.KEY_PAGE_DOWN) {
          direction *= 10;
        }

        var val = this.value;
        if (this._ticksWrapper.element.childNodes.length > 1) {
          val = this._getNextValue(val, direction);
        } else {

          var step = this.element.step;
          if (!step || step === "any") {
            step = 0.1;
          }
          var newVal = val + parseFloat(step) * direction;
          val = newVal;
        }

        this._setValue(val, true, true);
        return;
      }
    }
  }, {
    key: "_handleFocus",
    value: function _handleFocus() {
      this._rangeContainer.addClass(CLASS_ACTIVE);
    }
  }, {
    key: "_handleBlur",
    value: function _handleBlur() {
      this._rangeContainer.removeClass(CLASS_ACTIVE);
    }
  }, {
    key: "_unfocus",
    value: function _unfocus() {
      if (document.selection) {
        document.selection.empty();
      } else {
        window.getSelection().removeAllRanges();
      }
    }
  }, {
    key: "_getRelativePosition",
    value: function _getRelativePosition(event) {
      var pageX = event.pageX;
      if (pageX === undefined) {
        var touch = event.touches[0] || event.changedTouches[0];
        pageX = touch.pageX;
      }

      return pageX - this._trackLeftPosition + this._grabPosition;
    }

    /**
     * Validates and updates the position and sets the corresponding value on the slider.
     * @param {position} the new position to set.
     * @param {updateValue} true if the value should be updated as well; otherwise false.
     * @param {snap} true if snapping should be used; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */

  }, {
    key: "_setPosition",
    value: function _setPosition(position) {
      var updateValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var snap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var animate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (position === undefined || position === null || (0, _isNan2.default)(position)) {
        throw new Error("Position is not a number");
      }

      // Clamp to min and max range
      var newPos = (0, _Utils.clamp)(position, this._trackPositionMin, this._trackPositionMax);
      if (updateValue) {
        var value = this._trackValueTotal / this._trackWidth * newPos + this._minValue;

        if (this._ticksWrapper.element.childNodes.length > 1 && snap) {
          var snapPos = this._getSnapPosition(newPos);
          newPos = snapPos.position;
          value = snapPos.value;
        } else if (this.element.step && this.element.step !== "any") {
          value = Math.round(value / this.element.step, 0) * this.element.step;
        }

        this._setValue(value, false, false, false);
      }

      if (animate && updateValue) {
        this._updateTickState();
      }

      if (animate) {
        _gsap.TweenLite.to(this._rangeThumb.element, 0.2, {
          left: newPos,
          ease: _gsap.Power4.easeInOut
        });

        if (this._rangeProgress) {
          _gsap.TweenLite.to(this._rangeProgress.element, 0.2, {
            width: newPos,
            ease: _gsap.Power4.easeInOut
          });
        }
      } else {
        _gsap.TweenLite.set(this._rangeThumb.element, { left: newPos });

        if (this._rangeProgress) {
          _gsap.TweenLite.set(this._rangeProgress.element, { width: newPos });
        }
      }
    }

    /**
     * Gets the snap value corresponding to the given value.
     * @param {value} the target value.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */

  }, {
    key: "_getSnapValue",
    value: function _getSnapValue(value) {
      var ticks = this._ticksWrapper.element.childNodes;
      var currentPosition = 0;

      for (var i = 0; i < ticks.length; i++) {

        var currentElement = new _DomElement3.default(ticks[i]);
        var currentValue = parseFloat(currentElement.getAttribute("data-value"));
        var currentWidth = currentElement.element.clientWidth;

        var nextElement = void 0;
        var nextValue = Number.MAX_VALUE;

        if (i < ticks.length - 1) {
          nextElement = new _DomElement3.default(ticks[i + 1]);
          nextValue = parseFloat(nextElement.getAttribute("data-value"));
        }

        // left most element
        if (i === 0 && value <= currentValue) {
          return {
            value: currentValue,
            position: MARGIN_TICK - this._grabPosition };
        }

        // right most element
        if (!nextElement && value >= currentValue) {
          return {
            value: currentValue,
            position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1 };
        }

        if (value >= currentValue && value < nextValue) {
          return {
            value: currentValue,
            position: currentPosition + 0.5 * currentWidth - this._grabPosition };
        }

        currentPosition += currentWidth;
      }

      throw new Error("Could not determine snap value");
    }

    /**
     * Gets the snap position corresponding to the given position.
     * @param {position} the target position.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */

  }, {
    key: "_getSnapPosition",
    value: function _getSnapPosition(position) {
      if (position === undefined || position === null || (0, _isNan2.default)(position)) {
        throw new Error("position is not a number");
      }

      var ticks = this._ticksWrapper.element.childNodes;
      var currentPosition = 0;

      for (var i = 0; i < ticks.length; i++) {

        var currentElement = new _DomElement3.default(ticks[i]);
        var currentValue = parseFloat(currentElement.getAttribute("data-value"));
        var currentWidth = currentElement.element.clientWidth;

        var nextElement = void 0;

        if (i < ticks.length - 1) {
          nextElement = new _DomElement3.default(ticks[i + 1]);
        }

        // left most element
        if (i === 0 && position <= currentPosition + currentWidth) {
          return {
            value: currentValue,
            position: MARGIN_TICK - this._grabPosition };
        }

        // right most element
        if (!nextElement && position >= currentPosition) {
          return {
            value: currentValue,
            position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1 };
        }

        if (position >= currentPosition && position < currentPosition + currentWidth) {
          return {
            value: currentValue,
            position: currentPosition + 0.5 * currentWidth - this._grabPosition };
        }

        currentPosition += currentWidth;
      }

      throw new Error("Could not determine snap position");
    }

    /**
     * Gets the next value in the given direction with regards to snapping.
     * @param {value} The current value.
     * @param {direction} The direction (positive or negative integer).
     * @returns The next value.
     * @private
     */

  }, {
    key: "_getNextValue",
    value: function _getNextValue(value, direction) {
      var ticks = this._ticksWrapper.element.childNodes;

      for (var i = 0; i < ticks.length; i++) {
        var currentElement = new _DomElement3.default(ticks[i]);
        var currentVal = parseFloat(currentElement.getAttribute("data-value"));

        if (value === currentVal) {
          var index = (0, _Utils.clamp)(i + direction, 0, ticks.length - 1);
          value = ticks[index].getAttribute("data-value");
        }
      }

      return value;
    }
  }, {
    key: "_updateTickState",
    value: function _updateTickState() {
      if (this._ticksWrapper.element.childNodes.length > 1) {
        var activeTick = this._ticksWrapper.find("." + CLASS_TICK_ACTIVE);
        if (activeTick) {
          activeTick.removeClass(CLASS_TICK_ACTIVE);
        }
        var newActiveTick = this._ticksWrapper.find("." + CLASS_TICK + "[data-value='" + this.value + "']");
        if (newActiveTick) {
          newActiveTick.addClass(CLASS_TICK_ACTIVE);
        }
      }
    }
  }, {
    key: "_adjustTickLabelPosition",
    value: function _adjustTickLabelPosition(tickItem, outerItemsWidth, left) {
      var label = new _DomElement3.default(tickItem.querySelector("." + CLASS_TICK_LABEL));

      var dummyElement = new _DomElement3.default("span").addClass(CLASS_TICK_LABEL).setAttribute("style", "visibility: hidden; display: inline-block;").setHtml(label.innerText);

      this._rangeContainer.appendChild(dummyElement);

      var width = dummyElement.element.clientWidth / 2;
      this._rangeContainer.removeChild(dummyElement);

      var floatPosition = left ? "left" : "right";

      if (width < MARGIN_TICK) {
        // center small items on the tick
        label.setAttribute("style", floatPosition + ": " + (MARGIN_TICK - Math.floor(width)) + "px; text-align: " + floatPosition + ";");
      }
    }
  }, {
    key: "_formatOutput",
    value: function _formatOutput(value, short) {
      if (this._formatter) {
        return this._formatter(value, short);
      }

      var str = parseFloat(value.toFixed(2));
      return str.toString();
    }

    /**
     * Validates and updates the range value.
     * @param {value} the new value to set.
     * @param {update} true if the UI should be updated; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */

  }, {
    key: "_setValue",
    value: function _setValue(value) {
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var val = (0, _Utils.clamp)(value, this._minValue, this._maxValue);
      var position = void 0;

      if (this._ticksWrapper.element.childNodes.length > 1) {
        var snapValue = this._getSnapValue(val);
        position = snapValue.position;
        val = snapValue.value;
      } else {
        position = this._trackWidth / this._trackValueTotal * (value - this._minValue);
      }

      this.element.value = val;

      if (this._thumbValue) {
        this._thumbValue.setHtml(this._formatOutput(val, true));
      }

      if (this._outputLabel) {
        this._outputLabel.setHtml(this._formatOutput(val, false));
      }

      if (update) {
        this._setPosition(position, false, false, animate);
        this._updateTickState();
      }

      this.dispatchEvent("input");
    }

    /**
     * Sets the value of the range slider.
     */

  }, {
    key: "layout",


    /**
     * Force the component to re-layout itself.
     */
    value: function layout() {
      this._grabPosition = Math.round(this._rangeThumb.element.offsetWidth / 2);
      var tickItems = this._rangeContainer.element.querySelectorAll("." + CLASS_TICK);
      var ticksOffset = tickItems && tickItems.length > 0 ? 2 * MARGIN_TICK : MARGIN_TICK;

      this._trackWidth = this._rangeTrack.element.offsetWidth - ticksOffset;

      this._trackPositionMin = 0;
      this._trackPositionMax = this._rangeTrack.element.clientWidth - this._rangeThumb.element.offsetWidth + 1;
      this._trackLeftPosition = this._rangeTrack.element.getBoundingClientRect().left + MARGIN_TICK;

      var itemCount = tickItems.length - 1;

      this._itemWidth = this._trackWidth / itemCount;
      var outerItemsWidth = this._itemWidth * 0.5 + MARGIN_TICK;

      for (var i = 0; i <= itemCount; i++) {
        var width = this._itemWidth;

        if (i === 0 || i === itemCount) {
          width = outerItemsWidth;
        }

        var item = new _DomElement3.default(tickItems[i]);
        item.setAttribute("style", "width: " + Math.floor(width) + "px;");
      }

      // adjust first and last label positions
      if (tickItems.length > 1) {
        this._adjustTickLabelPosition(tickItems[0], outerItemsWidth, true);
        this._adjustTickLabelPosition(tickItems[tickItems.length - 1], outerItemsWidth, false);
      }

      // update the value
      this._setValue(this.element.value, true, false);
    }

    /**
     * Registers an event listener on the select control.
     */

  }, {
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      this.element.addEventListener(type, listener);
    }

    /**
     * Destroys the components and frees all references.
     */

  }, {
    key: "destoy",
    value: function destoy() {
      window.removeEventListener("resize", this._resizeHandler);
      window.removeEventListener("orientationchange", this._resizeHandler);

      this._downHander = null;
      this._moveHandler = null;
      this._endHander = null;
      this._focusHandler = null;
      this._blurHandler = null;

      this.element = null;
      this._rangeContainer = null;
      this._wrapperElement = null;
    }

    /**
     * Sets the component to the enabled state.
     */

  }, {
    key: "enable",
    value: function enable() {
      this.element.removeAttribute("disabled");
      this._wrapperElement.removeClass(CLASS_DISABLED);

      this._rangeContainer.element.addEventListener("mousedown", this._downHander);
      this._rangeContainer.element.addEventListener("touchstart", this._downHander);
      this._rangeContainer.element.addEventListener("keydown", this._keydownHandler);
      this._rangeContainer.element.addEventListener("focus", this._focusHandler);
      this._rangeContainer.element.addEventListener("blur", this._blurHandler);
    }

    /**
     * Sets the component to the disabled state.
     */

  }, {
    key: "disable",
    value: function disable() {
      this.element.setAttribute("disabled", "");
      this._wrapperElement.addClass(CLASS_DISABLED);

      this._rangeContainer.element.removeEventListener("mousedown", this._downHander);
      this._rangeContainer.element.removeEventListener("mouseup", this._endHander);
      this._rangeContainer.element.removeEventListener("mousemove", this._moveHandler);

      this._rangeContainer.element.removeEventListener("touchstart", this._downHander);

      this._rangeContainer.element.removeEventListener("focus", this._focusHandler);
      this._rangeContainer.element.removeEventListener("blur", this._blurHandler);
    }
  }, {
    key: "value",
    set: function set(value) {
      this._setValue(value, true, true, true);
    }

    /**
     * Gets the current value.
     */
    ,
    get: function get() {
      return parseFloat(this.element.value);
    }
  }]);
  return Range;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)("input[type='range']", function (e) {
    new Range(e);
  });
}

exports.default = Range;

},{"../DomElement":4,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/number/is-nan":36,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_PLACEHOLDER = "select__placeholder";
var CLASS_THUMB = "select__thumb";
var CLASS_BUTTON = "select__button";
var CLASS_DROPDOWN = "select__dropdown";

var CLASS_OPEN = "select--open";
var CLASS_CLOSED = "select--closed";
var CLASS_DISABLED = "select--disabled";

var CLASS_ITEM = "dropdown-item";
var CLASS_ITEM_SELECTED = "dropdown-item--selected";
var CLASS_ITEM_FOCUSED = "dropdown-item--focused";
var CLASS_ITEM_DISABLED = "dropdown-item--disabled";

var CLASS_GROUP_ITEM = "dropdown-group";
var CLASS_GROUP_HEADER = "dropdown-group__item";

var QUERY_MESSAGE = ".message";

var TIMEOUT_CLOSE = 150;
var TIMEOUT_BLUR = 400;

/**
 * The select component API.
 */

var Select = function (_DomElement) {
  (0, _inherits3.default)(Select, _DomElement);

  function Select(element) {
    (0, _classCallCheck3.default)(this, Select);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Select.__proto__ || (0, _getPrototypeOf2.default)(Select)).call(this, element));

    _this._openByFocus = false;

    // Check for multi-selection
    _this._multiselection = _this.element.hasAttribute("multiple") === true;

    // Setup event context
    _this._clickHandler = _this._handleClick.bind(_this);
    _this._handleDropdownClick = _this._handleClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._focusHandler = _this._handleFocus.bind(_this);
    _this._blurHandler = _this._handleBlur.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the select component.
   *
   * This method inspects the select definition and its options and
   * generates new stylable DOM elements around the original select-element
   * definitions.
   * @private
   */


  (0, _createClass3.default)(Select, [{
    key: "_initialize",
    value: function _initialize() {
      this._wrapperElement = new _DomElement3.default(this.element.parentNode).addClass(CLASS_CLOSED);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.classes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cls = _step.value;

          this._wrapperElement.addClass(cls);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._dropdownElement = new _DomElement3.default("div").addClass(CLASS_DROPDOWN);

      this._setupTarget();
      this._setupPlaceholder();

      this._wrapperElement.appendChild(this._dropdownElement);

      this._createOptions(this.element);

      this._updateSize();
      this._updateMessage();

      if (this.element.disabled) {
        this.disable();
      } else {
        this.enable();
      }
    }
  }, {
    key: "_setupTarget",
    value: function _setupTarget() {
      // move the id from the select element to the wrapper
      var id = this.element.getAttribute("id");
      if (id) {
        this.element.removeAttribute("id");
        this._wrapperElement.setAttribute("id", id);
      }

      // Apply the tab index
      var tabIndex = this.element.getAttribute("tabindex");
      if (tabIndex) {
        this._wrapperElement.setAttribute("tabIndex", tabIndex);
      }
    }
  }, {
    key: "_setupPlaceholder",
    value: function _setupPlaceholder() {
      if (!this._selectButtonElement) {
        this._selectButtonElement = new _DomElement3.default("div").addClass(CLASS_BUTTON);

        this._wrapperElement.appendChild(this._selectButtonElement);
      }

      if (!this._thumbElement) {
        this._thumbElement = new _DomElement3.default("div").addClass(CLASS_THUMB);

        var thumbIcon = new _DomElement3.default("div").addClass("thumb-icon");

        this._thumbElement.appendChild(thumbIcon);
        this._selectButtonElement.appendChild(this._thumbElement);
      }

      var placeholderText = "";

      this._placeholderOption = this.element.querySelector("option[value='']");
      if (this._placeholderOption) {
        placeholderText = Dom.text(this._placeholderOption);
        this._placeholderOption.selected = false;
      }

      var selectedOption = this.element.querySelector("option[selected]");
      if (selectedOption) {
        placeholderText = Dom.text(selectedOption);
      }

      if (!this._placeholderElement) {
        this._placeholderElement = new _DomElement3.default("span").addClass(CLASS_PLACEHOLDER);

        this._selectButtonElement.appendChild(this._placeholderElement);
      }

      this._placeholderElement.setHtml(placeholderText);

      this._placeholderText = placeholderText;

      if (selectedOption !== this._placeholderOption) {
        this._updatePlaceholder(true);
      }
    }
  }, {
    key: "_updateMessage",
    value: function _updateMessage() {
      var messageNode = this._wrapperElement.element.querySelector(QUERY_MESSAGE);
      if (messageNode !== null) {
        this._wrapperElement.appendChild(new _DomElement3.default(messageNode));
      }
    }
  }, {
    key: "_createOptions",
    value: function _createOptions(element) {
      for (var i = 0; i < element.childNodes.length; i++) {
        var child = element.childNodes[i];

        if (child.tagName === "OPTGROUP") {
          this._appendGroup(child);
        }

        if (child.tagName === "OPTION") {
          var option = this._createOption(child);

          if (option) {
            this._dropdownElement.appendChild(option);
          }
        }
      }
    }
  }, {
    key: "_createOption",
    value: function _createOption(option) {
      var opt = new _DomElement3.default("div").addClass(CLASS_ITEM).setHtml(option.innerHTML);

      if (option.selected) {
        opt.addClass(CLASS_ITEM_SELECTED);
      }

      if (option.disabled) {
        opt.addClass(CLASS_ITEM_DISABLED);
      }

      if (option.value) {
        opt.setAttribute("data-value", option.value);
        return opt;
      }

      return undefined;
    }
  }, {
    key: "_appendGroup",
    value: function _appendGroup(optgroup) {
      var label = optgroup.getAttribute("label");

      var group = new _DomElement3.default("div").addClass(CLASS_GROUP_ITEM);

      var groupHeader = new _DomElement3.default("div").addClass(CLASS_GROUP_HEADER).setHtml(label);

      group.appendChild(groupHeader);

      var options = optgroup.querySelectorAll("option");
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(options), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;

          var option = this._createOption(entry);
          if (option) {
            group.appendChild(option);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._dropdownElement.appendChild(group);
      return group;
    }
  }, {
    key: "_updateSize",
    value: function _updateSize() {
      // Note: Mirroring the DOM and measuring the items using their clientWidth was very
      // unreliable, therefore measuring was switched to the new HTML5 measureText method
      // margins and paddings arround the text are copied from the original placeholder items
      // dimension
      var placeholderStyle = window.getComputedStyle(this._placeholderElement.element, null);

      var paddingRight = parseFloat(placeholderStyle.paddingRight);
      var paddingLeft = parseFloat(placeholderStyle.paddingLeft);

      var font = this._placeholderElement.css("font");
      var textWidth = Dom.textWidth(this._placeholderText, font);
      var maxWidth = paddingLeft + paddingRight + textWidth;

      var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)(options), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var entry = _step3.value;

          var width = Dom.textWidth(Dom.text(entry), font) + paddingLeft + paddingRight;

          if (width > maxWidth) {
            maxWidth = width;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._selectButtonElement.setAttribute("style", "min-width: " + Math.round(maxWidth + 4) + "px;");
    }
  }, {
    key: "_isButtonTarget",
    value: function _isButtonTarget(target) {
      return target === this._wrapperElement.element || target === this._placeholderElement.element || target === this._selectButtonElement.element || target === this._thumbElement.element;
    }
  }, {
    key: "_isDropdownTarget",
    value: function _isDropdownTarget(target) {
      var current = target;
      while (current !== this._dropdownElement.element && current.parentNode) {
        current = current.parentNode;
      }

      return current === this._dropdownElement.element;
    }

    /**
     * Updates the UI if the selection has changed and makes sure the
     * select control and the generated markup are synchronized.
     * @private
     */

  }, {
    key: "_selectedItemChanged",
    value: function _selectedItemChanged(oldItems, newItem) {
      var _this2 = this;

      var autoClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var multiselect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (Dom.hasClass(newItem, CLASS_ITEM_DISABLED)) {
        return;
      }

      if (oldItems.length === 0 && !newItem) {
        throw new Error("Can not select undefined elements");
      }

      var oldItem = oldItems[0];
      if (multiselect === true) {
        oldItem = (0, _Utils.find)(oldItems, function (x) {
          return x.getAttribute("data-value") === newItem.getAttribute("data-value");
        });
      }

      if (newItem && oldItem && oldItem === newItem) {
        // Click on a previously selected element -> deselect
        newItem = undefined;
      }

      if (oldItem) {
        // Remove selection on the element
        var oldValue = oldItem.getAttribute("data-value") || -1;
        var optElement = (0, _Utils.find)(this.element.options, function (x) {
          return x.value === oldValue;
        });

        if (!optElement) {
          throw new Error("The option with value " + oldValue + " does not exist");
        }

        optElement.selected = false;
        Dom.removeClass(oldItem, CLASS_ITEM_SELECTED);
      }

      if (newItem) {
        // Select a new item
        var newValue = newItem.getAttribute("data-value") || -1;
        var _optElement = (0, _Utils.find)(this.element.options, function (x) {
          return x.value === newValue;
        });

        if (!_optElement) {
          throw new Error("The option with value " + newValue + " does not exist");
        }

        _optElement.selected = true;
        Dom.addClass(newItem, CLASS_ITEM_SELECTED);
      }

      var hasSelectedItems = true;
      if (this._multiselection === false && !newItem) {
        // Handle no selection for non multiselect states
        this._placeholderOption.selected = true;
        hasSelectedItems = false;
      }

      if (this._multiselection === true && this.element.selectedOptions.length === 0) {
        hasSelectedItems = false;
      }

      this._updatePlaceholder(hasSelectedItems);

      // Dispatch the changed event
      this.dispatchEvent("change");

      if (autoClose && !multiselect) {
        setTimeout(function () {
          _this2.close();
        }, TIMEOUT_CLOSE);
      }
    }
  }, {
    key: "_updatePlaceholder",
    value: function _updatePlaceholder(hasSelectedItems) {
      var text = this._placeholderOption ? Dom.text(this._placeholderOption) : " ";

      if (hasSelectedItems === true) {
        var selectedItems = Array.apply(undefined, (0, _toConsumableArray3.default)(this.element.selectedOptions));

        if (selectedItems.length > 0) {
          text = "";
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = (0, _getIterator3.default)(selectedItems), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var item = _step4.value;

              text += Dom.text(item) + ", ";
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }

        text = text.substring(0, text.length - 2);
      }

      // Update the placeholder text
      if (this._placeholderElement) {
        this._placeholderElement.setHtml(text);
      }
    }
  }, {
    key: "_handleFocus",
    value: function _handleFocus() {
      var _this3 = this;

      this.open();
      this._openByFocus = true;

      setTimeout(function () {
        _this3._openByFocus = false;
      }, TIMEOUT_BLUR);
    }
  }, {
    key: "_handleBlur",
    value: function _handleBlur() {
      this.close();
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      var handled = false;

      if (this._lastHandledEvent === event) {
        this._lastHandledEvent = undefined;
        return;
      }

      if (this._isButtonTarget(event.target) && this._openByFocus === false) {
        // handle header item clicks and toggle dropdown
        this.toggle();
        handled = true;
      }

      var newItem = event.target;

      if (!handled && Dom.hasClass(newItem, CLASS_ITEM)) {
        // handle clicks on dropdown items
        var oldItems = Array.apply(undefined, (0, _toConsumableArray3.default)(this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED)));
        this._selectedItemChanged(oldItems, newItem, true, this._multiselection);
        handled = true;
      }

      if (handled) {
        this._lastHandledEvent = event;
        (0, _Utils.preventDefault)(event);
      }
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      if (this._isDropdownTarget(event.target) || this._isButtonTarget(event.target)) {
        return;
      }

      this.close();
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = event || window.event;
      var keycode = event.which || event.keyCode;

      if (keycode === Inputs.KEY_ESCAPE) {
        // handle Escape key (ESC)
        if (this.isOpen()) {
          this.close();
        }
        evt.preventDefault();
        return;
      }

      if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN) {
        // Up and down arrows

        var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
        if (options.length > 0) {

          var newIndex = 0;
          var oldOption = void 0;

          var focusedElement = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
          var searchFor = focusedElement ? CLASS_ITEM_FOCUSED : CLASS_ITEM_SELECTED;

          var newElement = void 0;

          for (var index = 0; index < options.length; index++) {
            var direction = keycode === Inputs.KEY_ARROW_DOWN ? 1 : -1;

            var item = new _DomElement3.default(options[index]);

            // search for selected or focusedElement elements
            if (item.hasClass(searchFor)) {
              oldOption = item;
              newIndex = index;

              // get the next not disabled element in the apropriate direction
              for (var count = 0; count < options.length; count++) {
                newIndex += direction;
                newIndex %= options.length;

                if (newIndex < 0) {
                  newIndex = options.length - 1;
                }

                newElement = new _DomElement3.default(options[newIndex]);
                if (!newElement.hasClass(CLASS_ITEM_DISABLED)) {
                  break;
                }
              }
            }
          }

          // set the new element focused
          var newOption = new _DomElement3.default(options[newIndex]);
          newOption.addClass(CLASS_ITEM_FOCUSED);

          if (oldOption) {
            oldOption.removeClass(CLASS_ITEM_FOCUSED);
          }
        }

        evt.preventDefault();
        return;
      }

      if (keycode === Inputs.KEY_ENTER) {
        // Handle enter key by selecting the currently focused element
        var newItem = this._wrapperElement.element.querySelector("." + CLASS_ITEM_FOCUSED);
        var oldItems = Array.apply(undefined, (0, _toConsumableArray3.default)(this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED)));
        this._selectedItemChanged(oldItems, newItem, true, this._multiselection);
      }
    }

    /**
     * Gets the value of the currently selected option.
     * If multiple selection is enabled this property returns an array of values.
     */

  }, {
    key: "addEventListener",


    /**
     * Registers an event listener on the select control.
     */
    value: function addEventListener(type, listener) {
      this.element.addEventListener(type, listener);
    }

    /**
     * Reloads the dropdown's option data definitions from the DOM and updates
     * the generated dropdown display items.
     */

  }, {
    key: "reload",
    value: function reload() {
      // Remove all existing child elements
      while (this._dropdownElement.element.firstChild) {
        this._dropdownElement.element.removeChild(this._dropdownElement.element.firstChild);
      }

      this._setupPlaceholder();
      this._createOptions(this.element);

      this._updateSize();
      this._updateMessage();
    }

    /**
     * Sets the select control to the enabled state.
     */

  }, {
    key: "enable",
    value: function enable() {
      this.element.removeAttribute("disabled");
      this._wrapperElement.removeClass(CLASS_DISABLED);

      window.addEventListener("click", this._windowClickHander);

      this._wrapperElement.element.addEventListener("click", this._clickHandler);
      this._wrapperElement.element.addEventListener("keydown", this._keydownHandler);
      this._wrapperElement.element.addEventListener("focus", this._focusHandler);
      this._wrapperElement.element.addEventListener("blur", this._blurHandler);
    }

    /**
     * Sets the select control to the disabled state.
     */

  }, {
    key: "disable",
    value: function disable() {
      this.element.setAttribute("disabled", "");
      this._wrapperElement.addClass(CLASS_DISABLED);

      window.removeEventListener("click", this._windowClickHander);

      this._wrapperElement.element.removeEventListener("click", this._clickHandler);
      this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
      this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
      this._wrapperElement.element.removeEventListener("blur", this._blurHandler);

      this.close();
    }

    /**
     * Toggles the open/closed state of the select dropdown.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.isOpen()) {
        this.close();
      } else {
        this.open();
      }
    }

    /**
     * Gets if the select dropdown is open or closed.
     * @return {boolean} True if open; otherwise false.
     */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this._wrapperElement.hasClass(CLASS_OPEN);
    }

    /**
     * Opens the select dropdown.
     */

  }, {
    key: "open",
    value: function open() {
      if (!this.isOpen()) {
        this._openByFocus = false;

        this._wrapperElement.removeClass(CLASS_CLOSED);
        this._wrapperElement.addClass(CLASS_OPEN);

        this._dropdownElement.element.addEventListener("click", this._handleDropdownClick);
        this._dropdownElement.element.addEventListener("tap", this._handleDropdownClick);
      }
    }

    /**
     * Closes the select dropdown.
     */

  }, {
    key: "close",
    value: function close() {
      if (this.isOpen()) {
        this._openByFocus = false;

        this._wrapperElement.removeClass(CLASS_OPEN);
        this._wrapperElement.addClass(CLASS_CLOSED);

        this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
        this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);

        var focusedItem = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
        if (focusedItem) {
          focusedItem.removeClass(CLASS_ITEM_FOCUSED);
        }
      }
    }

    /**
     * Destroys the component and clears all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener("click", this._windowClickHander);

      if (this._dropdownElement) {
        this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
        this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);

        (0, _Utils.remove)(this._dropdownElement.element);
        this._dropdownElement = undefined;
      }

      if (this._wrapperElement) {
        this._wrapperElement.element.removeEventListener("click", this._clickHandler);
        this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
        this._wrapperElement.element.removeEventListener("blur", this._blurHandler);

        this._wrapperElement = undefined;
      }

      if (this._selectButtonElement) {
        (0, _Utils.remove)(this._selectButtonElement.element);
        this._selectButtonElement = undefined;
      }

      this.removeClass(CLASS_CLOSED);
    }
  }, {
    key: "value",
    get: function get() {
      if (this._multiselection) {
        return Array.apply(undefined, (0, _toConsumableArray3.default)(this.element.selectedOptions)).map(function (x) {
          return x.value;
        });
      }

      if (this.element.value === "") {
        return null;
      }

      return this.element.value;
    }

    /**
     * Enables or disables the select component depending on the
     * 'value' parameter.
     * @param {value} If true disables the control; false enables it.
     */

  }, {
    key: "disabled",
    set: function set(value) {
      if (value) {
        this.disable();
      } else {
        this.enable();
      }
    }
  }]);
  return Select;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)("select", function (e) {
    new Select(e);
  });
}

exports.default = Select;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"babel-runtime/helpers/toConsumableArray":48}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _maxSafeInteger = require("babel-runtime/core-js/number/max-safe-integer");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_TEXTAREA = "textarea";
var CLASS_HAS_VALUE = "is-fixed";

/**
 * Textarea component
 */

var Textarea = function (_DomElement) {
  (0, _inherits3.default)(Textarea, _DomElement);

  function Textarea(element) {
    (0, _classCallCheck3.default)(this, Textarea);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Textarea.__proto__ || (0, _getPrototypeOf2.default)(Textarea)).call(this, element));

    _this._area = _this.element.querySelector(QUERY_TEXTAREA);

    _this._focusChangedHandler = _this._focusChanged.bind(_this);
    _this._valueChangedHander = _this._onValueChanged.bind(_this);
    _this._resizeHandler = _this._updateHeight.bind(_this);

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the textarea component.
   * @private
   */


  (0, _createClass3.default)(Textarea, [{
    key: "_initialize",
    value: function _initialize() {
      this._minRows = this._area.getAttribute("data-min-rows") || 3;
      this._maxRows = this._area.getAttribute("data-max-rows") || _maxSafeInteger2.default;

      // Make sure min an max are property specified
      this._minRows = Math.min(this._minRows, this._maxRows);
      this._maxRows = Math.max(this._minRows, this._maxRows);

      this._lineHeight = parseInt(this._css(this._area, "line-height"), 10);

      this._updateBaseHeight = Dom.isHidden(this._area, true);
      this._calculateBaseHeight();

      // add event listeners
      this._area.addEventListener("focus", this._focusChangedHandler);
      this._area.addEventListener("blur", this._focusChangedHandler);
      this._area.addEventListener("input", this._valueChangedHander);

      window.addEventListener("resize", this._resizeHandler);
      window.addEventListener("orientationchange", this._resizeHandler);

      this._onValueChanged();
    }
  }, {
    key: "_calculateBaseHeight",
    value: function _calculateBaseHeight() {
      // temporary clear the content to take measurements
      var value = this._area.value;
      this._area.value = "";

      this._baseHeight = this._area.offsetHeight - this._lineHeight;
      this._baseScrollHeight = this._area.scrollHeight - this._lineHeight;

      // restore initial content
      this._area.value = value;
    }
  }, {
    key: "_focusChanged",
    value: function _focusChanged() {
      this._updateHeight();
    }
  }, {
    key: "_css",
    value: function _css(element, property) {
      return window.getComputedStyle(element, null).getPropertyValue(property);
    }
  }, {
    key: "_updateHeight",
    value: function _updateHeight() {
      var hasFocus = this._area === document.activeElement;
      var maxRows = void 0,
          rows = 0;

      if (this._updateBaseHeight === true && Dom.isHidden(this._area, true) === false) {
        this._calculateBaseHeight();
        this._updateBaseHeight = false;
      }

      // Calculate the apropriate size for the control
      if (!this._hasValue()) {
        // Handle empty states
        rows = hasFocus === true ? this._minRows : 1;
        maxRows = rows;
      } else {
        // Reset the height for calculation of the row count
        this._area.style.height = "auto";

        // Get the new height
        rows = Math.ceil((this._area.scrollHeight - this._baseScrollHeight) / this._lineHeight) + 1;
        maxRows = Math.max(Math.min(this._maxRows, rows), this._minRows);
      }

      if (rows > this._maxRows) {
        this._area.style.overflow = "auto";
      } else {
        this._area.style.overflow = "hidden";
      }

      var height = (maxRows - 1) * this._lineHeight + this._baseHeight;
      this._area.style.height = height + "px";
    }
  }, {
    key: "_hasValue",
    value: function _hasValue() {
      return this._area.value && this._area.value.length > 0;
    }
  }, {
    key: "_onValueChanged",
    value: function _onValueChanged() {
      if (this._hasValue()) {
        Dom.addClass(this._area, CLASS_HAS_VALUE);
      } else {
        Dom.removeClass(this._area, CLASS_HAS_VALUE);
        this._area.value = "";
      }

      this._updateHeight();
    }

    /**
     * Destroys the component and clears all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener("resize", this._resizeHandler);
      window.removeEventListener("orientationchange", this._resizeHandler);

      this._area.removeEventListener("focus", this._focusChangedHandler);
      this._area.removeEventListener("blur", this._focusChangedHandler);
      this._area.removeEventListener("input", this._valueChangedHander);

      this._focusChangedHandler = null;
      this._valueChangedHander = null;
      this._area = null;
      this._minRows = null;
      this._maxRows = null;
      this._lineHeight = null;
      this._baseHeight = null;
      this._baseScrollHeight = null;
      this.element = null;
    }
  }]);
  return Textarea;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".input-multiline", function (e) {
    new Textarea(e);
  });
}

exports.default = Textarea;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/number/max-safe-integer":37,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Loader bar component
 */
var LoaderBar = function (_DomElement) {
  (0, _inherits3.default)(LoaderBar, _DomElement);

  /**
   * Creates and initializes the LoaderBar component.
   * @param {Element} - The root element of the LoaderBar component.
   */
  function LoaderBar(element) {
    (0, _classCallCheck3.default)(this, LoaderBar);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoaderBar.__proto__ || (0, _getPrototypeOf2.default)(LoaderBar)).call(this, element));

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the loader bar component.
   * @private
   */


  (0, _createClass3.default)(LoaderBar, [{
    key: "_initialize",
    value: function _initialize() {
      this.progressElement = this.find(".indicator") || this.element;
      this.fileNameElement = this.find(".detail > .name");
      this.progressLabelElement = this.find(".progress");
      this.totalProgressElement = this.find(".progress > .file-size");
    }

    /**
     * Gets the current progress value in the range of 0..1.
     */

  }, {
    key: "progress",
    get: function get() {
      return this.value;
    }

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 0..1.
     */
    ,
    set: function set(val) {
      // val = clamp(val, 0, 1)

      var percentage = (val * 100).toFixed(0);

      this.value = val;
      this.element.value = val;

      this.progressElement.setAttribute("style", "width: " + val * 100 + "%");

      if (this.progressLabelElement) {
        this.progressLabelElement.element.textContent = percentage + "%";
      }
    }

    /**
     * Gets the filename.
     * @returns {string} - The filename.
     */

  }, {
    key: "filename",
    get: function get() {
      if (!this.fileNameElement) {
        return undefined;
      }

      return this.fileNameElement.element.innerHtml;
    }

    /**
     * Sets the filename.
     */
    ,
    set: function set(val) {
      if (!this.fileNameElement) {
        throw new Error("Cannot set the filename, missing detail element");
      }

      this.fileNameElement.setHtml(val);
    }

    /**
     * Sets the file size label.
     */

  }, {
    key: "fileSize",
    set: function set(val) {
      if (!this.totalProgressElement) {
        throw new Error("Cannot set the fileSize, missing detail element");
      }

      this.fileSize.setHtml(val);
    }
  }]);
  return LoaderBar;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".loader-bar", function (e) {
    new LoaderBar(e);
  });
}

exports.default = LoaderBar;

},{"../DomElement":4,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_OPEN = "is-open";
var CLASS_MENU = "js-flyout";

var ANIMATION_OPEN = 0.3;

/**
 * The flyout menu component.
 */

var MenuFlyout = function (_DomElement) {
  (0, _inherits3.default)(MenuFlyout, _DomElement);

  /**
   * Creates and initializes the flyout component.
   * @param {DomElement} - The root element of the flyout menu component.
   */
  function MenuFlyout(element) {
    (0, _classCallCheck3.default)(this, MenuFlyout);

    var _this = (0, _possibleConstructorReturn3.default)(this, (MenuFlyout.__proto__ || (0, _getPrototypeOf2.default)(MenuFlyout)).call(this, element));

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);

    _this._animationDuration = ANIMATION_OPEN;

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the flyout component.
   * @private
   */


  (0, _createClass3.default)(MenuFlyout, [{
    key: "_initialize",
    value: function _initialize() {
      var dataTarget = this.element.getAttribute("data-target");
      if (dataTarget === null || dataTarget === "") {

        /* eslint-disable no-console */
        console.error("A flyout menu element requires a 'data-target' that specifies the element to collapse");
        console.info(this.element);
        /* eslint-enable no-console */

        return;
      }

      var hiddenTarget = this.element.getAttribute("data-hidden");
      if (hiddenTarget !== null && hiddenTarget !== "") {
        this._hiddenIndicator = document.querySelector(hiddenTarget);
      }

      this._flyoutElement = document.querySelector(dataTarget);
      this.element.addEventListener("click", this._clickHandler);
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      (0, _Utils.preventDefault)(event);
      this.toggle();
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      var target = event.target;

      if ((0, _DomFunctions.parentWithClass)(target, CLASS_MENU) === this._flyoutElement) {
        return false;
      }

      while (target !== this.element && target.parentElement) {
        target = target.parentElement;
      }

      if (target !== this.element) {
        this.close();
        return false;
      }

      return true;
    }
  }, {
    key: "_openMenu",
    value: function _openMenu(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.set(el, {
        display: "block"
      });

      _gsap.TweenLite.to(el, this._animationDuration, {
        className: "+=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      // set aria expanded
      el.setAttribute("aria-expanded", true);
    }
  }, {
    key: "_closeMenu",
    value: function _closeMenu(el) {
      _gsap.TweenLite.killTweensOf(el);

      _gsap.TweenLite.to(el, ANIMATION_OPEN, {
        className: "-=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut],
        onComplete: function onComplete() {
          _gsap.TweenLite.set(el, {
            clearProps: "display"
          });
        }
      });

      // set aria expanded
      el.setAttribute("aria-expanded", false);
    }

    /**
     * Sets the opening animation duration.
     * @param {durationInSeconds} - The animation duration in seconds.
     */

  }, {
    key: "open",


    /**
     * Opens the flyout menu.
     */
    value: function open() {
      var _this2 = this;

      if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
        return;
      }

      if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === true) {
        return;
      }

      (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
      this._openMenu(this._flyoutElement);

      setTimeout(function () {
        window.addEventListener("click", _this2._windowClickHander);
        window.addEventListener("touchend", _this2._windowClickHander);
      }, 50);
    }

    /**
     * Closes the flyout menu.
     */

  }, {
    key: "close",
    value: function close() {
      if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
        return;
      }

      if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
        return;
      }

      (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);

      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);

      this._closeMenu(this._flyoutElement);
    }

    /**
     * Toggles the flyout menu.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
        this.open();
      } else {
        this.close();
      }
    }

    /**
     * Removes all event handlers and clears references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._flyoutElement = null;

      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);

      if (this._clickHandler) {
        this.element.removeEventListener(this._clickHandler);
      }

      this._clickHandler = null;
      this._windowClickHander = null;
      this.element = null;
    }
  }, {
    key: "animationDuration",
    set: function set(durationInSeconds) {
      this._animationDuration = durationInSeconds;
    }
  }]);
  return MenuFlyout;
}(_DomElement3.default);

function init() {
  var elements = document.querySelectorAll("[data-toggle='flyout']");
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(elements), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var e = _step.value;

      if (e.getAttribute("data-init") === "auto") {
        new MenuFlyout(e);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

exports.default = MenuFlyout;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_BACKDROP = "backdrop";
var CLASS_BACKDROP_OPEN = "backdrop--open";

var CLASS_OPEN = "modal--open";
var CLASS_TRIGGER = "modal-trigger";

var CLASS_BUTTONS_OKAY = ".modal-close";
var CLASS_BUTTONS_CLOSE = ".modal-cancel";

/**
 * The modal dialog component definition.
 */

var Modal = function (_DomElement) {
  (0, _inherits3.default)(Modal, _DomElement);

  function Modal(element) {
    (0, _classCallCheck3.default)(this, Modal);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Modal.__proto__ || (0, _getPrototypeOf2.default)(Modal)).call(this, element));

    _this._okayHandler = _this.close.bind(_this);
    _this._cancelHandler = _this._handleClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the range modal component.
   * @private
   */


  (0, _createClass3.default)(Modal, [{
    key: "_initialize",
    value: function _initialize() {

      // Create the backdrop
      this._backdrop = new _DomElement3.default("div").addClass(CLASS_BACKDROP);

      this._backdropParent = (0, _DomFunctions.getRootElement)();
      this._subscribeToTrigger();
    }
  }, {
    key: "_subscribeToTrigger",
    value: function _subscribeToTrigger() {
      var triggerId = this.element.id;
      if (!triggerId) {
        return;
      }

      this._triggerClickHander = this.open.bind(this);

      var triggerElement = document.querySelector("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
      if (triggerElement) {
        triggerElement.addEventListener("click", this._triggerClickHander);
      }
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = evt || window.event;
      var keycode = event.which || event.keyCode;

      if (keycode === Inputs.KEY_ESCAPE) {
        // handle Escape key (ESC)
        this.cancel();
        return;
      }
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      (0, _Utils.preventDefault)(event);
      this.cancel();
    }
  }, {
    key: "_close",
    value: function _close() {
      var _this2 = this;

      document.removeEventListener("keydown", this._keydownHandler);
      this._backdrop.element.removeEventListener("click", this._cancelHandler);

      this._backdrop.removeClass(CLASS_BACKDROP_OPEN);
      this.removeClass(CLASS_OPEN);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var closeButton = _step.value;

          closeButton.removeEventListener("click", this._cancelHandler);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var okayButton = _step2.value;

          okayButton.removeEventListener("click", this._okayHandler);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      setTimeout(function () {
        // add the backdrop to the body
        _this2._backdropParent.removeChild(_this2._backdrop.element);
      }, 300);
    }

    /**
     * Opens the modal dialog.
     */

  }, {
    key: "open",
    value: function open() {
      var _this3 = this;

      // add the backdrop to the body
      this._backdropParent.appendChild(this._backdrop.element);

      // set the element to flex as it is initially hidden
      this.element.style.display = "flex";

      // remove the style after the animation completes
      setTimeout(function () {
        _this3.element.style.display = "";
      }, 800);

      // wait a bit to allow the browser to catch up and show the animation
      setTimeout(function () {
        _this3.addClass(CLASS_OPEN);
        _this3._backdrop.addClass(CLASS_BACKDROP_OPEN);

        document.addEventListener("keydown", _this3._keydownHandler);

        _this3._backdrop.element.addEventListener("mousedown", _this3._handleButtonDown);
        _this3._backdrop.element.addEventListener("click", _this3._cancelHandler);

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator3.default)(_this3.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var closeButton = _step3.value;

            closeButton.addEventListener("click", _this3._cancelHandler);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _getIterator3.default)(_this3.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var okayButton = _step4.value;

            okayButton.addEventListener("click", _this3._okayHandler);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        _this3.dispatchEvent("opened");
      }, 50);
    }

    /**
     * Cancels (and closes) the modal dialog.
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this.dispatchEvent("cancelled");
      this._close();
    }

    /**
     * Closes the modal dialog.
     */

  }, {
    key: "close",
    value: function close() {
      this._close();
      this.dispatchEvent("closed");
    }
  }]);
  return Modal;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".modal", function (e) {
    new Modal(e);
  });
}

exports.default = Modal;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

var _SearchInput = require("../search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";

var QUERY_NAV_HAMBURGER = ".nav-hamburger";
var QUERY_NAV_HB_BODY = ".nav__primary";

var CLASS_NAV_LINK = "nav-link--header";
var QUERY_NAV_LINK_ACTIVE = ".nav-link--header.is-active";

var QUERY_NAV_MOBILE = ".nav__level1 .nav__mainnav .nav__primary";
var QUERY_NAV_LEVEL0 = ".nav__level0";
var QUERY_NAV_LEVEL0_CONTAINER = ".nav__level0 .nav__subnav";
var QUERY_SECTION_OPEN = ".nav-section.is-open";

var QUERY_NAV_LEVEL1 = ".nav__level1 .nav__mainnav";

var QUERY_NAV_LEVEL0_LINK = ".nav-link.nav-link--header";
var QUERY_NAV_LEVEL1_LINK = ".nav-link--header";

var QUERY_NAV_COLUMN = ".nav-col";
var QUERY_NAV_COLUMN_ACTIVE = ".nav-col.is-active";

var QUERY_NAV_BODY = ".nav-body";
var QUERY_NAV_FOOTER = ".nav-footer";

var QUERY_SEARCH_ICON = ".nav-search";
var QUERY_SEARCH_FIELD = ".search__input";
var CLASS_SEARCH_DESKTOP = "search--desktop";

var ANIMATION_START_DELAY = 0.2;
var ANIMATION_OFFSET = 0.05;

var ANIMATION_BODY_DURATION = 0.3;
var ANIMATION_FOOTER_DURATION = 0.1;

/**
 * The navigation component definition.
 */

var Navigation = function (_DomElement) {
  (0, _inherits3.default)(Navigation, _DomElement);

  function Navigation(element) {
    (0, _classCallCheck3.default)(this, Navigation);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Navigation.__proto__ || (0, _getPrototypeOf2.default)(Navigation)).call(this, element));

    _this._navLevel0 = _this.element.querySelector(QUERY_NAV_LEVEL0) || document.createElement("div");
    _this._navLevel0Body = _this.element.querySelector(QUERY_NAV_LEVEL0_CONTAINER) || document.createElement("div");
    _this._navLevel1 = _this.element.querySelector(QUERY_NAV_LEVEL1) || document.createElement("div");

    _this._navMobile = _this.element.querySelector(QUERY_NAV_MOBILE);
    if (!_this._navMobile) {
      var dummyParent = document.createElement("div");
      _this._navMobile = document.createElement("div");
      dummyParent.appendChild(_this._navMobile);
    }

    _this._hamburgerElement = _this.element.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
    _this._searchComponents = [];

    _this._level0ClickHandler = _this._handleLevel0Click.bind(_this);
    _this._level1ClickHandler = _this._handleLevel1Click.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);
    _this._searchClickHandler = _this._handleSearchClick.bind(_this);

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(Navigation, [{
    key: "_resetMainTimeline",
    value: function _resetMainTimeline() {
      var _this2 = this;

      if (this._tlMain) {
        this._tlMain.stop();
      }

      this._tlMain = new _gsap.TimelineLite({
        onComplete: function onComplete() {
          _this2._tlMain = undefined;
        }
      });
    }
  }, {
    key: "_isMobile",
    value: function _isMobile() {
      return Dom.isHidden(this._hamburgerElement, true) === false;
    }
  }, {
    key: "_handleLevel0Click",
    value: function _handleLevel0Click(event) {
      var isDesktop = !this._isMobile();

      if (isDesktop) {
        this._resetMainTimeline();

        var navItems = new NavigationItems(this).fromLevel0(event.target);

        if (!navItems.section) {
          return;
        }

        var previousNavLink = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
        var previousNavSection = this._navLevel0.querySelector(QUERY_SECTION_OPEN);

        this._toggleContainer(navItems.link, this._navLevel0Body, navItems.section, undefined, previousNavLink, this._navLevel0Body, previousNavSection, undefined, true);
      }
    }
  }, {
    key: "_handleLevel1Click",
    value: function _handleLevel1Click(event) {
      var navItems = new NavigationItems(this).fromLevel1(event.target);

      var prevItems = navItems.previousLevel1();

      this._toggleContainer(navItems.link, navItems.container, navItems.section, navItems.footer, prevItems.link, prevItems.container, prevItems.section, prevItems.footer, false);

      return false;
    }
  }, {
    key: "_toggleContainer",
    value: function _toggleContainer(navLink, navContainer, navSection, navFooter, previousNavLink, previousNavContainer, previousNavSection, previousNavFooter) {
      var animateContainer = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

      var isDesktop = !this._isMobile();

      if (previousNavLink && previousNavLink !== navLink && navLink !== this._hamburgerElement) {
        Dom.removeClass(previousNavLink, CLASS_ACTIVE);
      }

      if (Dom.hasClass(navLink, CLASS_ACTIVE)) {
        Dom.removeClass(navLink, CLASS_ACTIVE);

        if (isDesktop) {
          this._onNavigationClosed();

          this._resetMainTimeline();
          this._closeSection(navContainer, navSection, navFooter, this._tlMain, true, animateContainer);
        } else if (navLink === this._hamburgerElement) {
          // Close mobile navigation
          this._onNavigationClosed();

          this._resetMainTimeline();
          this._closeSection(navContainer, navSection, undefined, this._tlMain, false, false);
        } else if (!isDesktop) {
          // Close the section
          this._closeSection(navContainer, navSection, navFooter, undefined, true, animateContainer);
        }
      } else {
        Dom.addClass(navLink, CLASS_ACTIVE);

        if (isDesktop) {
          Dom.addClass(this._navMobile, CLASS_OPEN);
          this._onNavigationOpened();
          this._resetMainTimeline();

          if (previousNavContainer && previousNavSection) {
            this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, this._tlMain, true, animateContainer);
          }
          this._openSection(navContainer, navSection, navFooter, this._tlMain, true, animateContainer);
        } else if (navLink === this._hamburgerElement) {
          // Open mobile navigation
          this._onNavigationOpened();

          this._resetMainTimeline();
          this._openSection(navContainer, navSection, undefined, this._tlMain, false, false);
        } else if (!isDesktop) {
          // Open section
          if (previousNavContainer && previousNavSection) {
            this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, undefined, true, animateContainer);
          }
          this._openSection(navContainer, navSection, navFooter, undefined, true, animateContainer);
        }
      }
    }
  }, {
    key: "_onNavigationOpened",
    value: function _onNavigationOpened() {
      Dom.addClass(this._navMobile, CLASS_OPEN);
      Dom.addClass(this._navMobile.parentElement, CLASS_OPEN);
      Dom.addClass(this._hamburgerElement, CLASS_ACTIVE);

      window.addEventListener("click", this._windowClickHander);
      window.addEventListener("touchend", this._windowClickHander);
    }
  }, {
    key: "_onNavigationClosed",
    value: function _onNavigationClosed() {
      Dom.removeClass(this._navMobile, CLASS_OPEN);
      Dom.removeClass(this._navMobile.parentElement, CLASS_OPEN);
      Dom.removeClass(this._hamburgerElement, CLASS_ACTIVE);

      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      var target = event.target;

      while (target !== this.element && target.parentElement) {
        target = target.parentElement;
      }

      if (target !== this.element) {
        this.close();
        return false;
      }

      return true;
    }
  }, {
    key: "_openSection",
    value: function _openSection(navContainer, navSection, navFooter, tl) {
      var animateColumns = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var animateContainer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      if (!navSection) {
        return;
      }

      var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN);

      if (animateContainer === true) {
        var container = navContainer;
        navContainer = navSection;
        navSection = container;
      }

      if (!tl) {
        tl = new _gsap.TimelineLite();
      }

      tl.set(navContainer, {
        className: "+=" + CLASS_OPEN
      });

      tl.set(navSection, {
        display: "block"
      });

      tl.to(navSection, ANIMATION_BODY_DURATION, {
        className: "+=" + CLASS_OPEN,
        clearProps: "all",
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      if (navFooter) {
        tl.set(navFooter.querySelectorAll(QUERY_NAV_COLUMN), {
          className: "+=" + CLASS_ACTIVE
        });

        tl.set(navFooter, {
          display: "block"
        }, 0);

        tl.to(navFooter, ANIMATION_FOOTER_DURATION, {
          className: "+=" + CLASS_OPEN,
          clearProps: "height, display",
          ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
        }, "-=0.1");
      }

      if (animateColumns === true) {
        var delay = ANIMATION_START_DELAY;
        var items = activeItems;

        for (var index = 0; index < items.length; index++) {
          tl.to(items[index], 0, {
            className: "+=" + CLASS_ACTIVE
          }, delay);
          delay += ANIMATION_OFFSET;
        }
      }
    }
  }, {
    key: "_closeSection",
    value: function _closeSection(navContainer, navSection, navFooter, tl) {
      var animateColumns = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var animateContainer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

      if (!navSection) {
        return;
      }

      var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE);

      if (animateContainer === true) {
        var container = navContainer;
        navContainer = navSection;
        navSection = container;
      }

      if (!tl) {
        tl = new _gsap.TimelineLite();
      }

      tl.set(navSection, {
        display: "block"
      });

      if (animateColumns === true) {
        tl.set(activeItems, {
          className: "-=" + CLASS_ACTIVE
        }, 0);
      }

      tl.to(navSection, ANIMATION_BODY_DURATION, {
        className: "-=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut],
        clearProps: "all",
        onComplete: function onComplete() {
          Dom.removeClass(navContainer, CLASS_OPEN);

          if (animateColumns === true) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = (0, _getIterator3.default)(activeItems), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var active = _step.value;

                Dom.removeClass(active, CLASS_ACTIVE);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }
      }, 0);

      if (navFooter) {
        tl.set(navFooter, {
          display: "block"
        }, 0);

        tl.to(navFooter, ANIMATION_FOOTER_DURATION, {
          className: "-=" + CLASS_OPEN,
          ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut],
          clearProps: "height,display",
          onComplete: function onComplete() {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = (0, _getIterator3.default)(navFooter.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var active = _step2.value;

                Dom.removeClass(active, CLASS_ACTIVE);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }, 0);
      }
    }
  }, {
    key: "_handleSearchClick",
    value: function _handleSearchClick() {
      this._searchDesktop.open();
    }

    /**
     * Initializes the navigation component.
     * @private
     */

  }, {
    key: "_initialize",
    value: function _initialize() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)(this._navLevel0.querySelectorAll(QUERY_NAV_LEVEL0_LINK)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var navLink = _step3.value;

          navLink.addEventListener("click", this._level0ClickHandler);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)(this._navLevel1.querySelectorAll(QUERY_NAV_LEVEL1_LINK)), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _navLink = _step4.value;

          _navLink.addEventListener("click", this._level1ClickHandler);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._hamburgerElement.addEventListener("click", this._level1ClickHandler);

      // Desktop search icon
      var searchIcon = this.element.querySelector(QUERY_SEARCH_ICON);
      if (searchIcon) {
        searchIcon.addEventListener("click", this._searchClickHandler);
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_SEARCH_FIELD)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var search = _step5.value;

          var searchComponent = new _SearchInput2.default(search);

          if (Dom.hasClass(search, CLASS_SEARCH_DESKTOP) || Dom.hasClass(search.parentNode, CLASS_SEARCH_DESKTOP)) {
            this._searchDesktop = searchComponent;
          }

          this._searchComponents.push(searchComponent);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    /**
     * Closes the navigation.
     */

  }, {
    key: "close",
    value: function close() {
      var isMoble = this._isMobile();
      this._resetMainTimeline();

      var level1 = this._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
      var level0 = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);

      if (!level1 && isMoble && Dom.hasClass(this._hamburgerElement, CLASS_ACTIVE)) {
        level1 = this._hamburgerElement;
      }

      if (level1) {
        var navItems = new NavigationItems(this).fromLevel1(level1);

        Dom.removeClass(navItems.link, CLASS_ACTIVE);
        this._onNavigationClosed();
        this._closeSection(navItems.container, navItems.section, navItems.footer, this._tlMain, !isMoble, false);
      }

      if (level0) {
        var _navItems = new NavigationItems(this).fromLevel0(level0);

        Dom.removeClass(_navItems.link, CLASS_ACTIVE);
        this._onNavigationClosed();
        this._closeSection(_navItems.container, _navItems.section, _navItems.footer, this._tlMain, !isMoble, true);
      }
    }
  }]);
  return Navigation;
}(_DomElement3.default);

var NavigationItems = function () {
  function NavigationItems(nav) {
    (0, _classCallCheck3.default)(this, NavigationItems);

    this._navigation = nav;

    this._link = undefined;
    this._container = undefined;
    this._section = undefined;
    this._footer = undefined;
  }

  (0, _createClass3.default)(NavigationItems, [{
    key: "fromLevel0",
    value: function fromLevel0(navLink) {
      while (!Dom.hasClass(navLink, CLASS_NAV_LINK) && navLink.parentElement) {
        navLink = navLink.parentElement;
      }

      this._link = navLink;

      var toggleId = navLink.getAttribute("data-toggle");
      this._container = this._navigation._navLevel0Body;
      this._section = this._navigation._navLevel0.querySelector("#" + toggleId);

      return this;
    }
  }, {
    key: "fromLevel1",
    value: function fromLevel1(navLink) {
      while (navLink.parentElement) {
        if (navLink === this._navigation._hamburgerElement || Dom.hasClass(navLink, CLASS_NAV_LINK)) {
          break;
        }

        navLink = navLink.parentElement;
      }

      this._link = navLink;
      this._container = navLink.parentElement;
      this._section = this._container.querySelector(QUERY_NAV_BODY);
      this._footer = this._container.querySelector(QUERY_NAV_FOOTER);

      if (navLink === this._navigation._hamburgerElement) {
        this._container = this._navigation._navLevel1;
        this._section = this._container.querySelector(QUERY_NAV_HB_BODY);
      }

      return this;
    }
  }, {
    key: "previousLevel1",
    value: function previousLevel1() {
      var prev = new NavigationItems(this._navigation);

      prev._link = this._navigation._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
      prev._container = prev._link ? prev._link.parentElement : undefined;
      prev._section = prev._container ? prev._container.querySelector(QUERY_NAV_BODY) : undefined;
      prev._footer = prev._container ? prev._container.querySelector(QUERY_NAV_FOOTER) : undefined;

      return prev;
    }
  }, {
    key: "isHamburger",
    value: function isHamburger() {
      return this._link === this._navigation._hamburgerElement;
    }
  }, {
    key: "link",
    get: function get() {
      return this._link;
    }
  }, {
    key: "container",
    get: function get() {
      return this._container;
    }
  }, {
    key: "section",
    get: function get() {
      return this._section;
    }
  }, {
    key: "footer",
    get: function get() {
      return this._footer;
    }
  }]);
  return NavigationItems;
}();

function init() {
  (0, _Utils.searchAndInitialize)(".nav", function (e) {
    new Navigation(e);
  });
}

exports.default = Navigation;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"../search/SearchInput":29,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _gsap = require("gsap");

var _DomFunctions = require("../DomFunctions");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";

var QUERY_SITE_WRAPPER = ".js-site-wrapper";
var QUERY_NAV_HAMBURGER = ".js-site-wrapper .js-hamburger";

var QUERY_NAV_ITEM = ".js-nav-item";

var NAV_LINK_INITIAL_SCALE = 0.9;
var ANIMATION_DURATION_LINKS = 0.1;
var ANIMATION_DURATION_NAV = 0.3;

var ANIMATION_STAGGER_DELAY = 0.05;

/**
 * The navigation side component definition.
 */

var NavigationSide = function (_DomElement) {
  (0, _inherits3.default)(NavigationSide, _DomElement);

  function NavigationSide(element) {
    (0, _classCallCheck3.default)(this, NavigationSide);

    var _this = (0, _possibleConstructorReturn3.default)(this, (NavigationSide.__proto__ || (0, _getPrototypeOf2.default)(NavigationSide)).call(this, element));

    _this._clickHandler = _this._handleClick.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);

    _this._siteWrapper = document.querySelector(QUERY_SITE_WRAPPER);
    _this._hamburgerElement = document.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
    _this._navItems = _this.element.querySelectorAll(QUERY_NAV_ITEM);

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(NavigationSide, [{
    key: "_initialize",
    value: function _initialize() {
      this._hamburgerElement.addEventListener("click", this._clickHandler);
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      (0, _Utils.preventDefault)(event);
      this.toggle();
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      var target = event.target;

      while (target !== this.element && target.parentElement) {
        target = target.parentElement;
      }

      if (target !== this.element) {
        this.close();
        return false;
      }

      return true;
    }

    /**
     * Toggles the side navigation.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
        this.open();
      } else {
        this.close();
      }
    }

    /**
     * Opens the slide navigation.
     */

  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      var elements = [this.element, this._siteWrapper];
      _gsap.TweenLite.killTweensOf(elements);

      setTimeout(function () {
        window.addEventListener("click", _this2._windowClickHander);
        window.addEventListener("touchend", _this2._windowClickHander);
      }, 50);

      var tl = new _gsap.TimelineLite();

      (0, _DomFunctions.addClass)(this._hamburgerElement, CLASS_ACTIVE);

      tl.to(elements, ANIMATION_DURATION_NAV, {
        className: "+=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      tl.staggerFrom(this._navItems, ANIMATION_DURATION_LINKS, {
        autoAlpha: 0,
        scaleX: NAV_LINK_INITIAL_SCALE,
        scaleY: NAV_LINK_INITIAL_SCALE
      }, ANIMATION_STAGGER_DELAY);
    }

    /**
     * Closes the side navigation.
     */

  }, {
    key: "close",
    value: function close() {
      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);

      var elements = [this.element, this._siteWrapper];
      _gsap.TweenLite.killTweensOf(elements);

      (0, _DomFunctions.removeClass)(this._hamburgerElement, CLASS_ACTIVE);

      var tl = new _gsap.TimelineLite();

      tl.to(elements, ANIMATION_DURATION_NAV, {
        className: "-=" + CLASS_OPEN,
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });
    }

    /**
     * Destorys the component and removes all event
     * subscriptions and references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);

      this._windowClickHander = null;

      this._clickHandler = null;
      this._siteWrapper = null;

      this._hamburgerElement = null;
      this._navItems = null;
    }
  }]);
  return NavigationSide;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".nav-side", function (e) {
    new NavigationSide(e);
  });
}

exports.default = NavigationSide;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.showOnHeader = showOnHeader;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_NOTIFICATION = "notification-header";

var CLASS_OPEN = "notification--open";
var CLASS_BUTTON_CLOSE = "notification__close";

/**
 * Creates and shows a notification with the specified message.
 * @param {containerId} The id of the container on where to show the notification.
 * @param {message} The message to show.
 * @param {messageClickCallback} The callback that gets called when the user clicks on the notification message text.
 * @param {cancelCallback} The callback that gets called when the user cancels the notification by closing it.
 * @param {modifierClass} The css modifier class for the notification; this is an optional parameter
 */
function showOnHeader(containerId, message) {
  var messageClickCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  var cancelCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
  var modifierClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;


  var containerE = document.querySelector("#" + containerId);
  if (!containerE) {
    throw new Error("Could not find the container with id " + containerId);
  }

  var containerElement = new _DomElement3.default(containerE);
  var notificationElement = new NotificationHeader();

  if (modifierClass) {
    notificationElement.addClass(modifierClass);
  }

  notificationElement.message = message;
  notificationElement.messageClickCallback = messageClickCallback;
  notificationElement.cancelCallback = cancelCallback;

  containerElement.appendChild(notificationElement);
  notificationElement._open();

  return notificationElement;
}

/**
 * The notification component definition.
 */

var NotificationHeader = function (_DomElement) {
  (0, _inherits3.default)(NotificationHeader, _DomElement);

  function NotificationHeader() {
    (0, _classCallCheck3.default)(this, NotificationHeader);

    var _this = (0, _possibleConstructorReturn3.default)(this, (NotificationHeader.__proto__ || (0, _getPrototypeOf2.default)(NotificationHeader)).call(this, "div"));

    _this._closeHandler = _this._handleClose.bind(_this);
    _this._clickHandler = _this._handleClick.bind(_this);

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the range modal component.
   * @private
   */


  (0, _createClass3.default)(NotificationHeader, [{
    key: "_initialize",
    value: function _initialize() {
      this.addClass(CLASS_NOTIFICATION);
      this.addClass(CLASS_OPEN);

      var notificationContent = new _DomElement3.default("div").addClass("notification__content");

      this.appendChild(notificationContent);

      this._notificationBody = new _DomElement3.default("div").addClass("notification__body");

      notificationContent.appendChild(this._notificationBody);

      this._closeButton = new _DomElement3.default("button").addClass(CLASS_BUTTON_CLOSE).addClass("notification-cancel").setAttribute("aria-label", "Close");

      var closeIcon = new _DomElement3.default("i").addClass("icon").addClass("icon-022-close").setAttribute("aria-hidden", true);

      this._closeButton.appendChild(closeIcon);
      notificationContent.appendChild(this._closeButton);

      this.element.addEventListener("click", this._clickHandler);
    }
  }, {
    key: "_handleClick",
    value: function _handleClick(event) {
      (0, _Utils.preventDefault)(event);

      if (this._callback) {
        this._callback(this);
      }

      this.close();
    }
  }, {
    key: "_handleClose",
    value: function _handleClose(event) {
      (0, _Utils.preventDefault)(event);
      event.stopPropagation();

      if (this._cancelCallback) {
        this._cancelCallback(this);
      }

      this.close();
    }
  }, {
    key: "_close",
    value: function _close(event) {
      if (event) {
        event.stopPropagation();
      }

      this.removeClass(CLASS_OPEN);
      this._closeButton.element.removeEventListener("click", this._closeHandler);

      var el = this.element;
      setTimeout(function () {
        // remove the element from the dom
        el.parentElement.removeChild(el);
      }, 300);
    }
  }, {
    key: "_open",
    value: function _open() {
      this.addClass(CLASS_OPEN);

      this._closeButton.element.addEventListener("click", this._closeHandler);
      this.dispatchEvent("opened");
    }
  }, {
    key: "close",


    /**
     * Closes the notification.
     */
    value: function close() {
      this._close();
      this.dispatchEvent("closed");
    }
  }, {
    key: "messageClickCallback",
    set: function set(callback) {
      this._callback = callback;
    }

    /**
     * Sets the cancel callback function.
     * @param {function} - The callback function to call.
     */

  }, {
    key: "cancelCallback",
    set: function set(callback) {
      this._cancelCallback = callback;
    }

    /**
     * Sets the notification message.
     * @param {String} - The message to set.
     */

  }, {
    key: "message",
    set: function set(value) {
      this._notificationBody.setHtml(value);
    }
  }]);
  return NotificationHeader;
}(_DomElement3.default);

},{"../DomElement":4,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sign = require("babel-runtime/core-js/math/sign");

var _sign2 = _interopRequireDefault(_sign);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _gsap = require("gsap");

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_HEADER = ".progress-full__bar";
var CLASS_SECTIONS = ".progress-full__sections > span";
var CLASS_SECTION_ACTIVE = "section--active";

var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_CURRENT = "indicator--current";
var CLASS_INDICATOR_COMPLETED = "indicator--completed";

/**
 * Full progress bar component
 */

var ProgressFull = function (_DomElement) {
  (0, _inherits3.default)(ProgressFull, _DomElement);

  /**
   * Creates and initializes the ProgressFull component.
   * @param {DomElement} - The root element of the ProgressFull component.
   */
  function ProgressFull(element) {
    (0, _classCallCheck3.default)(this, ProgressFull);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ProgressFull.__proto__ || (0, _getPrototypeOf2.default)(ProgressFull)).call(this, element));

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the loader bar component.
   * @private
   */


  (0, _createClass3.default)(ProgressFull, [{
    key: "_initialize",
    value: function _initialize() {
      this._buttonClickHandler = this._handleButtonClick.bind(this);
      this._keydownHandler = this._handleKeydown.bind(this);

      this._headerElement = this.find(CLASS_HEADER);

      this._pages = this.element.querySelectorAll(CLASS_SECTIONS);

      this._minValue = 1;
      this._value = 1;
      this._total = this._pages.length;

      for (var index = 0; index < this._pages.length; index++) {
        if (this._pages[index].classList.contains(CLASS_SECTION_ACTIVE)) {
          this._value = index + 1;
        }
      }

      this._addIncicators();
      this._update(-1, this._value, false);

      // Apply the tab index
      var tabIndex = this.getAttribute("tabindex");
      if (tabIndex) {
        this.setAttribute("tabindex", "");
        this._headerElement.setAttribute("tabindex", tabIndex);
      }

      this._headerElement.element.addEventListener("click", this._buttonClickHandler);
      this._headerElement.element.addEventListener("keydown", this._keydownHandler);
    }
  }, {
    key: "_addIncicators",
    value: function _addIncicators() {
      for (var i = this._pages.length - 1; i >= 0; i--) {
        var indicatorElement = new _DomElement3.default("button").addClass(CLASS_INDICATOR).setAttribute("data-value", i + 1).setHtml((i + 1).toString());

        this._headerElement.prependChild(indicatorElement);
      }
    }
  }, {
    key: "_update",
    value: function _update(oldValue, newValue) {
      var animate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var indicators = this._headerElement.element.childNodes;

      for (var index = 0; index < indicators.length; index++) {
        var indicatorElement = new _DomElement3.default(indicators[index]);

        if (index + 1 < this._value) {
          indicatorElement.removeClass(CLASS_INDICATOR_CURRENT).addClass(CLASS_INDICATOR_COMPLETED);
        }

        if (index + 1 === this._value) {
          indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).addClass(CLASS_INDICATOR_CURRENT);
        }

        if (index + 1 > this._value) {
          indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).removeClass(CLASS_INDICATOR_CURRENT);
        }
      }

      if (oldValue !== newValue) {
        var direction = (0, _sign2.default)(oldValue - newValue);

        if (oldValue > 0 && oldValue !== newValue) {
          var oldSection = new _DomElement3.default(this._pages[oldValue - 1]);

          if (animate) {
            _gsap.TweenLite.to(oldSection.element, 0.3, {
              left: 100 * direction,
              ease: _gsap.Power4.easeInOut,
              autoAlpha: 0,
              onComplete: function onComplete() {
                oldSection.removeClass(CLASS_SECTION_ACTIVE);
                oldSection.setAttribute("style", "");
              }
            });
          } else {
            oldSection.removeClass(CLASS_SECTION_ACTIVE);
            oldSection.setAttribute("style", "");
          }
        }

        var newSection = new _DomElement3.default(this._pages[newValue - 1]);

        if (animate) {
          _gsap.TweenLite.from(newSection.element, 0.3, {
            left: -100 * direction,
            ease: _gsap.Power4.easeInOut,
            autoAlpha: 0,
            onComplete: function onComplete() {
              newSection.addClass(CLASS_SECTION_ACTIVE);
              newSection.setAttribute("style", "");
            }
          });
        } else {
          newSection.addClass(CLASS_SECTION_ACTIVE);
          newSection.setAttribute("style", "");
        }
      }
    }
  }, {
    key: "_handleButtonClick",
    value: function _handleButtonClick(event) {
      var element = new _DomElement3.default(event.target);
      if (!element.hasClass(CLASS_INDICATOR)) {
        return;
      }

      var value = element.getAttribute("data-value");
      this.value = value;
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = evt || window.event;
      var keycode = event.which || event.keyCode;

      if (keycode === Inputs.KEY_ARROW_RIGHT) {
        this.value++;

        (0, _Utils.preventDefault)(event);
        return;
      }

      if (keycode === Inputs.KEY_ARROW_LEFT) {
        this.value--;

        (0, _Utils.preventDefault)(event);
        return;
      }

      if (keycode >= Inputs.KEY_NR_0 && keycode <= Inputs.KEY_NR_9) {
        this.value = keycode - Inputs.KEY_NR_0;
        (0, _Utils.preventDefault)(event);
        return;
      }
    }

    /**
     * Gets the current progress value in the range of 1..total.
     */

  }, {
    key: "addEventListener",


    /**
     * Register event listener on this component.
     */
    value: function addEventListener(type, listener) {
      this.element.addEventListener(type, listener);
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 1..total.
     */
    ,
    set: function set(val) {
      var oldValue = this._value;

      this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
      this._update(oldValue, this._value, true);

      this.dispatchEvent("changed");
    }

    /**
     * Gets the total progress value.
     */

  }, {
    key: "total",
    get: function get() {
      return this._total;
    }
  }]);
  return ProgressFull;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".progress-full", function (e) {
    new ProgressFull(e);
  });
}

exports.default = ProgressFull;

},{"../DomElement":4,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/math/sign":34,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _gsap = require("gsap");

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_BAR = ".progress-light__bar";
var CLASS_PROGRESS = ".bar__progress";
var CLASS_PROGRESS_COMPLETED = "bar__progress--complete";
var CLASS_TICK = "bar__tick";
var CLASS_PAGE_CURRENT = ".detail__currentpage";
var CLASS_PAGE_TOTAL = ".detail__totalpage";

var CLASS_DISABLED = "arrow--disabled";
var CLASS_BUTTON_LEFT = ".arrow--left";
var CLASS_BUTTON_RIGHT = ".arrow--right";

/**
 * Light progress bar component
 */

var ProgressLight = function (_DomElement) {
  (0, _inherits3.default)(ProgressLight, _DomElement);

  /**
   * Creates and initializes the ProgressLight component.
   * @param {DomElement} - The root element of the ProgressLight component.
   */
  function ProgressLight(element) {
    (0, _classCallCheck3.default)(this, ProgressLight);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ProgressLight.__proto__ || (0, _getPrototypeOf2.default)(ProgressLight)).call(this, element));

    _this._initialize();
    return _this;
  }

  /**
   * Initializes the loader bar component.
   * @private
   */


  (0, _createClass3.default)(ProgressLight, [{
    key: "_initialize",
    value: function _initialize() {

      this._buttonClickHandler = this._handleButtonClick.bind(this);
      this._animationCompletedHandler = this._handleAnimationCompleted.bind(this);

      this._barElement = this.find(CLASS_BAR);
      this._progressElement = this.find(CLASS_PROGRESS);
      this._pageCurrentElement = this.find(CLASS_PAGE_CURRENT);
      this._pageTotalElement = this.find(CLASS_PAGE_TOTAL);
      this._buttonLeft = this.find(CLASS_BUTTON_LEFT);
      this._buttonRight = this.find(CLASS_BUTTON_RIGHT);

      this._minValue = 1;
      this._total = Math.max(parseInt(this.getAttribute("total"), 10), this._minValue);
      this._value = (0, _Utils.clamp)(parseInt(this.getAttribute("value"), 10), this._minValue, this._total);

      this._layout();

      this._addTicks();
      this._update(false);

      this.enable();
    }
  }, {
    key: "_addTicks",
    value: function _addTicks() {
      for (var i = 1; i < this._total; i++) {
        var position = this._itemWidth * i;

        var tickElement = new _DomElement3.default("div").addClass(CLASS_TICK).setAttribute("style", "left: " + position + "%");

        this._barElement.prependChild(tickElement);
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._pageCurrentElement.setHtml(this._value.toString());
      this._pageTotalElement.setHtml(this._total.toString());

      var position = this._value * this._itemWidth;

      // Add additional width to the last element to make sure
      // the rounded border on the left is filled as well
      if (this._value === this._total) {
        position += 5;
      }

      if (this._value >= this._total) {
        this._buttonRight.addClass(CLASS_DISABLED);
      } else {
        this._buttonRight.removeClass(CLASS_DISABLED);
      }

      if (this._value <= this._minValue) {
        this._buttonLeft.addClass(CLASS_DISABLED);
      } else {
        this._buttonLeft.removeClass(CLASS_DISABLED);
      }

      if (animate) {
        _gsap.TweenLite.to(this._progressElement.element, 0.2, {
          width: position + "%",
          ease: _gsap.Power4.easeInOut,
          onComplete: this._animationCompletedHandler
        });
      } else {
        _gsap.TweenLite.set(this._progressElement.element, {
          width: position + "%",
          onComplete: this._animationCompletedHandler
        });
      }
    }
  }, {
    key: "_layout",
    value: function _layout() {
      this._itemWidth = Math.floor(100 / this._total);
    }
  }, {
    key: "_handleButtonClick",
    value: function _handleButtonClick(event) {
      if (event.target === this._buttonLeft.element) {
        this.value = this._value - 1;
      } else if (event.target === this._buttonRight.element) {
        this.value = this._value + 1;
      }
    }
  }, {
    key: "_handleAnimationCompleted",
    value: function _handleAnimationCompleted() {
      if (this._value === this._total) {
        this._progressElement.addClass(CLASS_PROGRESS_COMPLETED);
      } else {
        this._progressElement.removeClass(CLASS_PROGRESS_COMPLETED);
      }
    }

    /**
     * Gets the current progress value in the range of 1..total.
     */

  }, {
    key: "addEventListener",


    /**
     * Registers an event listener.
     */
    value: function addEventListener(type, listener) {
      this.element.addEventListener(type, listener);
    }

    /**
     * Enables the component.
     */

  }, {
    key: "enable",
    value: function enable() {
      this._buttonLeft.element.addEventListener("click", this._buttonClickHandler);
      this._buttonRight.element.addEventListener("click", this._buttonClickHandler);
    }

    /**
     * Disables the component.
     */

  }, {
    key: "disable",
    value: function disable() {
      this._buttonLeft.element.removeEventListener("click", this._buttonClickHandler);
      this._buttonRight.element.removeEventListener("click", this._buttonClickHandler);
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }

    /**
     * Sets the current progress.
     * @param {number} - The progress in the range of 1..total.
     */
    ,
    set: function set(val) {
      this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
      this._update(true);

      this.dispatchEvent("changed");
    }

    /**
     * Gets the total progress value.
     */

  }, {
    key: "total",
    get: function get() {
      return this._total;
    }

    /**
     * Sets the total progress value and updates the UI accordingly.
     * @param {number} - The total progress positive integer value.
     */
    ,
    set: function set(value) {
      if (this._total === value) {
        return;
      }

      this._total = Math.max(value, this._minValue);
      this._value = (0, _Utils.clamp)(this._value, this._minValue, this._total);

      // Clear the thicks
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.element.querySelectorAll("." + CLASS_TICK)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tick = _step.value;

          this._barElement.element.removeChild(tick);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._layout();
      this._addTicks();

      this._update(false);

      this.dispatchEvent("totalchanged");
    }
  }]);
  return ProgressLight;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".progress-light", function (e) {
    new ProgressLight(e);
  });
}

exports.default = ProgressLight;

},{"../DomElement":4,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_SEARCH_INPUT = "input.search__field";
var QUERY_BTN_CLOSE = ".search__icon-close";

var QUERY_LIVE_SUGESTIONS = ".js-suggestions";
var QUERY_LIVE_FOOTER = ".js-footer";

var CLASS_ACTIVE = "is-active";
var CLASS_OPEN = "is-open";

var CLASS_SEARCH = "search";

var ANIMATION_SUGGESTIONS_DURATION = 0.3;
var ANIMATION_FOOTER_DURATION = 0.1;

/**
 * The search input component definition.
 */

var SearchInput = function (_DomElement) {
  (0, _inherits3.default)(SearchInput, _DomElement);

  function SearchInput(element) {
    (0, _classCallCheck3.default)(this, SearchInput);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SearchInput.__proto__ || (0, _getPrototypeOf2.default)(SearchInput)).call(this, element));

    _this._input = _this.element.querySelector(QUERY_SEARCH_INPUT);
    _this._form = _this.element.querySelector("form");
    _this._btnClose = _this.element.querySelector(QUERY_BTN_CLOSE);

    var liveSearch = (0, _DomFunctions.getAttributeReference)(_this.element, "data-live");
    if (liveSearch) {
      _this._liveSuggestions = liveSearch.querySelector(QUERY_LIVE_SUGESTIONS);
      _this._liveFooter = liveSearch.querySelector(QUERY_LIVE_FOOTER);
    }

    _this._focusHandler = _this._handleInputFocus.bind(_this);
    _this._blurHandler = _this._handleInputBlur.bind(_this);
    _this._closeHandler = _this.close.bind(_this);
    _this._windowClickHander = _this._handleWindowClick.bind(_this);
    _this._keydownHandler = _this._handleKeydown.bind(_this);
    _this._resizeHandler = _this._handleResize.bind(_this);

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(SearchInput, [{
    key: "_initialize",
    value: function _initialize() {
      this._input.addEventListener("focus", this._focusHandler);
      this._input.addEventListener("blur", this._blurHandler);

      if ((0, _Utils.msIEVersion)() > 0) {
        // This is a workaround for IE browsers where a focused
        // input's cursor bleeds trough even if hidden

        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
      }

      if (this._btnClose) {
        this._btnClose.addEventListener("click", this._closeHandler);
      }
    }
  }, {
    key: "_handleInputFocus",
    value: function _handleInputFocus() {
      this.addClass(CLASS_ACTIVE);
    }
  }, {
    key: "_handleInputBlur",
    value: function _handleInputBlur() {
      this.removeClass(CLASS_ACTIVE);
    }
  }, {
    key: "_handleWindowClick",
    value: function _handleWindowClick(event) {
      var target = event.target;

      if (!(0, _DomFunctions.parentWithClass)(target, CLASS_SEARCH)) {
        this.close();
        return false;
      }

      return true;
    }
  }, {
    key: "_handleKeydown",
    value: function _handleKeydown(event) {
      var evt = evt || window.event;
      var keycode = event.which || event.keyCode;

      if (keycode === Inputs.KEY_ESCAPE) {
        this.close();
        (0, _Utils.preventDefault)(event);
      }
    }
  }, {
    key: "_handleResize",
    value: function _handleResize() {
      var style = window.getComputedStyle(this.element, null);
      if (style.display === "none") {
        this._input.blur();
      }
    }
  }, {
    key: "_resetMainTimeline",
    value: function _resetMainTimeline() {
      var _this2 = this;

      if (this._tlMain) {
        this._tlMain.stop();
      }

      this._tlMain = new _gsap.TimelineLite({
        onComplete: function onComplete() {
          _this2._tlMain = undefined;
        }
      });
    }

    /**
     * Gets the search input text content.
     * @returns {String} The input text.
     */

  }, {
    key: "open",


    /**
     * Opens/activates the search input.
     */
    value: function open() {
      var _this3 = this;

      this.addClass(CLASS_OPEN);
      this._input.focus();

      setTimeout(function () {
        window.addEventListener("click", _this3._windowClickHander);
        window.addEventListener("touchend", _this3._windowClickHander);
        window.addEventListener("keydown", _this3._keydownHandler);
      }, 50);
    }

    /**
     * Closes/deactivates the search input.
     */

  }, {
    key: "close",
    value: function close() {
      this._form.reset();
      this.removeClass(CLASS_OPEN);

      this.closeLiveSearch();

      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);
      window.removeEventListener("keydown", this._keydownHandler);
    }

    /**
     * Opens the live search suggestions.
     */

  }, {
    key: "openLiveSearch",
    value: function openLiveSearch() {
      if (!this._liveSuggestions || (0, _DomFunctions.hasClass)(this._liveSuggestions, CLASS_OPEN) === true) {
        return;
      }

      this._resetMainTimeline();

      this._tlMain.set(this._liveSuggestions, {
        display: "block"
      });

      this._tlMain.to(this._liveSuggestions, ANIMATION_SUGGESTIONS_DURATION, {
        className: "+=" + CLASS_OPEN,
        clearProps: "all",
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      });

      if (this._liveFooter) {
        this._tlMain.set(this._liveFooter, {
          display: "block"
        }, 0);

        this._tlMain.to(this._liveFooter, ANIMATION_FOOTER_DURATION, {
          className: "+=" + CLASS_OPEN,
          clearProps: "height, display",
          ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
        }, "-=0.1");
      }
    }

    /**
     * Closes the live search suggestions.
     */

  }, {
    key: "closeLiveSearch",
    value: function closeLiveSearch() {
      if (!this._liveSuggestions || (0, _DomFunctions.hasClass)(this._liveSuggestions, CLASS_OPEN) === false) {
        return;
      }

      this._resetMainTimeline();

      this._tlMain.set(this._liveSuggestions, {
        display: "block"
      });

      if (this._liveFooter) {
        this._tlMain.set(this._liveFooter, {
          display: "block"
        }, 0);

        this._tlMain.to(this._liveFooter, ANIMATION_FOOTER_DURATION, {
          className: "-=" + CLASS_OPEN,
          clearProps: "height, display",
          ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
        });
      }

      this._tlMain.to(this._liveSuggestions, ANIMATION_SUGGESTIONS_DURATION, {
        className: "-=" + CLASS_OPEN,
        clearProps: "all",
        ease: [_gsap.Power1.easeIn, _gsap.Power4.easeOut]
      }, "-=0.1");
    }

    /**
     * Destroys the component and clears all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      window.removeEventListener("click", this._windowClickHander);
      window.removeEventListener("touchend", this._windowClickHander);
      window.removeEventListener("keydown", this._keydownHandler);

      this._input.removeEventListener("focus", this._focusHandler);
      this._input.removeEventListener("blur", this._blurHandler);

      window.removeEventListener("resize", this._resizeHandler);
      window.removeEventListener("orientationchange", this._resizeHandler);

      if (this._btnClose) {
        this._btnClose.removeEventListener("click", this._closeHandler);
      }

      this._input = null;
      this._form = null;
      this._btnClose = null;

      this._focusHandler = null;
      this._blurHandler = null;
      this._closeHandler = null;
      this._windowClickHander = null;
      this._keydownHandler = null;

      this._liveSuggestions = null;
      this._liveFooter = null;
    }

    /**
     * Determines if the SearchInput is open/visible.
     * @return {Boolean} - True if open; otherwise false.
     */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this.hasClass(CLASS_OPEN);
    }
  }, {
    key: "value",
    get: function get() {
      return this._input.value;
    }
  }]);
  return SearchInput;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)(".search.search__input", function (e) {
    new SearchInput(e);
  });
}

exports.default = SearchInput;

},{"../DomElement":4,"../DomFunctions":5,"../Inputs":6,"../Utils":7,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

exports.init = init;

var _Utils = require("../Utils");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_HEADER = "thead th";

var CLASS_SORTED_ASCENDING = "js-ascending";
var CLASS_SORTED_DESCENDING = "js-descending";
var CLASS_ARROW = "arrow-icon";

/**
 * The Table component. Adds additional capabilities to standard HTML 5 tables.
 */

var Table = function (_DomElement) {
  (0, _inherits3.default)(Table, _DomElement);

  /**
   * Creates a new instance of the table component.
   */
  function Table(element) {
    (0, _classCallCheck3.default)(this, Table);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Table.__proto__ || (0, _getPrototypeOf2.default)(Table)).call(this, element));

    _this._headerClickHandler = _this._handleHeaderClick.bind(_this);

    _this._body = _this.element.querySelector("tbody");
    _this._rows = _this._body.getElementsByTagName("tr");

    _this._initialize();
    return _this;
  }

  (0, _createClass3.default)(Table, [{
    key: "_initialize",
    value: function _initialize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_HEADER)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var header = _step.value;

          if (header.getAttribute("data-type")) {
            header.addEventListener("click", this._headerClickHandler);

            var arrowElement = new _DomElement3.default("div").addClass(CLASS_ARROW).element;

            header.appendChild(arrowElement);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_handleHeaderClick",
    value: function _handleHeaderClick(e) {
      var th = e.target;
      this.sort(th);
    }

    /**
     * Sorts the table according to the specified table header element.
     * The column is sorted ascending by default if no direction is specified and no
     * existing sort order class is found in the markup.
     *
     * If the displayed data is not suitable for sorting `<td/>` elements can define a `data-value` attribute
     * which is then used for the data-source.
     *
     * @param {TableHeader} tableHeader The header element of the row to sort by.
     * @param {Number} direction The direction to sort, `1` for ascending, `-1` for descending order. This parameter is optional.
     * @param {function} equalityComparer The equiality comparer function to compare individual cell values.
     */

  }, {
    key: "sort",
    value: function sort(tableHeader) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var equalityComparer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

      if (!tableHeader || tableHeader.tagName !== "TH") {
        throw new Error("The parameter 'tableHeader' must be a valid column header node");
      }

      if (direction !== 1 && direction !== -1 && direction) {
        throw new Error("Parameter out of range, parameter 'direction' with value '" + direction + "' must be either -1, 1 or undefined");
      }

      var columnIndex = tableHeader.cellIndex;

      if (!equalityComparer) {
        var dataType = tableHeader.getAttribute("data-type");
        equalityComparer = this._getComparer(dataType);
      }

      if (columnIndex >= this._rows.length) {
        throw new Error("Column out of range");
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_HEADER)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var header = _step2.value;

          if (header !== tableHeader) {
            Dom.removeClass(header, CLASS_SORTED_ASCENDING);
            Dom.removeClass(header, CLASS_SORTED_DESCENDING);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (Dom.hasClass(tableHeader, CLASS_SORTED_ASCENDING)) {
        Dom.removeClass(tableHeader, CLASS_SORTED_ASCENDING);
        Dom.addClass(tableHeader, CLASS_SORTED_DESCENDING);

        direction = direction || -1;
      } else {
        Dom.removeClass(tableHeader, CLASS_SORTED_DESCENDING);
        Dom.addClass(tableHeader, CLASS_SORTED_ASCENDING);
        direction = direction || 1;
      }

      this._quicksort(columnIndex, 0, this._rows.length - 1, direction, equalityComparer);
    }
  }, {
    key: "_getCell",
    value: function _getCell(column, row) {
      return this._rows[row].cells[column];
    }
  }, {
    key: "_getRow",
    value: function _getRow(row) {
      return this._rows[row];
    }
  }, {
    key: "_getComparer",
    value: function _getComparer(dataType) {
      switch (dataType) {
        case "number":
          {
            // parse the string as a number
            return function (a, b) {
              return parseFloat(a) - parseFloat(b);
            };
          }
        default:
          {
            // compare strings
            return function (a, b) {
              if (a < b) {
                return -1;
              }
              if (a > b) {
                return 1;
              }

              return 0;
            };
          }
      }
    }
  }, {
    key: "_quicksort",
    value: function _quicksort(column, left, right) {
      var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var equalityComparer = arguments[4];

      if (right - left > 1) {

        var partition = this._partition(column, left, right, direction, equalityComparer);

        if (left < partition - 1) {
          this._quicksort(column, left, partition - 1, direction, equalityComparer);
        }

        if (partition < right) {
          this._quicksort(column, partition, right, direction, equalityComparer);
        }
      }
    }
  }, {
    key: "_partition",
    value: function _partition(column, left, right, direction, equalityComparer) {
      var pivot = this._getCell(column, Math.floor((right + left) / 2));
      var i = left;
      var j = right;

      while (i <= j) {
        while (this._equals(this._getCell(column, i), pivot, equalityComparer) * direction < 0) {
          i++;
        }

        while (this._equals(this._getCell(column, j), pivot, equalityComparer) * direction > 0) {
          j--;
        }

        if (i <= j) {
          this._swap(i, j);
          i++;
          j--;
        }
      }

      return i;
    }
  }, {
    key: "_equals",
    value: function _equals(a, b, equalityComparer) {
      var dataA = a.getAttribute("data-value");
      var dataB = b.getAttribute("data-value");

      dataA = dataA || a.textContent || a.innerText;
      dataB = dataB || b.textContent || b.innerText;

      return equalityComparer(dataA, dataB);
    }
  }, {
    key: "_swap",
    value: function _swap(i, j) {
      var tmpNode = this._body.replaceChild(this._getRow(i), this._getRow(j));
      var referenceRow = this._getRow(i);

      if (!referenceRow) {
        this._body.appendChild(tmpNode);
      } else {
        this._body.insertBefore(tmpNode, referenceRow);
      }
    }

    /**
     * Destroys the component and clears all references.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)(this.element.querySelectorAll(QUERY_HEADER)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var header = _step3.value;

          header.removeEventListener("click", this._headerClickHandler);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._headerClickHandler = null;
      this._body = null;
      this._rows = null;
    }
  }]);
  return Table;
}(_DomElement3.default);

function init() {
  (0, _Utils.searchAndInitialize)("table", function (e) {
    new Table(e);
  });
}

exports.default = Table;

},{"../DomElement":4,"../DomFunctions":5,"../Utils":7,"babel-runtime/core-js/get-iterator":33,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _gsap = require("gsap");

var _DomElement2 = require("../DomElement");

var _DomElement3 = _interopRequireDefault(_DomElement2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_ITEMS = ".toolbar__item";
var CLASS_SHOW = "item--show";

var ANIMATION_START_DELAY = 0.1;
var ANIMATION_OFFSET = 0.05;

/**
 * Toolbar component. Use this component to show and hide the
 * individual toolbar items.
 */

var Toolbar = function (_DomElement) {
  (0, _inherits3.default)(Toolbar, _DomElement);

  function Toolbar() {
    (0, _classCallCheck3.default)(this, Toolbar);
    return (0, _possibleConstructorReturn3.default)(this, (Toolbar.__proto__ || (0, _getPrototypeOf2.default)(Toolbar)).apply(this, arguments));
  }

  (0, _createClass3.default)(Toolbar, [{
    key: "show",


    /**
     * Makes the toolbar items visible.
     */
    value: function show() {
      var delay = ANIMATION_START_DELAY;
      var items = this.element.querySelectorAll(CLASS_ITEMS);

      var timeline = new _gsap.TimelineLite();
      for (var index = 0; index < items.length; index++) {
        timeline.to(items[index], 0, { className: "+=" + CLASS_SHOW }, delay);
        delay += ANIMATION_OFFSET;
      }
    }

    /**
     * Hides the toolbar items.
     */

  }, {
    key: "hide",
    value: function hide() {
      var delay = ANIMATION_START_DELAY;
      var items = this.element.querySelectorAll(CLASS_ITEMS);

      var timeline = new _gsap.TimelineLite();
      for (var index = items.length - 1; index >= 0; index--) {
        timeline.to(items[index], 0, { className: "-=" + CLASS_SHOW }, delay);
        delay += ANIMATION_OFFSET;
      }
    }

    /**
     * Toggles the toolbar items visibility.
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.element.querySelectorAll("." + CLASS_SHOW).length === 0) {
        this.show();
      } else {
        this.hide();
      }
    }
  }]);
  return Toolbar;
}(_DomElement3.default);

exports.default = Toolbar;

},{"../DomElement":4,"babel-runtime/core-js/object/get-prototype-of":40,"babel-runtime/helpers/classCallCheck":44,"babel-runtime/helpers/createClass":45,"babel-runtime/helpers/inherits":46,"babel-runtime/helpers/possibleConstructorReturn":47,"gsap":144}],32:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":50}],33:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":51}],34:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":52}],35:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/trunc"), __esModule: true };
},{"core-js/library/fn/math/trunc":53}],36:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":54}],37:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/max-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/max-safe-integer":55}],38:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":56}],39:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":57}],40:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":58}],41:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":59}],42:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":60}],43:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":61}],44:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],45:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":39}],46:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":38,"../core-js/object/set-prototype-of":41,"../helpers/typeof":49}],47:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":49}],48:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":32}],49:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":42,"../core-js/symbol/iterator":43}],50:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;
},{"../../modules/_core":68,"../../modules/es6.array.from":128,"../../modules/es6.string.iterator":139}],51:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');
},{"../modules/core.get-iterator":127,"../modules/es6.string.iterator":139,"../modules/web.dom.iterable":143}],52:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/_core').Math.sign;
},{"../../modules/_core":68,"../../modules/es6.math.sign":130}],53:[function(require,module,exports){
require('../../modules/es6.math.trunc');
module.exports = require('../../modules/_core').Math.trunc;
},{"../../modules/_core":68,"../../modules/es6.math.trunc":131}],54:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;
},{"../../modules/_core":68,"../../modules/es6.number.is-nan":132}],55:[function(require,module,exports){
require('../../modules/es6.number.max-safe-integer');
module.exports = 0x1fffffffffffff;
},{"../../modules/es6.number.max-safe-integer":133}],56:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};
},{"../../modules/_core":68,"../../modules/es6.object.create":134}],57:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":68,"../../modules/es6.object.define-property":135}],58:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;
},{"../../modules/_core":68,"../../modules/es6.object.get-prototype-of":136}],59:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;
},{"../../modules/_core":68,"../../modules/es6.object.set-prototype-of":137}],60:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;
},{"../../modules/_core":68,"../../modules/es6.object.to-string":138,"../../modules/es6.symbol":140,"../../modules/es7.symbol.async-iterator":141,"../../modules/es7.symbol.observable":142}],61:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":124,"../../modules/es6.string.iterator":139,"../../modules/web.dom.iterable":143}],62:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],63:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],64:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":86}],65:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":116,"./_to-iobject":118,"./_to-length":119}],66:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":67,"./_wks":125}],67:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],68:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],69:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":98,"./_property-desc":109}],70:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":62}],71:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],72:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":77}],73:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":78,"./_is-object":86}],74:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],75:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":103,"./_object-keys":106,"./_object-pie":107}],76:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":68,"./_ctx":70,"./_global":78,"./_hide":80}],77:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],78:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],79:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],80:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":72,"./_object-dp":98,"./_property-desc":109}],81:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":78}],82:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":72,"./_dom-create":73,"./_fails":77}],83:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":67}],84:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":92,"./_wks":125}],85:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":67}],86:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],87:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":64}],88:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":80,"./_object-create":97,"./_property-desc":109,"./_set-to-string-tag":112,"./_wks":125}],89:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":76,"./_has":79,"./_hide":80,"./_iter-create":88,"./_iterators":92,"./_library":94,"./_object-gpo":104,"./_redefine":110,"./_set-to-string-tag":112,"./_wks":125}],90:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":125}],91:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],92:[function(require,module,exports){
module.exports = {};
},{}],93:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":106,"./_to-iobject":118}],94:[function(require,module,exports){
module.exports = true;
},{}],95:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],96:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":77,"./_has":79,"./_is-object":86,"./_object-dp":98,"./_uid":122}],97:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":64,"./_dom-create":73,"./_enum-bug-keys":74,"./_html":81,"./_object-dps":99,"./_shared-key":113}],98:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":64,"./_descriptors":72,"./_ie8-dom-define":82,"./_to-primitive":121}],99:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":64,"./_descriptors":72,"./_object-dp":98,"./_object-keys":106}],100:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":72,"./_has":79,"./_ie8-dom-define":82,"./_object-pie":107,"./_property-desc":109,"./_to-iobject":118,"./_to-primitive":121}],101:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":102,"./_to-iobject":118}],102:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":74,"./_object-keys-internal":105}],103:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],104:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":79,"./_shared-key":113,"./_to-object":120}],105:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":65,"./_has":79,"./_shared-key":113,"./_to-iobject":118}],106:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":74,"./_object-keys-internal":105}],107:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],108:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":68,"./_export":76,"./_fails":77}],109:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],110:[function(require,module,exports){
module.exports = require('./_hide');
},{"./_hide":80}],111:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":64,"./_ctx":70,"./_is-object":86,"./_object-gopd":100}],112:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":79,"./_object-dp":98,"./_wks":125}],113:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":114,"./_uid":122}],114:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":78}],115:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":71,"./_to-integer":117}],116:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":117}],117:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],118:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":71,"./_iobject":83}],119:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":117}],120:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":71}],121:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":86}],122:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],123:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":68,"./_global":78,"./_library":94,"./_object-dp":98,"./_wks-ext":124}],124:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":125}],125:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":78,"./_shared":114,"./_uid":122}],126:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":66,"./_core":68,"./_iterators":92,"./_wks":125}],127:[function(require,module,exports){
var anObject = require('./_an-object')
  , get      = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};
},{"./_an-object":64,"./_core":68,"./core.get-iterator-method":126}],128:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":69,"./_ctx":70,"./_export":76,"./_is-array-iter":84,"./_iter-call":87,"./_iter-detect":90,"./_to-length":119,"./_to-object":120,"./core.get-iterator-method":126}],129:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":63,"./_iter-define":89,"./_iter-step":91,"./_iterators":92,"./_to-iobject":118}],130:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":76,"./_math-sign":95}],131:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":76}],132:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":76}],133:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":76}],134:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":76,"./_object-create":97}],135:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":72,"./_export":76,"./_object-dp":98}],136:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":104,"./_object-sap":108,"./_to-object":120}],137:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":76,"./_set-proto":111}],138:[function(require,module,exports){

},{}],139:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":89,"./_string-at":115}],140:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":64,"./_descriptors":72,"./_enum-keys":75,"./_export":76,"./_fails":77,"./_global":78,"./_has":79,"./_hide":80,"./_is-array":85,"./_keyof":93,"./_library":94,"./_meta":96,"./_object-create":97,"./_object-dp":98,"./_object-gopd":100,"./_object-gopn":102,"./_object-gopn-ext":101,"./_object-gops":103,"./_object-keys":106,"./_object-pie":107,"./_property-desc":109,"./_redefine":110,"./_set-to-string-tag":112,"./_shared":114,"./_to-iobject":118,"./_to-primitive":121,"./_uid":122,"./_wks":125,"./_wks-define":123,"./_wks-ext":124}],141:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":123}],142:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":123}],143:[function(require,module,exports){
require('./es6.array.iterator');
var global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , TO_STRING_TAG = require('./_wks')('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}
},{"./_global":78,"./_hide":80,"./_iterators":92,"./_wks":125,"./es6.array.iterator":129}],144:[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.19.1
 * DATE: 2017-01-17
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2017, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.19.1";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
								pt = this._firstPT, endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime;
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}

				if (this._easeType) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt && vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};
		
		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			_pauseCallback = _internals.pauseCallback = function() {},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.19.1";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					tl.add(tween, tween._startTime - tween._delay);
				}
				tween = next;
			}
			root.add(tl, 0);
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > this.duration()) {
				this._time = this._duration;
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : this.duration();
			} else if (timeOrLabel == null) {
				timeOrLabel = this.duration();
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this.add(tween, tween._startTime - tween._delay);
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);








	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.19.1";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false},
				Engine = (vars.repeat && _globals.TweenMax) || TweenLite,
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new Engine(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration()) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale );
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don't use t._callback("onStart") or it'll point to the copy.onStart and we'll get a recursion error.
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTime = this._time,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents && time < dur) {
					time = this._time;
					if (time >= prevTime || (this._repeat && prevCycle !== this._cycle)) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._cycle = recCycle; //in case the onRepeat alters the playhead or invalidates(), we shouldn't stay locked or use the previous cycle.
						this._locked = false;
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					this._cycle = prevCycle; //if there's an onRepeat, we reverted this above, so make sure it's set properly again. We also unlocked in that scenario, so reset that too.
					this._locked = true;
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};

		p.invalidate = function() {
			this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat
			return TimelineLite.prototype.invalidate.call(this);
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				if (c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
					c = d - (d - b) / 1000000;
				}
				if (a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
					b = a + (c - a) / 1000000;
				}
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.7",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._mod = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
								this._overwriteProps.push(p);
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._mod[p]) {
								val = this._mod[p](val, target);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (this._mod[p]) {
										val = this._mod[p](val, target); //for modProps
									}

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
					data.proxy.rotation = data.autoRotate.rotation || 0;
					cssp._overwriteProps.push("rotation");
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._mod = function(lookup) {
			var op = this._overwriteProps,
				i = op.length,
				val;
			while (--i > -1) {
				val = lookup[op[i]];
				if (val && typeof(val) === "function") {
					this._mod[op[i]] = val;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			a = this._autoRotate;
			if (a) {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i][2]]) {
						a.splice(i, 1);
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.19.1";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_dummyElement = {style:{}},
			_doc = _gsScope.document || {createElement: function() {return _dummyElement;}},
			_createElement = function(type, ns) {
				return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = (_gsScope.navigator || {}).userAgent || "",
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i+8, 2)) > 3));
				_isSafariLT6 = (_isSafari && (parseFloat(_agent.substr(_agent.indexOf("Version/")+8, 2)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (_gsScope.console) {
					console.log(s);
				}
			},
			_target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
			_index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || !sfx) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					precise = (v === 1),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (precise) {
					v *= 100;
				}
				if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
						node = t.parentNode || _doc.body;
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				if (precise) {
					pix /= 100;
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				if ((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
					return (cs || _getComputedStyle(t))[p] || 0;
				} else if (t.getCTM && _isSVG(t)) {
					return t.getBBox()[p] || 0;
				}
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					return v + " ";
				}
				if (v == null || v === "") {
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
					i;
				if (a.length > 3 && !recObj) { //multiple positions
					a = v.split(", ").join(",").split(",");
					v = [];
					for (i = 0; i < a.length; i++) {
						v.push(_parsePosition(a[i]));
					}
					return v.join(",");
				}
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
					recObj.v = v;
				}
				return recObj || v;
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
			 */
			_parseColor = CSSPlugin.parseColor = function(v, toHSL) {
				var a, r, g, b, h, s, l, max, min, d, wasHSL;
				if (!v) {
					a = _colorLookup.black;
				} else if (typeof(v) === "number") {
					a = [v >> 16, (v >> 8) & 255, v & 255];
				} else {
					if (v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
						v = v.substr(0, v.length - 1);
					}
					if (_colorLookup[v]) {
						a = _colorLookup[v];
					} else if (v.charAt(0) === "#") {
						if (v.length === 4) { //for shorthand like #9F0
							r = v.charAt(1);
							g = v.charAt(2);
							b = v.charAt(3);
							v = "#" + r + r + g + g + b + b;
						}
						v = parseInt(v.substr(1), 16);
						a = [v >> 16, (v >> 8) & 255, v & 255];
					} else if (v.substr(0, 3) === "hsl") {
						a = wasHSL = v.match(_numExp);
						if (!toHSL) {
							h = (Number(a[0]) % 360) / 360;
							s = Number(a[1]) / 100;
							l = Number(a[2]) / 100;
							g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
							r = l * 2 - g;
							if (a.length > 3) {
								a[3] = Number(v[3]);
							}
							a[0] = _hue(h + 1 / 3, r, g);
							a[1] = _hue(h, r, g);
							a[2] = _hue(h - 1 / 3, r, g);
						} else if (v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
							return v.match(_relNumExp);
						}
					} else {
						a = v.match(_numExp) || _colorLookup.transparent;
					}
					a[0] = Number(a[0]);
					a[1] = Number(a[1]);
					a[2] = Number(a[2]);
					if (a.length > 3) {
						a[3] = Number(a[3]);
					}
				}
				if (toHSL && !wasHSL) {
					r = a[0] / 255;
					g = a[1] / 255;
					b = a[2] / 255;
					max = Math.max(r, g, b);
					min = Math.min(r, g, b);
					l = (max + min) / 2;
					if (max === min) {
						h = s = 0;
					} else {
						d = max - min;
						s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
						h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
						h *= 60;
					}
					a[0] = (h + 0.5) | 0;
					a[1] = (s * 100 + 0.5) | 0;
					a[2] = (l * 100 + 0.5) | 0;
				}
				return a;
			},
			_formatColors = function(s, toHSL) {
				var colors = s.match(_colorExp) || [],
					charIndex = 0,
					parsed = colors.length ? "" : s,
					i, color, temp;
				for (i = 0; i < colors.length; i++) {
					color = colors[i];
					temp = s.substr(charIndex, s.indexOf(color, charIndex)-charIndex);
					charIndex += temp.length + color.length;
					color = _parseColor(color, toHSL);
					if (color.length === 3) {
						color.push(1);
					}
					parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
				}
				return parsed + s.substr(charIndex);
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		CSSPlugin.colorStringFilter = function(a) {
			var combined = a[0] + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str, p;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
				if (v === 1 || v === 0) {
					mpt = d.firstMPT;
					p = (v === 1) ? "e" : "b";
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt[p] = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt[p] = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			_addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
				var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
				pt.b = start;
				pt.e = pt.xs0 = end;
				return pt;
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				if (clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
					e = [b, e];
					CSSPlugin.colorStringFilter(e);
					b = e[0];
					e = e[1];
				}
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				_colorExp.lastIndex = 0;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && _colorExp.test(bv)) {
						str = ev.indexOf(")") + 1;
						str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
						useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = (bv.length + ev.length > 6);
						if (hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra((hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
									.appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
									.appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
							} else {
								pt.appendXtra((hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
									.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
									.appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), true);
							}

							if (hasAlpha) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = _internals._registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = true; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = _gsScope.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement || {},
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !_gsScope.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
				var tm = e._gsTransform,
					m = _getMatrix(e, true),
					v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
				if (tm) {
					xOriginOld = tm.xOrigin; //record the original values before we alter them.
					yOriginOld = tm.yOrigin;
				}
				if (!absolute || (v = absolute.split(" ")).length < 2) {
					b = e.getBBox();
					if (b.x === 0 && b.y === 0 && b.width + b.height === 0) { //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
						b = {x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width:0, height:0};
					}
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
				}
				decoratee.xOrigin = xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = yOrigin = parseFloat(v[1]);
				if (absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					determinant = (a * d - b * c);
					if (determinant) { //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
						x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
						y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
						xOrigin = decoratee.xOrigin = v[0] = x;
						yOrigin = decoratee.yOrigin = v[1] = y;
					}
				}
				if (tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
					if (skipRecord) {
						decoratee.xOffset = tm.xOffset;
						decoratee.yOffset = tm.yOffset;
						tm = decoratee;
					}
					if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
						x = xOrigin - xOriginOld;
						y = yOrigin - yOriginOld;
						//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
						//tm.x -= x - (x * m[0] + y * m[2]);
						//tm.y -= y - (x * m[1] + y * m[3]);
						tm.xOffset += (x * m[0] + y * m[2]) - x;
						tm.yOffset += (x * m[1] + y * m[3]) - y;
					} else {
						tm.xOffset = tm.yOffset = 0;
					}
				}
				if (!skipRecord) {
					e.setAttribute("data-svg-origin", v.join(" "));
				}
			},
			_getBBoxHack = function(swapIfPossible) { //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
				var svg = _createElement("svg", this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
					oldParent = this.parentNode,
					oldSibling = this.nextSibling,
					oldCSS = this.style.cssText,
					bbox;
				_docElement.appendChild(svg);
				svg.appendChild(this);
				this.style.display = "block";
				if (swapIfPossible) {
					try {
						bbox = this.getBBox();
						this._originalGetBBox = this.getBBox;
						this.getBBox = _getBBoxHack;
					} catch (e) { }
				} else if (this._originalGetBBox) {
					bbox = this._originalGetBBox();
				}
				if (oldSibling) {
					oldParent.insertBefore(this, oldSibling);
				} else {
					oldParent.appendChild(this);
				}
				_docElement.removeChild(svg);
				this.style.cssText = oldCSS;
				return bbox;
			},
			_getBBox = function(e) {
				try {
					return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
				} catch (error) {
					return _getBBoxHack.call(e, true);
				}
			},
			_isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
				return !!(_SVGElement && e.getCTM && _getBBox(e) && (!e.parentNode || e.ownerSVGElement));
			},
			_identity2DMatrix = [1,0,0,1,0,0],
			_getMatrix = function(e, force2D) {
				var tm = e._gsTransform || new Transform(),
					rnd = 100000,
					style = e.style,
					isDefault, s, m, n, dec, none;
				if (_transformProp) {
					s = _getStyle(e, _transformPropCSS, null, true);
				} else if (e.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = e.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				if (isDefault && _transformProp && ((none = (_getComputedStyle(e).display === "none")) || !e.parentNode)) {
					if (none) { //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none".
						n = style.display;
						style.display = "block";
					}
					if (!e.parentNode) {
						dec = 1; //flag
						_docElement.appendChild(e);
					}
					s = _getStyle(e, _transformPropCSS, null, true);
					isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
					if (n) {
						style.display = n;
					} else if (none) {
						_removeProp(style, "display");
					}
					if (dec) {
						_docElement.removeChild(e);
					}
				}
				if (tm.svg || (e.getCTM && _isSVG(e))) {
					if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = style[_transformProp];
						isDefault = 0;
					}
					m = e.getAttribute("transform");
					if (isDefault && m) {
						if (m.indexOf("matrix") !== -1) { //just in case there's a "transform" value specified as an attribute instead of CSS style. Accept either a matrix() or simple translate() value though.
							s = m;
							isDefault = 0;
						} else if (m.indexOf("translate") !== -1) {
							s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
							isDefault = 0;
						}
					}
				}
				if (isDefault) {
					return _identity2DMatrix;
				}
				//split the matrix values out into an array (m for matrix)
				m = (s || "").match(_numExp) || [];
				i = m.length;
				while (--i > -1) {
					n = Number(m[i]);
					m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
				}
				return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					m, i, scaleX, scaleY, rotation, skewX;

				tm.svg = !!(t.getCTM && _isSVG(t));
				if (tm.svg) {
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
				}
				m = _getMatrix(t);
				if (m !== _identity2DMatrix) {

					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;

						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(-a31, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							a11 = a11*cos+a12*sin;
							t2 = a21*cos+a22*sin;
							a22 = a21*-sin+a22*cos;
							a32 = a31*-sin+a32*cos;
							a21 = t2;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY = 180 - tm.rotationY;
						}

						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						if (tm.rotationX || tm.rotationY) {
							tm.skewX = 0;
						} else {
							tm.skewX = (a12 || a22) ? Math.atan2(a12, a22) * _RAD2DEG + tm.rotation : tm.skewX || 0;
							if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
								if (invX) {
									tm.scaleX *= -1;
									tm.skewX += (tm.rotation <= 0) ? 180 : -180;
									tm.rotation += (tm.rotation <= 0) ? 180 : -180;
								} else {
									tm.scaleY *= -1;
									tm.skewX += (tm.skewX <= 0) ? 180 : -180;
								}
							}
						}
						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
							if (invX) {
								scaleX *= -1;
								skewX += (rotation <= 0) ? 180 : -180;
								rotation += (rotation <= 0) ? 180 : -180;
							} else {
								scaleY *= -1;
								skewX += (skewX <= 0) ? 180 : -180;
							}
						}
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
							tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							TweenLite.delayedCall(0.001, function(){ //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
								_removeProp(t.style, _transformProp);
							});
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							TweenLite.delayedCall(0.001, function(){
								t.removeAttribute("transform");
							});
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					skewY = t.skewY,
					skewX = t.skewX,
					t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
				if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
					skewX += skewY;
					angle += skewY;
				}

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

					//2D
					if (angle || skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x < min) if (x > -min) {
								x = 0;
							}
							if (y < min) if (y > -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
						if (isSVG && _useSVGTransformAttr) {
							this.t.setAttribute("transform", "matrix(" + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
					min = 0.0001;
					if (sx < min && sx > -min) {
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || skewX) {
					angle *= _DEG2RAD;
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (skewX) {
						angle -= skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan((skewX - skewY) * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
							if (t.skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || isSVG) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {parser:function(t, e, parsingProp, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var scaleFunc = (vars.scale && typeof(vars.scale) === "function") ? vars.scale : 0, //if there's a function-based "scale" value, swap in the resulting numeric value temporarily. Otherwise, if it's called for both scaleX and scaleY independently, they may not match (like if the function uses Math.random()).
				swapFunc;
			if (typeof(vars[parsingProp]) === "function") { //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
				swapFunc = vars[parsingProp];
				vars[parsingProp] = e;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc(_index, t);
			}
			var originalGSTransform = t._gsTransform,
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				transformOriginString = "transformOrigin",
				m1 = _getTransform(t, _cs, true, v.parseTransform),
				orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
				m2, copy, has3D, hasChange, dr, x, y, matrix, p;
			cssp._transform = m1;
			if (orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = orig;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				if (m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
					x = m1.xOrigin;
					y = m1.yOrigin;
					m2.x -= m1.xOffset;
					m2.y -= m1.yOffset;
					if (v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
						orig = {};
						_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
						x = orig.xOrigin;
						y = orig.yOrigin;
						m2.x -= orig.xOffset - m1.xOffset;
						m2.y -= orig.yOffset - m1.yOffset;
					}
					if (x || y) {
						matrix = _getMatrix(_tempDiv, true);
						m2.x -= x - (x * matrix[0] + y * matrix[2]);
						m2.y -= y - (x * matrix[1] + y * matrix[3]);
					}
				}
				_doc.body.removeChild(_tempDiv);
				if (!m2.perspective) {
					m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
				}
				if (v.xPercent != null) {
					m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
				}
				if (v.yPercent != null) {
					m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
				}
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = _parseAngle(v.skewX, m1.skewX);
				m2.skewY = _parseAngle(v.skewY, m1.skewY);
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
				y = m1.yOffset;
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
				pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
				pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
				if (x !== m1.xOffset || y !== m1.yOffset) {
					pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
					pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
				}
				orig = "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			if (swapFunc) {
				vars[parsingProp] = swapFunc;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc;
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
		}, prefix:true, formatter:_getFormatter("0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:function(v) {
			v += ""; //ensure it's a string
			return _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong).
		}});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
			var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
				end = this.format(e).split(" "),
				esfx = end[0].replace(_suffixExp, "");
			if (esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
				bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
			}
			return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			t.setAttribute("class", pt.e);
			difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
			t.setAttribute("class", b);
			pt.data = difData.firstMPT;
			t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform, transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween, index) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = _target = target;
			this._tween = tween;
			this._vars = vars;
			_index = index;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				if (typeof(es) === "function") {
					es = es(_index, _target);
				}
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);

				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		p._mod = function(lookup) {
			var pt = this._firstPT;
			while (pt) {
				if (typeof(lookup[pt.p]) === "function" && lookup[pt.p] === Math.round) { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally..
					pt.r = 1;
				}
				pt = pt._next;
			}
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
					pt.plugin._kill(lookup);
					p = pt.plugin;
				}
				pt = pt._next;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				version: "1.6.0",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			_roundLinkedList = function(node) {
				while (node) {
					if (!node.f && !node.blob) {
						node.m = Math.round;
					}
					node = node._next;
				}
			},
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = Math.round;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, Math.round);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */

	(function() {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.6.0",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function(target, value, tween, index) {
				var p, end;
				if (typeof(target.setAttribute) !== "function") {
					return false;
				}
				for (p in value) {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});

	}());










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.3.0",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween, index) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					split = (end + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + 1;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return ((this._p2 * p) >> 0) * this._p1;
		};
		p.config = SteppedEase.config = function(steps) {
			return new SteppedEase(steps);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _exports = {},
			_doc = window.document,
			_globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++])) {}
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl, hasModule;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							hasModule = (typeof(module) !== "undefined" && module.exports);
							if (!hasModule && typeof(define) === "function" && define.amd){ //AMD
								define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
							} else if (hasModule){ //node
								if (ns === moduleName) {
									module.exports = _exports[moduleName] = cl;
									for (i in _exports) {
										cl[i] = _exports[i];
									}
								} else if (_exports[moduleName]) {
									_exports[moduleName][n] = cl;
								}
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			_blankArray = [],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				if (i > 1) {
					list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
				}
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function(seamless) {
				if (_id !== null) {
					_self.sleep();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === "auto" && _self.frame < 5 && _doc.visibilityState !== "hidden") {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000) {
					_ticker.wake();
				}
				setTimeout(_checkTimeout, 2000);
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

		p._callback = function(type) {
			var v = this.vars,
				callback = v[type],
				params = v[type + "Params"],
				scope = v[type + "Scope"] || v.callbackScope || this,
				l = params ? params.length : 0;
			switch (l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
				case 0: callback.call(scope); break;
				case 1: callback.call(scope, params[0]); break;
				case 2: callback.call(scope, params[0], params[1]); break;
				default: callback.apply(scope, params);
			}
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					if (_lazyTweens.length) {
						_lazyRender();
					}
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			var duration = this.duration();
			return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				var pauseTime = this._pauseTime,
					t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			return this._uncache(false);
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
					this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.19.1";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(_doc) === "undefined") ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
			//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
			_setRatio = function(v) {
				var pt = this._firstPT,
					min = 0.000001,
					val;
				while (pt) {
					val = !pt.blob ? pt.c * v + pt.s : (v === 1) ? this.end : v ? this.join("") : this.start;
					if (pt.m) {
						val = pt.m(val, this._target || pt.t);
					} else if (val < min) if (val > -min && !pt.blob) { //prevents issues with converting very small numbers to strings in the browser
						val = 0;
					}
					if (!pt.f) {
						pt.t[pt.p] = val;
					} else if (pt.fp) {
						pt.t[pt.p](pt.fp, val);
					} else {
						pt.t[pt.p](val);
					}
					pt = pt._next;
				}
			},
			//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
			_blobDif = function(start, end, filter, pt) {
				var a = [],
					charIndex = 0,
					s = "",
					color = 0,
					startNums, endNums, num, i, l, nonNumbers, currentNum;
				a.start = start;
				a.end = end;
				start = a[0] = start + ""; //ensure values are strings
				end = a[1] = end + "";
				if (filter) {
					filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
					start = a[0];
					end = a[1];
				}
				a.length = 0;
				startNums = start.match(_numbersExp) || [];
				endNums = end.match(_numbersExp) || [];
				if (pt) {
					pt._next = null;
					pt.blob = 1;
					a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
				}
				l = endNums.length;
				for (i = 0; i < l; i++) {
					currentNum = endNums[i];
					nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
					s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
					charIndex += nonNumbers.length;
					if (color) { //sense rgba() values and round them.
						color = (color + 1) % 5;
					} else if (nonNumbers.substr(-5) === "rgba(") {
						color = 1;
					}
					if (currentNum === startNums[i] || startNums.length <= i) {
						s += currentNum;
					} else {
						if (s) {
							a.push(s);
							s = "";
						}
						num = parseFloat(startNums[i]);
						a.push(num);
						a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color && color < 4) ? Math.round : 0};
						//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
					}
					charIndex += currentNum.length;
				}
				s += end.substr(charIndex);
				if (s) {
					a.push(s);
				}
				a.setRatio = _setRatio;
				return a;
			},
			//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
			_addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
				if (typeof(end) === "function") {
					end = end(index || 0, target);
				}
				var type = typeof(target[prop]),
					getterName = (type !== "function") ? "" : ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3)),
					s = (start !== "get") ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
					isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
					pt = {t:target, p:prop, s:s, f:(type === "function"), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0},
					blob;

				if (typeof(s) !== "number" || (typeof(end) !== "number" && !isRelative)) {
					if (funcParam || isNaN(s) || (!isRelative && isNaN(end)) || typeof(s) === "boolean" || typeof(end) === "boolean") {
						//a blob (string that has multiple numbers in it)
						pt.fp = funcParam;
						blob = _blobDif(s, (isRelative ? pt.s + pt.c : end), stringFilter || TweenLite.defaultStringFilter, pt);
						pt = {t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0}; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
					} else {
						pt.s = parseFloat(s);
						if (!isRelative) {
							pt.c = (parseFloat(end) - pt.s) || 0;
						}
					}
				}
				if (pt.c) { //only add it to the linked list if there's a change.
					if ((pt._next = this._firstPT)) {
						pt._next._prev = pt;
					}
					this._firstPT = pt;
					return pt;
				}
			},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens, blobDif:_blobDif}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1, callbackScope:1, stringFilter:1, id:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},
			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (curTween._kill(null, target, tween)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},
			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars, l;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				l = this._targets.length;
				for (i = 0; i < l; i++) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					//m - mod           [function | 0]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else {
					propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, suppressEvents, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
					this._callback("onUpdate");
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, suppressEvents, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
				i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i], overwritingTween)) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
								if (pt.f) {
									pt.t[pt.p](pt.s);
								} else {
									pt.t[pt.p] = pt.s;
								}
								changed = true;
							}
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(Math.min(0, -this._delay)); //in case delay is negative.
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a;
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.19.0";
		TweenPlugin.API = 2;
		p._firstPT = null;
		p._addTween = _addPropTween;
		p.setRatio = _setRatio;

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._mod = p._roundProps = function(lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ]);
				if (val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_mod", mod:"_mod", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: " + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9idW5kbGUuanMiLCJqcy9tb2Rlcm5penIuanMiLCJqcy9wb2x5ZmlsbHMvc2VsZWN0ZWRPcHRpb25zLmpzIiwianMvc3JjL0RvbUVsZW1lbnQuanMiLCJqcy9zcmMvRG9tRnVuY3Rpb25zLmpzIiwianMvc3JjL0lucHV0cy5qcyIsImpzL3NyYy9VdGlscy5qcyIsImpzL3NyYy9hY2NvcmRpb24vQWNjb3JkaW9uLmpzIiwianMvc3JjL2Nhcm91c2VsL0Nhcm91c2VsLmpzIiwianMvc3JjL2NoYXJ0cy9CYXJDaGFydEhvcml6b250YWwuanMiLCJqcy9zcmMvY2hhcnRzL0JhckNoYXJ0VmVydGljYWwuanMiLCJqcy9zcmMvY2hhcnRzL0NoYXJ0RnVuY3Rpb25zLmpzIiwianMvc3JjL2NoYXJ0cy9QaWVDaGFydC5qcyIsImpzL3NyYy9jb2xsYXBzZS9Db2xsYXBzZS5qcyIsImpzL3NyYy9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZS5qcyIsImpzL3NyYy9mb3JtL0F1dG9jb21wbGV0ZS5qcyIsImpzL3NyYy9mb3JtL0lucHV0RmllbGQuanMiLCJqcy9zcmMvZm9ybS9SYW5nZS5qcyIsImpzL3NyYy9mb3JtL1NlbGVjdC5qcyIsImpzL3NyYy9mb3JtL1RleHRhcmVhLmpzIiwianMvc3JjL2xvYWRlci9Mb2FkZXJCYXIuanMiLCJqcy9zcmMvbWVudS9NZW51Rmx5b3V0LmpzIiwianMvc3JjL21vZGFsL01vZGFsLmpzIiwianMvc3JjL25hdmlnYXRpb24vTmF2aWdhdGlvbi5qcyIsImpzL3NyYy9uYXZpZ2F0aW9uL05hdmlnYXRpb25TaWRlLmpzIiwianMvc3JjL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24uanMiLCJqcy9zcmMvcHJvZ3Jlc3MvUHJvZ3Jlc3NGdWxsLmpzIiwianMvc3JjL3Byb2dyZXNzL1Byb2dyZXNzTGlnaHQuanMiLCJqcy9zcmMvc2VhcmNoL1NlYXJjaElucHV0LmpzIiwianMvc3JjL3RhYmxlL1RhYmxlLmpzIiwianMvc3JjL3Rvb2xiYXIvVG9vbGJhci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvYXJyYXkvZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9tYXRoL3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvdHJ1bmMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC90cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZ3NhcC9Ud2Vlbk1heC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FDQUEsQUFBTzs7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O2tCQUFBLEFBQWU7OztBQ3ZEZjs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBcIi4vbW9kZXJuaXpyXCJcblxuLyogUG9seWZpbGxzICovXG5pbXBvcnQgXCIuL3BvbHlmaWxscy9zZWxlY3RlZE9wdGlvbnNcIlxuXG5pbXBvcnQgeyBvbkRvY3VtZW50UmVhZHkgfSBmcm9tIFwiLi9zcmMvVXRpbHNcIlxuaW1wb3J0ICogYXMgTG9hZGVyQmFyIGZyb20gXCIuL3NyYy9sb2FkZXIvTG9hZGVyQmFyXCJcblxuLyogRm9ybSBDb21wb25lbnRzICovXG5pbXBvcnQgKiBhcyBJbnB1dEZpZWxkcyBmcm9tIFwiLi9zcmMvZm9ybS9JbnB1dEZpZWxkXCJcbmltcG9ydCAqIGFzIFRleHRhcmVhIGZyb20gXCIuL3NyYy9mb3JtL1RleHRhcmVhXCJcbmltcG9ydCAqIGFzIFNlbGVjdCBmcm9tIFwiLi9zcmMvZm9ybS9TZWxlY3RcIlxuaW1wb3J0ICogYXMgUmFuZ2UgZnJvbSBcIi4vc3JjL2Zvcm0vUmFuZ2VcIlxuaW1wb3J0ICogYXMgQXV0b2NvbXBsZXRlIGZyb20gXCIuL3NyYy9mb3JtL0F1dG9jb21wbGV0ZVwiXG5cbmltcG9ydCAqIGFzIFByb2dyZXNzTGlnaHQgZnJvbSBcIi4vc3JjL3Byb2dyZXNzL1Byb2dyZXNzTGlnaHRcIlxuaW1wb3J0ICogYXMgUHJvZ3Jlc3NGdWxsIGZyb20gXCIuL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0Z1bGxcIlxuXG5pbXBvcnQgKiBhcyBNb2RhbCBmcm9tIFwiLi9zcmMvbW9kYWwvTW9kYWxcIlxuaW1wb3J0ICogYXMgVG9vbGJhciBmcm9tIFwiLi9zcmMvdG9vbGJhci9Ub29sYmFyXCJcblxuaW1wb3J0ICogYXMgTm90aWZpY2F0aW9uIGZyb20gXCIuL3NyYy9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uXCJcblxuaW1wb3J0ICogYXMgQ29sbGFwc2UgZnJvbSBcIi4vc3JjL2NvbGxhcHNlL0NvbGxhcHNlXCJcbmltcG9ydCAqIGFzIEFjY29yZGlvbiBmcm9tIFwiLi9zcmMvYWNjb3JkaW9uL0FjY29yZGlvblwiXG5pbXBvcnQgKiBhcyBNZW51Rmx5b3V0IGZyb20gXCIuL3NyYy9tZW51L01lbnVGbHlvdXRcIlxuXG5pbXBvcnQgKiBhcyBOYXZpZ2F0aW9uIGZyb20gXCIuL3NyYy9uYXZpZ2F0aW9uL05hdmlnYXRpb25cIlxuaW1wb3J0ICogYXMgTmF2aWdhdGlvblNpZGUgZnJvbSBcIi4vc3JjL25hdmlnYXRpb24vTmF2aWdhdGlvblNpZGVcIlxuaW1wb3J0ICogYXMgU2VhcmNoSW5wdXQgZnJvbSBcIi4vc3JjL3NlYXJjaC9TZWFyY2hJbnB1dFwiXG5pbXBvcnQgKiBhcyBFbXB0eVN0YXRlIGZyb20gXCIuL3NyYy9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZVwiXG5pbXBvcnQgKiBhcyBDYXJvdXNlbCBmcm9tIFwiLi9zcmMvY2Fyb3VzZWwvQ2Fyb3VzZWxcIlxuXG5pbXBvcnQgKiBhcyBUYWJsZSBmcm9tIFwiLi9zcmMvdGFibGUvVGFibGVcIlxuXG5pbXBvcnQgKiBhcyBQaWVDaGFydCBmcm9tIFwiLi9zcmMvY2hhcnRzL1BpZUNoYXJ0XCJcbmltcG9ydCAqIGFzIEJhckNoYXJ0SG9yaXpvbnRhbCBmcm9tIFwiLi9zcmMvY2hhcnRzL0JhckNoYXJ0SG9yaXpvbnRhbFwiXG5pbXBvcnQgKiBhcyBCYXJDaGFydFZlcnRpY2FsIGZyb20gXCIuL3NyYy9jaGFydHMvQmFyQ2hhcnRWZXJ0aWNhbFwiXG5cbm9uRG9jdW1lbnRSZWFkeSgoKSA9PiB7XG4gIElucHV0RmllbGRzLmluaXQoKVxuICBUZXh0YXJlYS5pbml0KClcbiAgU2VsZWN0LmluaXQoKVxuICBMb2FkZXJCYXIuaW5pdCgpXG4gIEF1dG9jb21wbGV0ZS5pbml0KClcblxuICBQcm9ncmVzc0xpZ2h0LmluaXQoKVxuICBQcm9ncmVzc0Z1bGwuaW5pdCgpXG5cbiAgUmFuZ2UuaW5pdCgpXG4gIE1vZGFsLmluaXQoKVxuXG4gIEFjY29yZGlvbi5pbml0KClcbiAgQ29sbGFwc2UuaW5pdCgpXG4gIE1lbnVGbHlvdXQuaW5pdCgpXG5cbiAgTmF2aWdhdGlvbi5pbml0KClcbiAgTmF2aWdhdGlvblNpZGUuaW5pdCgpXG4gIFNlYXJjaElucHV0LmluaXQoKVxuICBFbXB0eVN0YXRlLmluaXQoKVxuICBDYXJvdXNlbC5pbml0KClcbiAgVGFibGUuaW5pdCgpXG5cbiAgUGllQ2hhcnQuaW5pdCgpXG4gIEJhckNoYXJ0SG9yaXpvbnRhbC5pbml0KClcbiAgQmFyQ2hhcnRWZXJ0aWNhbC5pbml0KClcbn0pXG5cbmxldCBzZHggPSB3aW5kb3cuc2R4IHx8IHt9XG5cbnNkeC5WRVJTSU9OID0gXCIkVkVSU0lPTiRcIlxuc2R4LkxvYWRlckJhciA9IExvYWRlckJhci5kZWZhdWx0XG5zZHguU2VsZWN0ID0gU2VsZWN0LmRlZmF1bHRcbnNkeC5JbnB1dEZpZWxkID0gSW5wdXRGaWVsZHMuZGVmYXVsdFxuc2R4LlRleHRhcmVhID0gVGV4dGFyZWEuZGVmYXVsdFxuc2R4LkF1dG9jb21wbGV0ZSA9IEF1dG9jb21wbGV0ZS5kZWZhdWx0XG5cbnNkeC5Qcm9ncmVzc0xpZ2h0ID0gUHJvZ3Jlc3NMaWdodC5kZWZhdWx0XG5zZHguUHJvZ3Jlc3NGdWxsID0gUHJvZ3Jlc3NGdWxsLmRlZmF1bHRcblxuc2R4LlJhbmdlID0gUmFuZ2UuZGVmYXVsdFxuc2R4Lk1vZGFsID0gTW9kYWwuZGVmYXVsdFxuc2R4LlRvb2xiYXIgPSBUb29sYmFyLmRlZmF1bHRcbnNkeC5Ob3RpZmljYXRpb24gPSBOb3RpZmljYXRpb25cblxuc2R4LkNvbGxhcHNlID0gQ29sbGFwc2UuZGVmYXVsdFxuc2R4LkFjY29yZGlvbiA9IEFjY29yZGlvbi5kZWZhdWx0XG5cbnNkeC5NZW51Rmx5b3V0ID0gTWVudUZseW91dC5kZWZhdWx0XG5cbnNkeC5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbi5kZWZhdWx0XG5zZHguTmF2aWdhdGlvblNpZGUgPSBOYXZpZ2F0aW9uU2lkZS5kZWZhdWx0XG5zZHguU2VhcmNoSW5wdXQgPSBTZWFyY2hJbnB1dC5kZWZhdWx0XG5zZHguRW1wdHlTdGF0ZSA9IEVtcHR5U3RhdGUuZGVmYXVsdFxuc2R4LkNhcm91c2VsID0gQ2Fyb3VzZWwuZGVmYXVsdFxuXG5zZHguVGFibGUgPSBUYWJsZS5kZWZhdWx0XG5cbnNkeC5QaWVDaGFydCA9IFBpZUNoYXJ0LmRlZmF1bHRcbnNkeC5CYXJDaGFydEhvcml6b250YWwgPSBCYXJDaGFydEhvcml6b250YWwuZGVmYXVsdFxuc2R4LkJhckNoYXJ0VmVydGljYWwgPSBCYXJDaGFydFZlcnRpY2FsLmRlZmF1bHRcblxud2luZG93LnNkeCA9IHNkeFxuIiwiLyohXG4gKiBtb2Rlcm5penIgdjMuNS4wXG4gKiBCdWlsZCBodHRwczovL21vZGVybml6ci5jb20vZG93bmxvYWQ/LWhpZGRlbnNjcm9sbC10b3VjaGV2ZW50cy1zZXRjbGFzc2VzLWRvbnRtaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpXG4gKiAgRmFydWsgQXRlc1xuICogIFBhdWwgSXJpc2hcbiAqICBBbGV4IFNleHRvblxuICogIFJ5YW4gU2VkZG9uXG4gKiAgUGF0cmljayBLZXR0bmVyXG4gKiAgU3R1IENveFxuICogIFJpY2hhcmQgSGVycmVyYVxuXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qXG4gKiBNb2Rlcm5penIgdGVzdHMgd2hpY2ggbmF0aXZlIENTUzMgYW5kIEhUTUw1IGZlYXR1cmVzIGFyZSBhdmFpbGFibGUgaW4gdGhlXG4gKiBjdXJyZW50IFVBIGFuZCBtYWtlcyB0aGUgcmVzdWx0cyBhdmFpbGFibGUgdG8geW91IGluIHR3byB3YXlzOiBhcyBwcm9wZXJ0aWVzIG9uXG4gKiBhIGdsb2JhbCBgTW9kZXJuaXpyYCBvYmplY3QsIGFuZCBhcyBjbGFzc2VzIG9uIHRoZSBgPGh0bWw+YCBlbGVtZW50LiBUaGlzXG4gKiBpbmZvcm1hdGlvbiBhbGxvd3MgeW91IHRvIHByb2dyZXNzaXZlbHkgZW5oYW5jZSB5b3VyIHBhZ2VzIHdpdGggYSBncmFudWxhciBsZXZlbFxuICogb2YgY29udHJvbCBvdmVyIHRoZSBleHBlcmllbmNlLlxuKi9cblxuOyhmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpe1xuICB2YXIgdGVzdHMgPSBbXTtcbiAgXG5cbiAgLyoqXG4gICAqXG4gICAqIE1vZGVybml6clByb3RvIGlzIHRoZSBjb25zdHJ1Y3RvciBmb3IgTW9kZXJuaXpyXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgKi9cblxuICB2YXIgTW9kZXJuaXpyUHJvdG8gPSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiwgZHVtbXlcbiAgICBfdmVyc2lvbjogJzMuNS4wJyxcblxuICAgIC8vIEFueSBzZXR0aW5ncyB0aGF0IGRvbid0IHdvcmsgYXMgc2VwYXJhdGUgbW9kdWxlc1xuICAgIC8vIGNhbiBnbyBpbiBoZXJlIGFzIGNvbmZpZ3VyYXRpb24uXG4gICAgX2NvbmZpZzoge1xuICAgICAgJ2NsYXNzUHJlZml4JzogJycsXG4gICAgICAnZW5hYmxlQ2xhc3Nlcyc6IHRydWUsXG4gICAgICAnZW5hYmxlSlNDbGFzcyc6IHRydWUsXG4gICAgICAndXNlUHJlZml4ZXMnOiB0cnVlXG4gICAgfSxcblxuICAgIC8vIFF1ZXVlIG9mIHRlc3RzXG4gICAgX3E6IFtdLFxuXG4gICAgLy8gU3R1YiB0aGVzZSBmb3IgcGVvcGxlIHdobyBhcmUgbGlzdGVuaW5nXG4gICAgb246IGZ1bmN0aW9uKHRlc3QsIGNiKSB7XG4gICAgICAvLyBJIGRvbid0IHJlYWxseSB0aGluayBwZW9wbGUgc2hvdWxkIGRvIHRoaXMsIGJ1dCB3ZSBjYW5cbiAgICAgIC8vIHNhZmUgZ3VhcmQgaXQgYSBiaXQuXG4gICAgICAvLyAtLSBOT1RFOjogdGhpcyBnZXRzIFdBWSBvdmVycmlkZGVuIGluIHNyYy9hZGRUZXN0IGZvciBhY3R1YWwgYXN5bmMgdGVzdHMuXG4gICAgICAvLyBUaGlzIGlzIGluIGNhc2UgcGVvcGxlIGxpc3RlbiB0byBzeW5jaHJvbm91cyB0ZXN0cy4gSSB3b3VsZCBsZWF2ZSBpdCBvdXQsXG4gICAgICAvLyBidXQgdGhlIGNvZGUgdG8gKmRpc2FsbG93KiBzeW5jIHRlc3RzIGluIHRoZSByZWFsIHZlcnNpb24gb2YgdGhpc1xuICAgICAgLy8gZnVuY3Rpb24gaXMgYWN0dWFsbHkgbGFyZ2VyIHRoYW4gdGhpcy5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHNlbGZbdGVzdF0pO1xuICAgICAgfSwgMCk7XG4gICAgfSxcblxuICAgIGFkZFRlc3Q6IGZ1bmN0aW9uKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgICB0ZXN0cy5wdXNoKHtuYW1lOiBuYW1lLCBmbjogZm4sIG9wdGlvbnM6IG9wdGlvbnN9KTtcbiAgICB9LFxuXG4gICAgYWRkQXN5bmNUZXN0OiBmdW5jdGlvbihmbikge1xuICAgICAgdGVzdHMucHVzaCh7bmFtZTogbnVsbCwgZm46IGZufSk7XG4gICAgfVxuICB9O1xuXG4gIFxuXG4gIC8vIEZha2Ugc29tZSBvZiBPYmplY3QuY3JlYXRlIHNvIHdlIGNhbiBmb3JjZSBub24gdGVzdCByZXN1bHRzIHRvIGJlIG5vbiBcIm93blwiIHByb3BlcnRpZXMuXG4gIHZhciBNb2Rlcm5penIgPSBmdW5jdGlvbigpIHt9O1xuICBNb2Rlcm5penIucHJvdG90eXBlID0gTW9kZXJuaXpyUHJvdG87XG5cbiAgLy8gTGVhayBtb2Rlcm5penIgZ2xvYmFsbHkgd2hlbiB5b3UgYHJlcXVpcmVgIGl0IHJhdGhlciB0aGFuIGZvcmNlIGl0IGhlcmUuXG4gIC8vIE92ZXJ3cml0ZSBuYW1lIHNvIGNvbnN0cnVjdG9yIG5hbWUgaXMgbmljZXIgOkRcbiAgTW9kZXJuaXpyID0gbmV3IE1vZGVybml6cigpO1xuXG4gIFxuXG4gIHZhciBjbGFzc2VzID0gW107XG4gIFxuXG4gIC8qKlxuICAgKiBpcyByZXR1cm5zIGEgYm9vbGVhbiBpZiB0aGUgdHlwZW9mIGFuIG9iaiBpcyBleGFjdGx5IHR5cGUuXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gaXNcbiAgICogQHBhcmFtIHsqfSBvYmogLSBBIHRoaW5nIHdlIHdhbnQgdG8gY2hlY2sgdGhlIHR5cGUgb2ZcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBBIHN0cmluZyB0byBjb21wYXJlIHRoZSB0eXBlb2YgYWdhaW5zdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXMob2JqLCB0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IHR5cGU7XG4gIH1cbiAgO1xuXG4gIC8qKlxuICAgKiBSdW4gdGhyb3VnaCBhbGwgdGVzdHMgYW5kIGRldGVjdCB0aGVpciBzdXBwb3J0IGluIHRoZSBjdXJyZW50IFVBLlxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gdGVzdFJ1bm5lcigpIHtcbiAgICB2YXIgZmVhdHVyZU5hbWVzO1xuICAgIHZhciBmZWF0dXJlO1xuICAgIHZhciBhbGlhc0lkeDtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBmZWF0dXJlTmFtZTtcbiAgICB2YXIgZmVhdHVyZU5hbWVTcGxpdDtcblxuICAgIGZvciAodmFyIGZlYXR1cmVJZHggaW4gdGVzdHMpIHtcbiAgICAgIGlmICh0ZXN0cy5oYXNPd25Qcm9wZXJ0eShmZWF0dXJlSWR4KSkge1xuICAgICAgICBmZWF0dXJlTmFtZXMgPSBbXTtcbiAgICAgICAgZmVhdHVyZSA9IHRlc3RzW2ZlYXR1cmVJZHhdO1xuICAgICAgICAvLyBydW4gdGhlIHRlc3QsIHRocm93IHRoZSByZXR1cm4gdmFsdWUgaW50byB0aGUgTW9kZXJuaXpyLFxuICAgICAgICAvLyB0aGVuIGJhc2VkIG9uIHRoYXQgYm9vbGVhbiwgZGVmaW5lIGFuIGFwcHJvcHJpYXRlIGNsYXNzTmFtZVxuICAgICAgICAvLyBhbmQgcHVzaCBpdCBpbnRvIGFuIGFycmF5IG9mIGNsYXNzZXMgd2UnbGwgam9pbiBsYXRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmFtZSwgaXQncyBhbiAnYXN5bmMnIHRlc3QgdGhhdCBpcyBydW4sXG4gICAgICAgIC8vIGJ1dCBub3QgZGlyZWN0bHkgYWRkZWQgdG8gdGhlIG9iamVjdC4gVGhhdCBzaG91bGRcbiAgICAgICAgLy8gYmUgZG9uZSB3aXRoIGEgcG9zdC1ydW4gYWRkVGVzdCBjYWxsLlxuICAgICAgICBpZiAoZmVhdHVyZS5uYW1lKSB7XG4gICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2goZmVhdHVyZS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgaWYgKGZlYXR1cmUub3B0aW9ucyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcyAmJiBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhbGwgdGhlIGFsaWFzZXMgaW50byB0aGUgbmFtZXMgbGlzdFxuICAgICAgICAgICAgZm9yIChhbGlhc0lkeCA9IDA7IGFsaWFzSWR4IDwgZmVhdHVyZS5vcHRpb25zLmFsaWFzZXMubGVuZ3RoOyBhbGlhc0lkeCsrKSB7XG4gICAgICAgICAgICAgIGZlYXR1cmVOYW1lcy5wdXNoKGZlYXR1cmUub3B0aW9ucy5hbGlhc2VzW2FsaWFzSWR4XS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdW4gdGhlIHRlc3QsIG9yIHVzZSB0aGUgcmF3IHZhbHVlIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb25cbiAgICAgICAgcmVzdWx0ID0gaXMoZmVhdHVyZS5mbiwgJ2Z1bmN0aW9uJykgPyBmZWF0dXJlLmZuKCkgOiBmZWF0dXJlLmZuO1xuXG5cbiAgICAgICAgLy8gU2V0IGVhY2ggb2YgdGhlIG5hbWVzIG9uIHRoZSBNb2Rlcm5penIgb2JqZWN0XG4gICAgICAgIGZvciAobmFtZUlkeCA9IDA7IG5hbWVJZHggPCBmZWF0dXJlTmFtZXMubGVuZ3RoOyBuYW1lSWR4KyspIHtcbiAgICAgICAgICBmZWF0dXJlTmFtZSA9IGZlYXR1cmVOYW1lc1tuYW1lSWR4XTtcbiAgICAgICAgICAvLyBTdXBwb3J0IGRvdCBwcm9wZXJ0aWVzIGFzIHN1YiB0ZXN0cy4gV2UgZG9uJ3QgZG8gY2hlY2tpbmcgdG8gbWFrZSBzdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgaW1wbGllZCBwYXJlbnQgdGVzdHMgaGF2ZSBiZWVuIGFkZGVkLiBZb3UgbXVzdCBjYWxsIHRoZW0gaW5cbiAgICAgICAgICAvLyBvcmRlciAoZWl0aGVyIGluIHRoZSB0ZXN0LCBvciBtYWtlIHRoZSBwYXJlbnQgdGVzdCBhIGRlcGVuZGVuY3kpLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQ2FwIGl0IHRvIFRXTyB0byBtYWtlIHRoZSBsb2dpYyBzaW1wbGUgYW5kIGJlY2F1c2Ugd2hvIG5lZWRzIHRoYXQga2luZCBvZiBzdWJ0ZXN0aW5nXG4gICAgICAgICAgLy8gaGFzaHRhZyBmYW1vdXMgbGFzdCB3b3Jkc1xuICAgICAgICAgIGZlYXR1cmVOYW1lU3BsaXQgPSBmZWF0dXJlTmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgaWYgKGZlYXR1cmVOYW1lU3BsaXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV0gPSByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhc3QgdG8gYSBCb29sZWFuLCBpZiBub3Qgb25lIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV0gJiYgIShNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV0gaW5zdGFuY2VvZiBCb29sZWFuKSkge1xuICAgICAgICAgICAgICBNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV0gPSBuZXcgQm9vbGVhbihNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBNb2Rlcm5penJbZmVhdHVyZU5hbWVTcGxpdFswXV1bZmVhdHVyZU5hbWVTcGxpdFsxXV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKChyZXN1bHQgPyAnJyA6ICduby0nKSArIGZlYXR1cmVOYW1lU3BsaXQuam9pbignLScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICA7XG5cbiAgLyoqXG4gICAqIGRvY0VsZW1lbnQgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIHRvIGdyYWIgdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICAgKi9cblxuICB2YXIgZG9jRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgaGVscGVyIHRvIGNoZWNrIGlmIHRoZSBkb2N1bWVudCB3ZSBhcmUgcnVubmluZyBpbiBpcyBhbiBTVkcgZG9jdW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICB2YXIgaXNTVkcgPSBkb2NFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnO1xuICBcblxuICAvKipcbiAgICogc2V0Q2xhc3NlcyB0YWtlcyBhbiBhcnJheSBvZiBjbGFzcyBuYW1lcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBzZXRDbGFzc2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzZXMgLSBBcnJheSBvZiBjbGFzcyBuYW1lc1xuICAgKi9cblxuICAvLyBQYXNzIGluIGFuIGFuZCBhcnJheSBvZiBjbGFzcyBuYW1lcywgZS5nLjpcbiAgLy8gIFsnbm8td2VicCcsICdib3JkZXJyYWRpdXMnLCAuLi5dXG4gIGZ1bmN0aW9uIHNldENsYXNzZXMoY2xhc3Nlcykge1xuICAgIHZhciBjbGFzc05hbWUgPSBkb2NFbGVtZW50LmNsYXNzTmFtZTtcbiAgICB2YXIgY2xhc3NQcmVmaXggPSBNb2Rlcm5penIuX2NvbmZpZy5jbGFzc1ByZWZpeCB8fCAnJztcblxuICAgIGlmIChpc1NWRykge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLmJhc2VWYWw7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIGBuby1qc2AgdG8gYGpzYCAoaW5kZXBlbmRlbnRseSBvZiB0aGUgYGVuYWJsZUNsYXNzZXNgIG9wdGlvbilcbiAgICAvLyBIYW5kbGUgY2xhc3NQcmVmaXggb24gdGhpcyB0b29cbiAgICBpZiAoTW9kZXJuaXpyLl9jb25maWcuZW5hYmxlSlNDbGFzcykge1xuICAgICAgdmFyIHJlSlMgPSBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NQcmVmaXggKyAnbm8tanMoXFxcXHN8JCknKTtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKHJlSlMsICckMScgKyBjbGFzc1ByZWZpeCArICdqcyQyJyk7XG4gICAgfVxuXG4gICAgaWYgKE1vZGVybml6ci5fY29uZmlnLmVuYWJsZUNsYXNzZXMpIHtcbiAgICAgIC8vIEFkZCB0aGUgbmV3IGNsYXNzZXNcbiAgICAgIGNsYXNzTmFtZSArPSAnICcgKyBjbGFzc1ByZWZpeCArIGNsYXNzZXMuam9pbignICcgKyBjbGFzc1ByZWZpeCk7XG4gICAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVFbGVtZW50IGlzIGEgY29udmVuaWVuY2Ugd3JhcHBlciBhcm91bmQgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC4gU2luY2Ugd2VcbiAgICogdXNlIGNyZWF0ZUVsZW1lbnQgYWxsIG92ZXIgdGhlIHBsYWNlLCB0aGlzIGFsbG93cyBmb3IgKHNsaWdodGx5KSBzbWFsbGVyIGNvZGVcbiAgICogYXMgd2VsbCBhcyBhYnN0cmFjdGluZyBhd2F5IGlzc3VlcyB3aXRoIGNyZWF0aW5nIGVsZW1lbnRzIGluIGNvbnRleHRzIG90aGVyIHRoYW5cbiAgICogSFRNTCBkb2N1bWVudHMgKGUuZy4gU1ZHIGRvY3VtZW50cykuXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gY3JlYXRlRWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8U1ZHRWxlbWVudH0gQW4gSFRNTCBvciBTVkcgZWxlbWVudFxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSBpbiBJRTcsIHdoZXJlIHRoZSB0eXBlIG9mIGNyZWF0ZUVsZW1lbnQgaXMgXCJvYmplY3RcIi5cbiAgICAgIC8vIEZvciB0aGlzIHJlYXNvbiwgd2UgY2Fubm90IGNhbGwgYXBwbHkoKSBhcyBPYmplY3QgaXMgbm90IGEgRnVuY3Rpb24uXG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSBpZiAoaXNTVkcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMuY2FsbChkb2N1bWVudCwgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkoZG9jdW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgO1xuXG4gIC8qKlxuICAgKiBnZXRCb2R5IHJldHVybnMgdGhlIGJvZHkgb2YgYSBkb2N1bWVudCwgb3IgYW4gZWxlbWVudCB0aGF0IGNhbiBzdGFuZCBpbiBmb3JcbiAgICogdGhlIGJvZHkgaWYgYSByZWFsIGJvZHkgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBnZXRCb2R5XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBSZXR1cm5zIHRoZSByZWFsIGJvZHkgb2YgYSBkb2N1bWVudCwgb3IgYW5cbiAgICogYXJ0aWZpY2lhbGx5IGNyZWF0ZWQgZWxlbWVudCB0aGF0IHN0YW5kcyBpbiBmb3IgdGhlIGJvZHlcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAvLyBBZnRlciBwYWdlIGxvYWQgaW5qZWN0aW5nIGEgZmFrZSBib2R5IGRvZXNuJ3Qgd29yayBzbyBjaGVjayBpZiBib2R5IGV4aXN0c1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuICAgIGlmICghYm9keSkge1xuICAgICAgLy8gQ2FuJ3QgdXNlIHRoZSByZWFsIGJvZHkgY3JlYXRlIGEgZmFrZSBvbmUuXG4gICAgICBib2R5ID0gY3JlYXRlRWxlbWVudChpc1NWRyA/ICdzdmcnIDogJ2JvZHknKTtcbiAgICAgIGJvZHkuZmFrZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGluamVjdEVsZW1lbnRXaXRoU3R5bGVzIGluamVjdHMgYW4gZWxlbWVudCB3aXRoIHN0eWxlIGVsZW1lbnQgYW5kIHNvbWUgQ1NTIHJ1bGVzXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gaW5qZWN0RWxlbWVudFdpdGhTdHlsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIGEgY3NzIHJ1bGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byB0ZXN0IHRoZSBpbmplY3RlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZXNdIC0gQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG5vZGVzIHlvdSB3YW50IGluamVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0ZXN0bmFtZXNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGFyZSB1c2VkIGFzIGlkcyBmb3IgdGhlIGFkZGl0aW9uYWwgbm9kZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluamVjdEVsZW1lbnRXaXRoU3R5bGVzKHJ1bGUsIGNhbGxiYWNrLCBub2RlcywgdGVzdG5hbWVzKSB7XG4gICAgdmFyIG1vZCA9ICdtb2Rlcm5penInO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBub2RlO1xuICAgIHZhciBkb2NPdmVyZmxvdztcbiAgICB2YXIgZGl2ID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGJvZHkgPSBnZXRCb2R5KCk7XG5cbiAgICBpZiAocGFyc2VJbnQobm9kZXMsIDEwKSkge1xuICAgICAgLy8gSW4gb3JkZXIgbm90IHRvIGdpdmUgZmFsc2UgcG9zaXRpdmVzIHdlIGNyZWF0ZSBhIG5vZGUgZm9yIGVhY2ggdGVzdFxuICAgICAgLy8gVGhpcyBhbHNvIGFsbG93cyB0aGUgbWV0aG9kIHRvIHNjYWxlIGZvciB1bnNwZWNpZmllZCB1c2VzXG4gICAgICB3aGlsZSAobm9kZXMtLSkge1xuICAgICAgICBub2RlID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG5vZGUuaWQgPSB0ZXN0bmFtZXMgPyB0ZXN0bmFtZXNbbm9kZXNdIDogbW9kICsgKG5vZGVzICsgMSk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZSA9IGNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgPSAncycgKyBtb2Q7XG5cbiAgICAvLyBJRTYgd2lsbCBmYWxzZSBwb3NpdGl2ZSBvbiBzb21lIHRlc3RzIGR1ZSB0byB0aGUgc3R5bGUgZWxlbWVudCBpbnNpZGUgdGhlIHRlc3QgZGl2IHNvbWVob3cgaW50ZXJmZXJpbmcgb2Zmc2V0SGVpZ2h0LCBzbyBpbnNlcnQgaXQgaW50byBib2R5IG9yIGZha2Vib2R5LlxuICAgIC8vIE9wZXJhIHdpbGwgYWN0IGFsbCBxdWlya3kgd2hlbiBpbmplY3RpbmcgZWxlbWVudHMgaW4gZG9jdW1lbnRFbGVtZW50IHdoZW4gcGFnZSBpcyBzZXJ2ZWQgYXMgeG1sLCBuZWVkcyBmYWtlYm9keSB0b28uICMyNzBcbiAgICAoIWJvZHkuZmFrZSA/IGRpdiA6IGJvZHkpLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cbiAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcnVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocnVsZSkpO1xuICAgIH1cbiAgICBkaXYuaWQgPSBtb2Q7XG5cbiAgICBpZiAoYm9keS5mYWtlKSB7XG4gICAgICAvL2F2b2lkIGNyYXNoaW5nIElFOCwgaWYgYmFja2dyb3VuZCBpbWFnZSBpcyB1c2VkXG4gICAgICBib2R5LnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgICAgIC8vU2FmYXJpIDUuMTMvNS4xLjQgT1NYIHN0b3BzIGxvYWRpbmcgaWYgOjotd2Via2l0LXNjcm9sbGJhciBpcyB1c2VkIGFuZCBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlXG4gICAgICBib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICBkb2NPdmVyZmxvdyA9IGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3c7XG4gICAgICBkb2NFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICBkb2NFbGVtZW50LmFwcGVuZENoaWxkKGJvZHkpO1xuICAgIH1cblxuICAgIHJldCA9IGNhbGxiYWNrKGRpdiwgcnVsZSk7XG4gICAgLy8gSWYgdGhpcyBpcyBkb25lIGFmdGVyIHBhZ2UgbG9hZCB3ZSBkb24ndCB3YW50IHRvIHJlbW92ZSB0aGUgYm9keSBzbyBjaGVjayBpZiBib2R5IGV4aXN0c1xuICAgIGlmIChib2R5LmZha2UpIHtcbiAgICAgIGJvZHkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib2R5KTtcbiAgICAgIGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBkb2NPdmVyZmxvdztcbiAgICAgIC8vIFRyaWdnZXIgbGF5b3V0IHNvIGtpbmV0aWMgc2Nyb2xsaW5nIGlzbid0IGRpc2FibGVkIGluIGlPUzYrXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGRvY0VsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIH1cblxuICAgIHJldHVybiAhIXJldDtcblxuICB9XG5cbiAgO1xuXG4gIC8qKlxuICAgKiB0ZXN0U3R5bGVzIGluamVjdHMgYW4gZWxlbWVudCB3aXRoIHN0eWxlIGVsZW1lbnQgYW5kIHNvbWUgQ1NTIHJ1bGVzXG4gICAqXG4gICAqIEBtZW1iZXJvZiBNb2Rlcm5penJcbiAgICogQG5hbWUgTW9kZXJuaXpyLnRlc3RTdHlsZXNcbiAgICogQG9wdGlvbk5hbWUgTW9kZXJuaXpyLnRlc3RTdHlsZXMoKVxuICAgKiBAb3B0aW9uUHJvcCB0ZXN0U3R5bGVzXG4gICAqIEBhY2Nlc3MgcHVibGljXG4gICAqIEBmdW5jdGlvbiB0ZXN0U3R5bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gU3RyaW5nIHJlcHJlc2VudGluZyBhIGNzcyBydWxlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gdGVzdCB0aGUgaW5qZWN0ZWQgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gW25vZGVzXSAtIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBub2RlcyB5b3Ugd2FudCBpbmplY3RlZFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbdGVzdG5hbWVzXSAtIEFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBhcmUgdXNlZCBhcyBpZHMgZm9yIHRoZSBhZGRpdGlvbmFsIG5vZGVzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgTW9kZXJuaXpyLnRlc3RTdHlsZXNgIHRha2VzIGEgQ1NTIHJ1bGUgYW5kIGluamVjdHMgaXQgb250byB0aGUgY3VycmVudCBwYWdlXG4gICAqIGFsb25nIHdpdGggKHBvc3NpYmx5IG11bHRpcGxlKSBET00gZWxlbWVudHMuIFRoaXMgbGV0cyB5b3UgY2hlY2sgZm9yIGZlYXR1cmVzXG4gICAqIHRoYXQgY2FuIG5vdCBiZSBkZXRlY3RlZCBieSBzaW1wbHkgY2hlY2tpbmcgdGhlIFtJRExdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTW96aWxsYS9EZXZlbG9wZXJfZ3VpZGUvSW50ZXJmYWNlX2RldmVsb3BtZW50X2d1aWRlL0lETF9pbnRlcmZhY2VfcnVsZXMpLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBNb2Rlcm5penIudGVzdFN0eWxlcygnI21vZGVybml6ciB7IHdpZHRoOiA5cHg7IGNvbG9yOiBwYXBheWF3aGlwOyB9JywgZnVuY3Rpb24oZWxlbSwgcnVsZSkge1xuICAgKiAgIC8vIGVsZW0gaXMgdGhlIGZpcnN0IERPTSBub2RlIGluIHRoZSBwYWdlIChieSBkZWZhdWx0ICNtb2Rlcm5penIpXG4gICAqICAgLy8gcnVsZSBpcyB0aGUgZmlyc3QgYXJndW1lbnQgeW91IHN1cHBsaWVkIC0gdGhlIENTUyBydWxlIGluIHN0cmluZyBmb3JtXG4gICAqXG4gICAqICAgYWRkVGVzdCgnd2lkdGh3b3JrcycsIGVsZW0uc3R5bGUud2lkdGggPT09ICc5cHgnKVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdXIgdGVzdCByZXF1aXJlcyBtdWx0aXBsZSBub2RlcywgeW91IGNhbiBpbmNsdWRlIGEgdGhpcmQgYXJndW1lbnRcbiAgICogaW5kaWNhdGluZyBob3cgbWFueSBhZGRpdGlvbmFsIGRpdiBlbGVtZW50cyB0byBpbmNsdWRlIG9uIHRoZSBwYWdlLiBUaGVcbiAgICogYWRkaXRpb25hbCBub2RlcyBhcmUgaW5qZWN0ZWQgYXMgY2hpbGRyZW4gb2YgdGhlIGBlbGVtYCB0aGF0IGlzIHJldHVybmVkIGFzXG4gICAqIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHt3aWR0aDogMXB4fTsgI21vZGVybml6cjIge3dpZHRoOiAycHh9JywgZnVuY3Rpb24oZWxlbSkge1xuICAgKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2Rlcm5penInKS5zdHlsZS53aWR0aCA9PT0gJzFweCc7IC8vIHRydWVcbiAgICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZXJuaXpyMicpLnN0eWxlLndpZHRoID09PSAnMnB4JzsgLy8gdHJ1ZVxuICAgKiAgIGVsZW0uZmlyc3RDaGlsZCA9PT0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVybml6cjInKTsgLy8gdHJ1ZVxuICAgKiB9LCAxKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBvZiB0aGUgYWRkaXRpb25hbCBlbGVtZW50cyBoYXZlIGFuIElEIG9mIGBtb2Rlcm5penJbbl1gLCB3aGVyZVxuICAgKiBgbmAgaXMgaXRzIGluZGV4IChlLmcuIHRoZSBmaXJzdCBhZGRpdGlvbmFsLCBzZWNvbmQgb3ZlcmFsbCBpcyBgI21vZGVybml6cjJgLFxuICAgKiB0aGUgc2Vjb25kIGFkZGl0aW9uYWwgaXMgYCNtb2Rlcm5penIzYCwgZXRjLikuXG4gICAqIElmIHlvdSB3YW50IHRvIGhhdmUgbW9yZSBtZWFuaW5nZnVsIElEcyBmb3IgeW91ciBmdW5jdGlvbiwgeW91IGNhbiBwcm92aWRlXG4gICAqIHRoZW0gYXMgdGhlIGZvdXJ0aCBhcmd1bWVudCwgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgKlxuICAgKiBgYGBqc1xuICAgKiBNb2Rlcm5penIudGVzdFN0eWxlcygnI2ZvbyB7d2lkdGg6IDEwcHh9OyAjYmFyIHtoZWlnaHQ6IDIwcHh9JywgZnVuY3Rpb24oZWxlbSkge1xuICAgKiAgIGVsZW0uZmlyc3RDaGlsZCA9PT0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpOyAvLyB0cnVlXG4gICAqICAgZWxlbS5sYXN0Q2hpbGQgPT09IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYXInKTsgLy8gdHJ1ZVxuICAgKiB9LCAyLCBbJ2ZvbycsICdiYXInXSk7XG4gICAqIGBgYFxuICAgKlxuICAgKi9cblxuICB2YXIgdGVzdFN0eWxlcyA9IE1vZGVybml6clByb3RvLnRlc3RTdHlsZXMgPSBpbmplY3RFbGVtZW50V2l0aFN0eWxlcztcbiAgXG4vKiFcbntcbiAgXCJuYW1lXCI6IFwiSGlkZGVuIFNjcm9sbGJhclwiLFxuICBcInByb3BlcnR5XCI6IFwiaGlkZGVuc2Nyb2xsXCIsXG4gIFwiYXV0aG9yc1wiOiBbXCJPbGVnIEtvcnN1bnNreVwiXSxcbiAgXCJ0YWdzXCI6IFtcIm92ZXJsYXlcIl0sXG4gIFwibm90ZXNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJPdmVybGF5IFNjcm9sbGJhciBkZXNjcmlwdGlvblwiLFxuICAgIFwiaHJlZlwiOiBcImh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L21hYy9yZWxlYXNlbm90ZXMvTWFjT1NYL1doYXRzTmV3SW5PU1gvQXJ0aWNsZXMvTWFjT1NYMTBfNy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAxMDM1NS1TVzM5XCJcbiAgfSx7XG4gICAgXCJuYW1lXCI6IFwiVmlkZW8gZXhhbXBsZSBvZiBvdmVybGF5IHNjcm9sbGJhcnNcIixcbiAgICBcImhyZWZcIjogXCJodHRwczovL2dmeWNhdC5jb20vRm9vbGlzaE1lYXNseUF0bGFudGljc2hhcnBub3NlcHVmZmVyXCJcbiAgfV1cbn1cbiEqL1xuLyogRE9DXG5EZXRlY3RzIG92ZXJsYXkgc2Nyb2xsYmFycyAod2hlbiBzY3JvbGxiYXJzIG9uIG92ZXJmbG93ZWQgYmxvY2tzIGFyZSB2aXNpYmxlKS4gVGhpcyBpcyBmb3VuZCBtb3N0IGNvbW1vbmx5IG9uIG1vYmlsZSBhbmQgT1MgWC5cbiovXG5cbiAgTW9kZXJuaXpyLmFkZFRlc3QoJ2hpZGRlbnNjcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHt3aWR0aDoxMDBweDtoZWlnaHQ6MTAwcHg7b3ZlcmZsb3c6c2Nyb2xsfScsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtLm9mZnNldFdpZHRoID09PSBlbGVtLmNsaWVudFdpZHRoO1xuICAgIH0pO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBzZXQgZm9yIGNzcyB0ZXN0cy4gU2VlIHRpY2tldCAjMjFcbiAgICogaHR0cDovL2dpdC5pby92VUdsNFxuICAgKlxuICAgKiBAbWVtYmVyb2YgTW9kZXJuaXpyXG4gICAqIEBuYW1lIE1vZGVybml6ci5fcHJlZml4ZXNcbiAgICogQG9wdGlvbk5hbWUgTW9kZXJuaXpyLl9wcmVmaXhlc1xuICAgKiBAb3B0aW9uUHJvcCBwcmVmaXhlc1xuICAgKiBAYWNjZXNzIHB1YmxpY1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBNb2Rlcm5penIuX3ByZWZpeGVzIGlzIHRoZSBpbnRlcm5hbCBsaXN0IG9mIHByZWZpeGVzIHRoYXQgd2UgdGVzdCBhZ2FpbnN0XG4gICAqIGluc2lkZSBvZiB0aGluZ3MgbGlrZSBbcHJlZml4ZWRdKCNtb2Rlcm5penItcHJlZml4ZWQpIGFuZCBbcHJlZml4ZWRDU1NdKCMtY29kZS1tb2Rlcm5penItcHJlZml4ZWRjc3MpLiBJdCBpcyBzaW1wbHlcbiAgICogYW4gYXJyYXkgb2Yga2ViYWItY2FzZSB2ZW5kb3IgcHJlZml4ZXMgeW91IGNhbiB1c2Ugd2l0aGluIHlvdXIgY29kZS5cbiAgICpcbiAgICogU29tZSBjb21tb24gdXNlIGNhc2VzIGluY2x1ZGVcbiAgICpcbiAgICogR2VuZXJhdGluZyBhbGwgcG9zc2libGUgcHJlZml4ZWQgdmVyc2lvbiBvZiBhIENTUyBwcm9wZXJ0eVxuICAgKiBgYGBqc1xuICAgKiB2YXIgcnVsZSA9IE1vZGVybml6ci5fcHJlZml4ZXMuam9pbigndHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyAnKTtcbiAgICpcbiAgICogcnVsZSA9PT0gJ3RyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsgd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsgbW96LXRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsgby10cmFuc2Zvcm06IHJvdGF0ZSgyMGRlZyk7IG1zLXRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsnXG4gICAqIGBgYFxuICAgKlxuICAgKiBHZW5lcmF0aW5nIGFsbCBwb3NzaWJsZSBwcmVmaXhlZCB2ZXJzaW9uIG9mIGEgQ1NTIHZhbHVlXG4gICAqIGBgYGpzXG4gICAqIHJ1bGUgPSAnZGlzcGxheTonICsgIE1vZGVybml6ci5fcHJlZml4ZXMuam9pbignZmxleDsgZGlzcGxheTonKSArICdmbGV4JztcbiAgICpcbiAgICogcnVsZSA9PT0gJ2Rpc3BsYXk6ZmxleDsgZGlzcGxheTotd2Via2l0LWZsZXg7IGRpc3BsYXk6LW1vei1mbGV4OyBkaXNwbGF5Oi1vLWZsZXg7IGRpc3BsYXk6LW1zLWZsZXg7IGRpc3BsYXk6ZmxleCdcbiAgICogYGBgXG4gICAqL1xuXG4gIC8vIHdlIHVzZSBbJycsJyddIHJhdGhlciB0aGFuIGFuIGVtcHR5IGFycmF5IGluIG9yZGVyIHRvIGFsbG93IGEgcGF0dGVybiBvZiAuYGpvaW4oKWBpbmcgcHJlZml4ZXMgdG8gdGVzdFxuICAvLyB2YWx1ZXMgaW4gZmVhdHVyZSBkZXRlY3RzIHRvIGNvbnRpbnVlIHRvIHdvcmtcbiAgdmFyIHByZWZpeGVzID0gKE1vZGVybml6clByb3RvLl9jb25maWcudXNlUHJlZml4ZXMgPyAnIC13ZWJraXQtIC1tb3otIC1vLSAtbXMtICcuc3BsaXQoJyAnKSA6IFsnJywnJ10pO1xuXG4gIC8vIGV4cG9zZSB0aGVzZSBmb3IgdGhlIHBsdWdpbiBBUEkuIExvb2sgaW4gdGhlIHNvdXJjZSBmb3IgaG93IHRvIGpvaW4oKSB0aGVtIGFnYWluc3QgeW91ciBpbnB1dFxuICBNb2Rlcm5penJQcm90by5fcHJlZml4ZXMgPSBwcmVmaXhlcztcblxuICBcbi8qIVxue1xuICBcIm5hbWVcIjogXCJUb3VjaCBFdmVudHNcIixcbiAgXCJwcm9wZXJ0eVwiOiBcInRvdWNoZXZlbnRzXCIsXG4gIFwiY2FuaXVzZVwiIDogXCJ0b3VjaFwiLFxuICBcInRhZ3NcIjogW1wibWVkaWFcIiwgXCJhdHRyaWJ1dGVcIl0sXG4gIFwibm90ZXNcIjogW3tcbiAgICBcIm5hbWVcIjogXCJUb3VjaCBFdmVudHMgc3BlY1wiLFxuICAgIFwiaHJlZlwiOiBcImh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELXRvdWNoLWV2ZW50cy0yMDEzMDEyNC9cIlxuICB9XSxcbiAgXCJ3YXJuaW5nc1wiOiBbXG4gICAgXCJJbmRpY2F0ZXMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIFRvdWNoIEV2ZW50cyBzcGVjLCBhbmQgZG9lcyBub3QgbmVjZXNzYXJpbHkgcmVmbGVjdCBhIHRvdWNoc2NyZWVuIGRldmljZVwiXG4gIF0sXG4gIFwia25vd25CdWdzXCI6IFtcbiAgICBcIkZhbHNlLXBvc2l0aXZlIG9uIHNvbWUgY29uZmlndXJhdGlvbnMgb2YgTm9raWEgTjkwMFwiLFxuICAgIFwiRmFsc2UtcG9zaXRpdmUgb24gc29tZSBCbGFja0JlcnJ5IDYuMCBidWlsZHMg4oCTIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2lzc3Vlcy8zNzIjaXNzdWVjb21tZW50LTMxMTI2OTVcIlxuICBdXG59XG4hKi9cbi8qIERPQ1xuSW5kaWNhdGVzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBXM0MgVG91Y2ggRXZlbnRzIEFQSS5cblxuVGhpcyAqZG9lcyBub3QqIG5lY2Vzc2FyaWx5IHJlZmxlY3QgYSB0b3VjaHNjcmVlbiBkZXZpY2U6XG5cbiogT2xkZXIgdG91Y2hzY3JlZW4gZGV2aWNlcyBvbmx5IGVtdWxhdGUgbW91c2UgZXZlbnRzXG4qIE1vZGVybiBJRSB0b3VjaCBkZXZpY2VzIGltcGxlbWVudCB0aGUgUG9pbnRlciBFdmVudHMgQVBJIGluc3RlYWQ6IHVzZSBgTW9kZXJuaXpyLnBvaW50ZXJldmVudHNgIHRvIGRldGVjdCBzdXBwb3J0IGZvciB0aGF0XG4qIFNvbWUgYnJvd3NlcnMgJiBPUyBzZXR1cHMgbWF5IGVuYWJsZSB0b3VjaCBBUElzIHdoZW4gbm8gdG91Y2hzY3JlZW4gaXMgY29ubmVjdGVkXG4qIEZ1dHVyZSBicm93c2VycyBtYXkgaW1wbGVtZW50IG90aGVyIGV2ZW50IG1vZGVscyBmb3IgdG91Y2ggaW50ZXJhY3Rpb25zXG5cblNlZSB0aGlzIGFydGljbGU6IFtZb3UgQ2FuJ3QgRGV0ZWN0IEEgVG91Y2hzY3JlZW5dKGh0dHA6Ly93d3cuc3R1Y294LmNvbS9ibG9nL3lvdS1jYW50LWRldGVjdC1hLXRvdWNoc2NyZWVuLykuXG5cbkl0J3MgcmVjb21tZW5kZWQgdG8gYmluZCBib3RoIG1vdXNlIGFuZCB0b3VjaC9wb2ludGVyIGV2ZW50cyBzaW11bHRhbmVvdXNseSDigJMgc2VlIFt0aGlzIEhUTUw1IFJvY2tzIHR1dG9yaWFsXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL21vYmlsZS90b3VjaGFuZG1vdXNlLykuXG5cblRoaXMgdGVzdCB3aWxsIGFsc28gcmV0dXJuIGB0cnVlYCBmb3IgRmlyZWZveCA0IE11bHRpdG91Y2ggc3VwcG9ydC5cbiovXG5cbiAgLy8gQ2hyb21lIChkZXNrdG9wKSB1c2VkIHRvIGxpZSBhYm91dCBpdHMgc3VwcG9ydCBvbiB0aGlzLCBidXQgdGhhdCBoYXMgc2luY2UgYmVlbiByZWN0aWZpZWQ6IGh0dHA6Ly9jcmJ1Zy5jb20vMzY0MTVcbiAgTW9kZXJuaXpyLmFkZFRlc3QoJ3RvdWNoZXZlbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvb2w7XG4gICAgaWYgKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCkge1xuICAgICAgYm9vbCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluY2x1ZGUgdGhlICdoZWFydHonIGFzIGEgd2F5IHRvIGhhdmUgYSBub24gbWF0Y2hpbmcgTVEgdG8gaGVscCB0ZXJtaW5hdGUgdGhlIGpvaW5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0LmlvL3Z6bkZIXG4gICAgICB2YXIgcXVlcnkgPSBbJ0BtZWRpYSAoJywgcHJlZml4ZXMuam9pbigndG91Y2gtZW5hYmxlZCksKCcpLCAnaGVhcnR6JywgJyknLCAneyNtb2Rlcm5penJ7dG9wOjlweDtwb3NpdGlvbjphYnNvbHV0ZX19J10uam9pbignJyk7XG4gICAgICB0ZXN0U3R5bGVzKHF1ZXJ5LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGJvb2wgPSBub2RlLm9mZnNldFRvcCA9PT0gOTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYm9vbDtcbiAgfSk7XG5cblxuICAvLyBSdW4gZWFjaCB0ZXN0XG4gIHRlc3RSdW5uZXIoKTtcblxuICAvLyBSZW1vdmUgdGhlIFwibm8tanNcIiBjbGFzcyBpZiBpdCBleGlzdHNcbiAgc2V0Q2xhc3NlcyhjbGFzc2VzKTtcblxuICBkZWxldGUgTW9kZXJuaXpyUHJvdG8uYWRkVGVzdDtcbiAgZGVsZXRlIE1vZGVybml6clByb3RvLmFkZEFzeW5jVGVzdDtcblxuICAvLyBSdW4gdGhlIHRoaW5ncyB0aGF0IGFyZSBzdXBwb3NlZCB0byBydW4gYWZ0ZXIgdGhlIHRlc3RzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTW9kZXJuaXpyLl9xLmxlbmd0aDsgaSsrKSB7XG4gICAgTW9kZXJuaXpyLl9xW2ldKCk7XG4gIH1cblxuICAvLyBMZWFrIE1vZGVybml6ciBuYW1lc3BhY2VcbiAgd2luZG93Lk1vZGVybml6ciA9IE1vZGVybml6cjtcblxuXG47XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQpOyIsInRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRPcHRpb25zXCIsIHtcbiAgICBnZXQ6IChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmNoZWNrZWRcIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwXG4gICAgICAgICAgICAgID8gW3RoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYSA9IFtdOyBpIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tpXS5zZWxlY3RlZCkgYS5wdXNoKHRoaXMub3B0aW9uc1tpXSk7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSkoKVxuICB9KTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWdub3JlIGVycm9ycyB3aXRoIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBTYWZhcmlcbiAgLy8gYXMgZGV0ZWN0aW9uIHdpdGggT2JqZWN0LmlzRXh0ZW5zaWJsZSgpIGlzIG5vdCByZWxpYWJsZS5cbn1cbiIsImltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi9Eb21GdW5jdGlvbnNcIlxuXG4vKiBnbG9iYWwgaHRtbEV2ZW50czp0cnVlICovXG5cbi8qKlxuICogQSB3cmFwcGVyIGNsYXNzIGZvciBET00gRWxlbWVudHMuXG4gKi9cbmNsYXNzIERvbUVsZW1lbnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSAtIFRoZSBlbGVtZW50IHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBET00gZWxlbWVudCB0byBjcmVhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIENTUyBjbGFzcyB0byB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICBhZGRDbGFzcyhuYW1lKSB7XG4gICAgRG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIGNsYXNzIG5hbWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtEb21FbGVtZW50fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBmbHVlbnQgY2hhaW5pbmcgb2YgY2FsbHMuXG4gICAqL1xuICByZW1vdmVDbGFzcyhuYW1lKSB7XG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaGFzQ2xhc3MobmFtZSkge1xuICAgIHJldHVybiBEb20uaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKVxuICB9XG5cbiAgdG9nZ2xlQ2xhc3MobmFtZSkge1xuICAgIERvbS50b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBjbGFzc2VzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0XG4gIH1cblxuICBzZXRJZCAoaWQpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBpbm5lclRleHQoKSB7XG4gICAgcmV0dXJuIERvbS50ZXh0KHRoaXMuZWxlbWVudClcbiAgfVxuXG4gIGdldCBpbm5lckh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbm5lckhUTUxcbiAgfVxuXG4gIHNldEh0bWwgKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgSFRNTCBzdHJpbmdcIilcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gdmFsdWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKVxuICB9XG5cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50KVxuICB9XG5cbiAgYXBwZW5kQ2hpbGQobmV3Q2hpbGQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChuZXdDaGlsZC5lbGVtZW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcmVwZW5kQ2hpbGQobmV3Q2hpbGQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUobmV3Q2hpbGQuZWxlbWVudCwgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGluc2VydEJlZm9yZShuZXdDaGlsZCkge1xuICAgIGlmICghKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb3RoZXIgRG9tRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLmVsZW1lbnQsIHRoaXMuZWxlbWVudClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIobmV3Q2hpbGQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZC5lbGVtZW50LCB0aGlzLmVsZW1lbnQubmV4dFNpYmxpbmcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlbW92ZUNoaWxkKG9sZENoaWxkKSB7XG4gICAgaWYgKCEob2xkQ2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBhIERvbUVsZW1lbnRzIGNoaWxkIGNhbiBiZSByZW1vdmVkXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKG9sZENoaWxkLmVsZW1lbnQpXG4gIH1cblxuICBmaW5kKHNlbGVjdG9ycykge1xuICAgIGxldCBlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKVxuICAgIGlmIChlKSB7XG4gICAgICByZXR1cm4gbmV3IERvbUVsZW1lbnQoZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB3cmFwV2l0aEVsZW1lbnQod3JhcHBlckVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlckVsZW1lbnQuZWxlbWVudCwgdGhpcy5lbGVtZW50KVxuICAgIHdyYXBwZXJFbGVtZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgbGV0IGV2ZW50XG4gICAgbGV0IGVsID0gdGhpcy5lbGVtZW50XG5cbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpXG4gICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHsgLy8gSUUgPCA5XG4gICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KClcbiAgICAgIGV2ZW50LmV2ZW50VHlwZSA9IGV2ZW50TmFtZVxuICAgIH1cbiAgICBldmVudC5ldmVudE5hbWUgPSBldmVudE5hbWVcbiAgICBpZiAoZWwuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICB9IGVsc2UgaWYgKGVsLmZpcmVFdmVudCAmJiBodG1sRXZlbnRzW2BvbiR7ZXZlbnROYW1lfWBdKSB7IC8vIElFIDwgOVxuICAgICAgZWwuZmlyZUV2ZW50KGBvbiR7ZXZlbnQuZXZlbnRUeXBlfWAsIGV2ZW50KSAvLyBjYW4gdHJpZ2dlciBvbmx5IHJlYWwgZXZlbnQgKGUuZy4gJ2NsaWNrJylcbiAgICB9IGVsc2UgaWYgKGVsW2V2ZW50TmFtZV0pIHtcbiAgICAgIGVsW2V2ZW50TmFtZV0oKVxuICAgIH0gZWxzZSBpZiAoZWxbYG9uJHtldmVudE5hbWV9YF0pIHtcbiAgICAgIGVsW2BvbiR7ZXZlbnROYW1lfWBdKClcbiAgICB9XG4gIH1cblxuICBjc3MocHJvcGVydHkpIHtcbiAgICByZXR1cm4gRG9tLmNzcyh0aGlzLmVsZW1lbnQsIHByb3BlcnR5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkIG5vZGVzIG9mIHRoZSBjdXJyZW50IERvbUVsZW1lbnQuXG4gICAqL1xuICBlbXB0eSgpIHtcbiAgICB3aGlsZSAodGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRG9tRWxlbWVudFxuIiwiXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUobmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKG5hbWUpXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBoaWRkZW4gZnJvbSB2aWV3LlxuICogQHBhcmFtIHtFbGVtZW50fSBFbGVtZW50IFRoZSBkb20gZWxlbWVudCB0byBjaGVjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVBhcmVudHMgSWYgc2V0IHRvIGB0cnVlYCBzZWFyY2hlcyB1cCB0aGUgRE9NIGFuZCBjaGVja3MgcGFyZW50IHZpc2liaWxpdHkgYXMgd2VsbC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGlkZGVuKGVsZW1lbnQsIGluY2x1ZGVQYXJlbnRzID0gZmFsc2UpIHtcbiAgaWYgKGluY2x1ZGVQYXJlbnRzID09PSBmYWxzZSkge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClcbiAgICByZXR1cm4gKHN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB8fCBlbGVtZW50Lm9mZnNldExlZnQgPCAwXG4gIH1cblxuICBsZXQgcmVzdWx0XG4gIHdoaWxlICgocmVzdWx0ID0gaXNIaWRkZW4oZWxlbWVudCwgZmFsc2UpKSA9PT0gZmFsc2UgJiYgZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYW4gZWxlbWVudCBhbiBtYWtlcyBzdXJlIHRoaXMgd29ya3Mgb24gYWxsIGJyb3dzZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRleHRDb250ZW50IHx8IGVsZW1lbnQuaW5uZXJUZXh0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJlbnRXaXRoQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGxldCBjdXJyZW50ID0gZWxlbWVudFxuXG4gIHdoaWxlICghaGFzQ2xhc3MoY3VycmVudCwgY2xhc3NOYW1lKSAmJiBjdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50XG4gIH1cblxuICBpZiAoaGFzQ2xhc3MoY3VycmVudCwgY2xhc3NOYW1lKSkge1xuICAgIHJldHVybiBjdXJyZW50XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dCwgZm9udCkge1xuICAvLyBOT1RFOiB0aGlzIHdpZHRoIG1lYXN1cmluZyBhbGdvcml0aG0gaXMgYSBsb3QgZmFzdGVyXG4gIC8vIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgbm90IHdvcmsgb24gSUUgMTAuLi5cblxuICAvLyBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICAvLyBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgLy8gY29udGV4dC5mb250ID0gZm9udFxuICAvLyBsZXQgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dClcbiAgLy8gcmV0dXJuIE1hdGgucm91bmQobWV0cmljcy53aWR0aClcblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBkaXYuaW5uZXJIVE1MID0gdGV4dFxuXG4gIGRpdi5zdHlsZS5mb250ID0gZm9udFxuICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgZGl2LnN0eWxlLmxlZnQgPSAtMTAwMDBcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gLTEwMDAwXG4gIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIlxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KVxuXG4gIGNvbnN0IHJlc3VsdCA9IGRpdi5vZmZzZXRXaWR0aFxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdilcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3MoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2luZ2xlIGVsZW1lbnQgcmVmZXJlbmNlZCBpbiBhbiBpdGVtcyBkYXRhLSogYXR0cmlidXRlLlxuICogQHBhcmFtIHtEb21FbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgcmVmZXJlbmNlIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtEb21FbGVtZW50fSBUaGUgcmVmZXJlbmNlZCBlbGVtZW50OyBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcmVmZXJlbmNlIGlzIGludmFsaWRcbiAqIG9yIHRoZSBhdHRyaWJ1dGUgY291bGQgbm90IGJlIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlUmVmZXJlbmNlKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICBjb25zdCBhdHRyVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG5cbiAgaWYgKCFhdHRyVmFsdWUgfHwgYXR0clZhbHVlID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXR0clZhbHVlKVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGRvY3VtZW50IHJvb3QgZWxlbWVudCAobm9ybWFsbHkgdGhlIGJvZHkgZWxlbWVudClcbiAqIElmIHRoZSBkb2N1bWVudCB1c2VzIGEgc2R4LWNvbnRhaW5lciB3cmFwcGVyIHRoaXMgaXMgcmV0dXJuZWQgaW5zdGVhZC5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBUaGUgcm9vdCBkb20gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3RFbGVtZW50KCkge1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc2R4LWNvbnRhaW5lclwiKVxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBjaGlsZCBub2RlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBEb20gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpXG4gIH1cbn1cbiIsIi8qIEtleWJvYXJkIGlucHV0IGtleWNvZGUgZGVmaW5pdGlvbnMgKi9cblxuZXhwb3J0IGNvbnN0IEtFWV9FTlRFUiA9IDEzXG5leHBvcnQgY29uc3QgS0VZX0VTQ0FQRSA9IDI3XG5cbi8vIEFycm93IGtleXNcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfVVAgPSAzOFxuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19ET1dOID0gNDBcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfTEVGVCA9IDM3XG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX1JJR0hUID0gMzlcblxuLy8gUGFnZSBrZXlzXG5leHBvcnQgY29uc3QgS0VZX1BBR0VfVVAgPSAzM1xuZXhwb3J0IGNvbnN0IEtFWV9QQUdFX0RPV04gPSAzNFxuXG4vLyBOdW1iZXJzXG5leHBvcnQgY29uc3QgS0VZX05SXzAgPSA0OFxuZXhwb3J0IGNvbnN0IEtFWV9OUl8xID0gNDlcbmV4cG9ydCBjb25zdCBLRVlfTlJfOSA9IDU3XG4iLCIvKipcbiAqIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjb21wbGV0ZWx5IHBhcnNlZC5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IHZhbHVlIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25Eb2N1bWVudFJlYWR5KGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKVxuICB9IGVsc2Uge1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSlcblxuICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hFbGVtZW50KHNlbGVjdG9ycywgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjYWxsYmFjayBjYW5ub3QgYmUgdW5kZWZpbmVkXCIpXG4gIH1cblxuICBsZXQgZWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSlcblxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgY2FsbGJhY2soZSlcbiAgfVxufVxuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbiBpZiB0aGUgYGRhdGEtaW5pdGAgYXR0cmlidXRlIGlzIHByZXNlbnQgb24gdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3NlbGVjdG9yfSB2YWx1ZSBUaGUgcXVlcnkuXG4gKiBAcGFyYW0ge2NhbGxiYWNrfSB2YWx1ZSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGluaXRTZWxlY3RvciBUaGUgaW5pdGl0YWxpemF0aW9uIGVsZW1lbnQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbmRJbml0aWFsaXplKHNlbGVjdG9yLCBjYWxsYmFjaywgaW5pdFNlbGVjdG9yID0gdW5kZWZpbmVkKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2FsbGJhY2sgY2Fubm90IGJlIHVuZGVmaW5lZFwiKVxuICB9XG5cbiAgbGV0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG5cbiAgICBsZXQgaW5pdEVsZW1lbnQgPSBlXG5cbiAgICBpZiAoaW5pdFNlbGVjdG9yKSB7XG4gICAgICBpbml0RWxlbWVudCA9IGluaXRTZWxlY3RvcihlKVxuICAgIH1cblxuICAgIGlmIChpbml0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBjYWxsYmFjayhlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgd2hvc2UgdmFsdWUgaXMgbGltaXRlZCB0byB0aGUgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogRXhhbXBsZTogbGltaXQgdGhlIG91dHB1dCBvZiB0aGlzIGNvbXB1dGF0aW9uIHRvIGJldHdlZW4gMCBhbmQgMjU1XG4gKiBVdGlscy5jbGFtcChudW1iZXIsIDAsIDI1NSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIG91dHB1dCByYW5nZVxuICogQHJldHVybnMgQSBudW1iZXIgaW4gdGhlIHJhbmdlIFttaW4sIG1heF1cbiAqIEB0eXBlIE51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KVxufVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIEV2ZW50LnByZXZlbnREZWZhdWx0KCkuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfSBlbHNlIHtcbiAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBOb2RlLnJlbW92ZSgpLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxufVxuXG4vKipcbiAqIEEgc2ltcGxlIHBvbHlmaWxsIGZvciB0aGUgQXJyYXkuZmluZCgpIG1ldGhvZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV4cHJlc3Npb24gLSBUaGUgZXhwcmVzc3Rpb24gdG8gZXZhbHVhdGUuIE11c3QgcmV0dXJuIHRydWUgaWYgdGhlIGVsZW1lbnQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmQoYXJyYXksIGV4cHJlc3Npb24pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBpdGVtID0gYXJyYXlbaV1cbiAgICBpZiAoZXhwcmVzc2lvbihpdGVtKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSB1c2VyYWdlbnQgYW5kIHJldHVybnMgdGhlIE1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlciAvIEVkZ2UgdmVyc2lvbi5cbiAqIElmIGFub3RoZXIgYnJvd3NlciBpcyBkZXRlY3RlZCAwIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNJRVZlcnNpb24odXNlckFnZW50ID0gdW5kZWZpbmVkKSB7XG4gIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5OTk5Mzg4L2NoZWNrLWlmLXVzZXItaXMtdXNpbmctaWUtd2l0aC1qcXVlcnlcbiAgY29uc3QgdWEgPSB1c2VyQWdlbnQgfHwgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcblxuICBjb25zdCBtc2llID0gdWEuaW5kZXhPZihcIk1TSUUgXCIpXG4gIGlmIChtc2llID4gMCkge1xuICAgIC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoXCIuXCIsIG1zaWUpKSwgMTApXG4gIH1cblxuICBjb25zdCB0cmlkZW50ID0gdWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpXG4gIGlmICh0cmlkZW50ID4gMCkge1xuICAgIC8vIElFIDExID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgIGNvbnN0IHJ2ID0gdWEuaW5kZXhPZihcInJ2OlwiKVxuICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcocnYgKyAzLCB1YS5pbmRleE9mKFwiLlwiLCBydikpLCAxMClcbiAgfVxuXG4gIGNvbnN0IGVkZ2UgPSB1YS5pbmRleE9mKFwiRWRnZS9cIilcbiAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgLy8gRWRnZSAoSUUgMTIrKSA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKGVkZ2UgKyA1LCB1YS5pbmRleE9mKFwiLlwiLCBlZGdlKSksIDEwKVxuICB9XG5cbiAgLy8gb3RoZXIgYnJvd3NlclxuICByZXR1cm4gMFxufVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBUd2VlbkxpdGUsIFBvd2VyMSwgUG93ZXI0IH0gZnJvbSBcImdzYXBcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgRG9tIGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9UT0dHTEUgPSBcIi5hY2NvcmRpb25fX3RvZ2dsZVwiXG5jb25zdCBRVUVSWV9PUEVOX1NFQ1RJT04gPSBcIi5hY2NvcmRpb25fX2l0ZW0uaXMtb3BlblwiXG5jb25zdCBRVUVSWV9DT0xMQVBTRSA9IFwiLmFjY29yZGlvbl9fY29sbGFwc2VcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJhY2NvcmRpb25fX2l0ZW1cIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5cbmNvbnN0IFJFR0VYX0hJRERFTiA9IC9hY2NvcmRpb24tLWhpZGRlbi0uKi9cblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAwLjNcblxuY29uc3QgQU5JTUFUSU9OX0RFTEFZX09QRU4gPSAwLjJcbmNvbnN0IEFOSU1BVElPTl9WSVNJQkxFX09QRU4gPSAwLjVcblxuY29uc3QgQU5JTUFUSU9OX1ZJU0lCTEVfQ0xPU0UgPSAwLjFcblxuLyoqXG4gKiBUaGUgQWNjb3JkaW9uIGNvbXBvbmVudFxuICovXG5jbGFzcyBBY2NvcmRpb24gZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIEFjY29yZGlvbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBBY2NvcmRpb24gY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9zZWN0aW9uQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlU2VjdGlvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQWNjb3JkaW9uIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5zb21lKChjKSA9PiBSRUdFWF9ISURERU4udGVzdChjKSkpIHtcbiAgICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImlucHV0XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImpzLWhpZGRlblwiKVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGluZGljYXRvci5lbGVtZW50XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdG9nZ2xlIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX1RPR0dMRSkpIHtcbiAgICAgIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fc2VjdGlvbkNsaWNrSGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlU2VjdGlvbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvcikge1xuICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5faGlkZGVuSW5kaWNhdG9yLCBudWxsKVxuXG4gICAgICBpZiAoc3R5bGUudmlzaWJpbGl0eSAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5hdlNlY3Rpb24gPSBldmVudC50YXJnZXQucGFyZW50RWxlbWVudFxuXG4gICAgd2hpbGUgKCFEb20uaGFzQ2xhc3MobmF2U2VjdGlvbiwgQ0xBU1NfSVRFTSkgJiYgbmF2U2VjdGlvbi5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBuYXZTZWN0aW9uID0gbmF2U2VjdGlvbi5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgbGV0IHByZXZTZWN0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfT1BFTl9TRUNUSU9OKVxuXG4gICAgaWYgKHByZXZTZWN0aW9uICYmIHByZXZTZWN0aW9uICE9PSBuYXZTZWN0aW9uKSB7XG4gICAgICB0aGlzLl90b2dnbGVTZWN0aW9uKHByZXZTZWN0aW9uKVxuICAgIH1cblxuICAgIHRoaXMuX3RvZ2dsZVNlY3Rpb24obmF2U2VjdGlvbilcbiAgfVxuXG4gIF90b2dnbGVTZWN0aW9uKGFjY1NlY3Rpb24pIHtcbiAgICBsZXQgY29sbGFwc2VFbGVtZW50ID0gYWNjU2VjdGlvbi5xdWVyeVNlbGVjdG9yKFFVRVJZX0NPTExBUFNFKVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKSkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKGFjY1NlY3Rpb24sIENMQVNTX09QRU4pXG4gICAgICB0aGlzLl9jbG9zZUNvbGxhcHNlU2VjdGlvbihjb2xsYXBzZUVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5hZGRDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fb3BlbkNvbGxhcHNlU2VjdGlvbihjb2xsYXBzZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgX29wZW5Db2xsYXBzZVNlY3Rpb24oZWwpIHtcbiAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKGVsKVxuXG4gICAgVHdlZW5MaXRlLnNldChlbCwge1xuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSlcblxuICAgIFR3ZWVuTGl0ZS50byhlbCwgQU5JTUFUSU9OX09QRU4sIHtcbiAgICAgIGNsYXNzTmFtZTogYCs9JHtDTEFTU19PUEVOfWAsXG4gICAgICBlYXNlOiBbXG4gICAgICAgIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0XG4gICAgICBdXG4gICAgfSlcblxuICAgIFR3ZWVuTGl0ZS50byhlbCwgQU5JTUFUSU9OX1ZJU0lCTEVfT1BFTiwge1xuICAgICAgYXV0b0FscGhhOiAxLFxuICAgICAgZGVsYXk6IEFOSU1BVElPTl9ERUxBWV9PUEVOXG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKVxuICB9XG5cbiAgX2Nsb3NlQ29sbGFwc2VTZWN0aW9uKGVsKSB7XG4gICAgVHdlZW5MaXRlLmtpbGxUd2VlbnNPZihlbClcblxuICAgIFR3ZWVuTGl0ZS50byhlbCwgQU5JTUFUSU9OX1ZJU0lCTEVfQ0xPU0UsIHtcbiAgICAgIGF1dG9BbHBoYTogMFxuICAgIH0pXG5cbiAgICBUd2VlbkxpdGUudG8oZWwsIEFOSU1BVElPTl9PUEVOLCB7XG4gICAgICBjbGFzc05hbWU6IGAtPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgZWFzZTogW1xuICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgXSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgVHdlZW5MaXRlLnNldChlbCwge1xuICAgICAgICAgIGNsZWFyUHJvcHM6IFwiZGlzcGxheSwgdmlzaWJpbGl0eSwgb3BhY2l0eVwiXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IHRvZ2dsZSBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9UT0dHTEUpKSB7XG4gICAgICB0b2dnbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fc2VjdGlvbkNsaWNrSGFuZGxlciA9IG51bGxcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuYWNjb3JkaW9uXCIsIChlKSA9PiB7XG4gICAgbmV3IEFjY29yZGlvbihlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb25cbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wLCBwcmV2ZW50RGVmYXVsdCwgcmVtb3ZlIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfU0xJREVSID0gXCIuY2Fyb3VzZWxfX2NvbnRhaW5lclwiXG5jb25zdCBRVUVSWV9TTElERV9BUkVBID0gXCIuY2Fyb3VzZWxfX3NsaWRlclwiXG5jb25zdCBRVUVSWV9XUkFQUEVSID0gXCIuY2Fyb3VzZWxfX3NsaWRlci13cmFwcGVyXCJcblxuY29uc3QgUVVFUllfUEFHSU5BVElPTiA9IFwiLmNhcm91c2VsX19wYWdpbmF0aW9uXCJcblxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJzbGlkZS0tYWN0aXZlXCJcbmNvbnN0IENMQVNTX1BSRVYgPSBcInNsaWRlLS1wcmV2XCJcbmNvbnN0IENMQVNTX05FWFQgPSBcInNsaWRlLS1uZXh0XCJcblxuY29uc3QgQ0xBU1NfQlVMTEVUID0gXCJwYWdpbmF0aW9uLWJ1bGxldFwiXG5jb25zdCBDTEFTU19CVUxMRVRfQUNUSVZFID0gXCJwYWdpbmF0aW9uLWJ1bGxldC0tYWN0aXZlXCJcblxuY29uc3QgUVVFUllfQlROX1BSRVYgPSBcIi5jYXJvdXNlbF9fYnV0dG9uLXByZXZcIlxuY29uc3QgUVVFUllfQlROX05FWFQgPSBcIi5jYXJvdXNlbF9fYnV0dG9uLW5leHRcIlxuY29uc3QgUVVFUllfQlROX1dSQVBQRVIgPSBcIi5jYXJvdXNlbF9fYnV0dG9uLXdyYXBwZXJcIlxuXG5jb25zdCBBVFRSSUJVVEVfSU5ERVggPSBcImpzLWluZGV4XCJcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gMzUwXG5jb25zdCBBTklNQVRJT05fRUFTSU5HID0gXCJlYXNlLWluLW91dFwiXG5cbmNvbnN0IFRPVUNIX0RVUkFUSU9OID0gMzAwXG5jb25zdCBUT1VDSF9ERUxUQV9NSU4gPSAyNVxuXG4vKipcbiAqIFRoZSBjYXJvdXNlbCBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSBlbGVtZW50IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgQ2Fyb3VzZWwgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge2luZGV4fSAtIFRoZSBpbml0aWFsIGluZGV4LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgaW5kZXggPSAwKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2JyZWFrcG9pbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zbGlkZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TTElERVIpXG4gICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1dSQVBQRVIpXG4gICAgdGhpcy5fcGFnaW5hdGlvbiA9IHRoaXMuX3NsaWRlci5xdWVyeVNlbGVjdG9yKFFVRVJZX1BBR0lOQVRJT04pXG4gICAgdGhpcy5fc2xpZGVBcmVhID0gdGhpcy5fc2xpZGVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0xJREVfQVJFQSlcblxuICAgIHRoaXMuX2J0bldyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9CVE5fV1JBUFBFUilcbiAgICB0aGlzLl9wcmV2Q3RybCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0JUTl9QUkVWKVxuICAgIHRoaXMuX25leHRDdHJsID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX05FWFQpXG5cbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TTElERVIpXG4gICAgdGhpcy5fc2xpZGVzID0gW11cblxuICAgIHRoaXMuX2luZGV4ID0gaW5kZXggfHwgMFxuICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gMVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlciA9IG5ldyBTbGlkZXJXcmFwcGVyKHRoaXMuX3dyYXBwZXIsIHRoaXMuX3NsaWRlQXJlYSwgdGhpcy5lbGVtZW50KVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuX2luZGV4ID0gdGhpcy5faW5kZXhcbiAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5fb25yZXNpemUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ByZXZIYW5kbGVyID0gdGhpcy5wcmV2LmJpbmQodGhpcylcbiAgICB0aGlzLl9uZXh0SGFuZGxlciA9IHRoaXMubmV4dC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVBhZ2luYXRpb25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQgPSB0aGlzLl9vblRvdWNoc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuX2hhbmRsZVRvdWNobW92ZSA9IHRoaXMuX29uVG91Y2htb3ZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVUb3VjaGVuZCA9IHRoaXMuX29uVG91Y2hlbmQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gICAgdGhpcy5zbGlkZSh0aGlzLl9pbmRleCwgMCwgZmFsc2UpXG5cbiAgICB0aGlzLl91cGRhdGVDdHJsT2Zmc2V0cygpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIHJlc3BvbnNpdmUgaGVscGVyc1xuICAgIHRoaXMuX2JyZWFrcG9pbnRQaG9uZSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJqcy1waG9uZVwiKVxuICAgICAgLmVsZW1lbnRcblxuICAgIHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtdGFibGV0XCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5fYnJlYWtwb2ludERlc2t0b3AgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwianMtZGVza3RvcFwiKVxuICAgICAgLmVsZW1lbnRcblxuICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9icmVha3BvaW50UGhvbmUpXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQpXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wKVxuXG4gICAgaWYgKHRoaXMuX3ByZXZDdHJsICYmIHRoaXMuX25leHRDdHJsKSB7XG4gICAgICB0aGlzLl9wcmV2Q3RybC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldkhhbmRsZXIpXG4gICAgICB0aGlzLl9uZXh0Q3RybC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbmV4dEhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMuX3BhZ2luYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3BhZ2luYXRpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGVzID0gQXJyYXkuZnJvbSh0aGlzLl93cmFwcGVyLmNoaWxkcmVuKVxuICAgIGlmICh0aGlzLl9zbGlkZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlByb3ZpZGUgYXQgbGVhc3Qgb25lIHNsaWRlIHRvIHRoZSBzbGlkZXJcIilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsaWRlID0gdGhpcy5fc2xpZGVzW2ldXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYLCBpKVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKClcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmluaXRpYWxpemUoKVxuXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9zbGlkZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gIH1cblxuICBfaXNCcmVha3BvaW50QWN0aXZlKGJyZWFrcG9pbnQpIHtcbiAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShicmVha3BvaW50LCBudWxsKVxuICAgIHJldHVybiBzdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIlxuICB9XG5cbiAgX29ucmVzaXplKCkge1xuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuX3VwZGF0ZUN0cmxPZmZzZXRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoZSBpbmRleCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIG9mIGF2YWlsYWJsZSBzbGlkZVxuICAgKiBJbiBjYXNlIGl0J3MgdG8gaGlnaCBvciB0byBsb3cgaXQgaXMgd3JhcHBlZCBhcm91bmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGFkanVzdCBhbmQgc2FuaXRpemVcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGFkanVzdGVkIGluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRqdXN0SW5kZXgoaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRleCA9IDBcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuX3NsaWRlcy5sZW5ndGgpIHtcbiAgICAgIGluZGV4ICU9IHRoaXMuX3NsaWRlcy5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKSAqIHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gIH1cblxuICBfd3JhcHJvdW5kKG4sIG1pbiwgbWF4KSB7XG4gICAgaWYgKG4gPj0gbWF4KSB7XG4gICAgICByZXR1cm4gbWluXG4gICAgfVxuXG4gICAgaWYgKG4gPCBtaW4pIHtcbiAgICAgIHJldHVybiBtYXggLSAxXG4gICAgfVxuXG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIF93cmFwcm91bmRDb3VudChhLCBiLCBtaW4sIG1heCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBpZiAoYSA8IG1pbiB8fCBhID49IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnYScgaXMgb3V0IG9mIHJhbmdlLCBWYWx1ZTogJHthfSBNaW46ICR7bWlufSwgTWF4OiAke21heH1gKVxuICAgIH1cblxuICAgIGlmIChiIDwgbWluIHx8IGIgPj0gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICdiJyBpcyBvdXQgb2YgcmFuZ2UsIFZhbHVlOiAke2J9IE1pbjogJHttaW59LCBNYXg6ICR7bWF4fWApXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgd2hpbGUgKGEgIT09IGIpIHtcbiAgICAgIGkrK1xuICAgICAgYSA9IHRoaXMuX3dyYXByb3VuZChhICsgZGlyZWN0aW9uLCBtaW4sIG1heClcbiAgICB9XG5cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgX3VwZGF0ZUN0cmxPZmZzZXRzKCkge1xuICAgIGlmICghdGhpcy5fbmV4dEN0cmwgfHwgIXRoaXMuX3ByZXZDdHJsIHx8ICF0aGlzLl9idG5XcmFwcGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcHJldkN0cmxNYXJnaW4gPSAwXG4gICAgbGV0IG5leHRDdHJsTWFyZ2luID0gMFxuXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgbGV0IHdyYXBwZXJSZWN0ID0gdGhpcy5fYnRuV3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICBjb25zdCBwcmV2U2xpZGVDb3VudCA9IE1hdGguZmxvb3IoMC41ICogdGhpcy5fc2xpZGVzUGVyR3JvdXApXG4gICAgICBjb25zdCByaWdodEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleCArIHByZXZTbGlkZUNvdW50ICsgMVxuXG4gICAgICBsZXQgbGVmdEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleCAtIDFcbiAgICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCAlIDIgIT09IDApIHtcbiAgICAgICAgbGVmdEluZGV4IC09IHByZXZTbGlkZUNvdW50XG4gICAgICB9XG5cbiAgICAgIGlmICgobGVmdEluZGV4ID49IDAgJiYgbGVmdEluZGV4IDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpICYmXG4gICAgICAgICAgKHJpZ2h0SW5kZXggPj0gMCAmJiByaWdodEluZGV4IDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIGxldCBsZWZ0U2xpZGUgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyhsZWZ0SW5kZXgpXG4gICAgICAgIGxldCByaWdodFNsaWRlID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMocmlnaHRJbmRleClcblxuICAgICAgICBsZXQgYnRuV2lkdGggPSB0aGlzLl9wcmV2Q3RybC5vZmZzZXRXaWR0aFxuICAgICAgICBpZiAoYnRuV2lkdGggPD0gMCkge1xuICAgICAgICAgIGJ0bldpZHRoID0gNjBcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZDdHJsTWFyZ2luID0gbGVmdFNsaWRlLnJpZ2h0IC0gd3JhcHBlclJlY3QubGVmdCAtIGJ0bldpZHRoXG4gICAgICAgIG5leHRDdHJsTWFyZ2luID0gd3JhcHBlclJlY3QucmlnaHQgLSByaWdodFNsaWRlLmxlZnQgLSBidG5XaWR0aFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBsZWZ0ID0gcHJldkN0cmxNYXJnaW4gIT09IDAgPyBgJHtwcmV2Q3RybE1hcmdpbn1weGAgOiBcIlwiXG4gICAgdGhpcy5fcHJldkN0cmwuc3R5bGUubGVmdCA9IGxlZnRcblxuICAgIGxldCByaWdodCA9IG5leHRDdHJsTWFyZ2luICE9PSAwID8gYCR7bmV4dEN0cmxNYXJnaW59cHhgIDogXCJcIlxuICAgIHRoaXMuX25leHRDdHJsLnN0eWxlLnJpZ2h0ID0gcmlnaHRcbiAgfVxuXG4gIF91cGRhdGVBY3RpdmVTbGlkZXMobmV4dEluZGV4KSB7XG4gICAgY29uc3QgcHJldlNsaWRlQ291bnQgPSBNYXRoLmZsb29yKDAuNSAqICh0aGlzLl9zbGlkZXNQZXJHcm91cCAtIDEpKVxuICAgIGNvbnN0IGV2ZW5Hcm91cCA9IHRoaXMuX3NsaWRlc1Blckdyb3VwICUgMiA9PT0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChpID09PSBuZXh0SW5kZXggfHwgKGV2ZW5Hcm91cCAmJiBpID09PSBuZXh0SW5kZXggKyAxKSkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX0FDVElWRSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhzbGlkZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IG5leHRJbmRleCAmJiAgaSA+PSBuZXh0SW5kZXggLSBwcmV2U2xpZGVDb3VudCkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX1BSRVYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3Moc2xpZGUsIENMQVNTX1BSRVYpXG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gbmV4dEluZGV4ICYmIChpIDw9IG5leHRJbmRleCArIHByZXZTbGlkZUNvdW50IHx8IChldmVuR3JvdXAgJiYgaSA8PSBuZXh0SW5kZXggKyAxICsgcHJldlNsaWRlQ291bnQpKSkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX05FWFQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3Moc2xpZGUsIENMQVNTX05FWFQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW5kIGNyZWF0ZXMgdGhlIHBhZ2luYXRpb24gYnVsbGV0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVQYWdpbmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRvID0gdGhpcy5faW5kZXhcblxuICAgIGxldCBidWxsZXRzID0gdGhpcy5fcGFnaW5hdGlvbi5jaGlsZHJlblxuICAgIGxldCB0b3RhbEl0ZW1zID0gTWF0aC5tYXgodGhpcy5fc2xpZGVzLmxlbmd0aCwgYnVsbGV0cy5sZW5ndGgpXG4gICAgbGV0IHNsaWRlQ291bnQgPSBNYXRoLmNlaWwodGhpcy5fc2xpZGVzLmxlbmd0aCAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuICAgIGxldCBhY3RpdmVTbGlkZUluZGV4ID0gTWF0aC5mbG9vcih0byAvIHRoaXMuX3NsaWRlc1Blckdyb3VwKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEl0ZW1zOyBpKyspIHtcbiAgICAgIGxldCBidWxsZXRcblxuICAgICAgaWYgKGJ1bGxldHMubGVuZ3RoID4gaSkge1xuICAgICAgICBpZiAoYnVsbGV0cy5sZW5ndGggPD0gc2xpZGVDb3VudCkge1xuICAgICAgICAgIGJ1bGxldCA9IGJ1bGxldHNbaV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmUoYnVsbGV0c1tpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpIDwgc2xpZGVDb3VudCkge1xuICAgICAgICBidWxsZXQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19CVUxMRVQpXG4gICAgICAgICAgLmVsZW1lbnRcbiAgICAgICAgdGhpcy5fcGFnaW5hdGlvbi5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgICB9XG5cbiAgICAgIGlmIChidWxsZXQgJiYgaSA8IHNsaWRlQ291bnQpIHtcbiAgICAgICAgaWYgKGkgPT09IGFjdGl2ZVNsaWRlSW5kZXgpIHtcbiAgICAgICAgICBEb20uYWRkQ2xhc3MoYnVsbGV0LCBDTEFTU19CVUxMRVRfQUNUSVZFKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERvbS5yZW1vdmVDbGFzcyhidWxsZXQsIENMQVNTX0JVTExFVF9BQ1RJVkUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaGFuZGxlUGFnaW5hdGlvbkNsaWNrKGUpIHtcbiAgICBpZiAoIURvbS5oYXNDbGFzcyhlLnRhcmdldCwgQ0xBU1NfQlVMTEVUKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLl9wYWdpbmF0aW9uLmNoaWxkcmVuKS5pbmRleE9mKGUudGFyZ2V0KVxuICAgIGxldCBzbGlkZU51bWJlciA9IGluZGV4ICogdGhpcy5fc2xpZGVzUGVyR3JvdXBcblxuICAgIHRoaXMuc2xpZGVUbyhzbGlkZU51bWJlcilcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgbGV0IGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIHN3aXRjaCAoa2V5Y29kZSkge1xuICAgICAgY2FzZSBJbnB1dHMuS0VZX0FSUk9XX0xFRlQ6XG4gICAgICAgIHRoaXMucHJldigpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIElucHV0cy5LRVlfQVJST1dfUklHSFQ6XG4gICAgICAgIHRoaXMubmV4dCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIElucHV0cy5LRVlfRVNDQVBFOlxuICAgICAgICB0aGlzLmVsZW1lbnQuYmx1cigpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoc3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudFxuXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5faGFuZGxlVG91Y2hzdGFydClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuYmVnaW5EcmFnKClcbiAgICBjb25zdCB7IHBhZ2VYIH0gPSB0b3VjaGVzXG5cbiAgICB0aGlzLl90b3VjaE9mZnNldCA9IHtcbiAgICAgIHg6IHBhZ2VYLFxuICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgIH1cblxuICAgIHRoaXMuX2RlbHRhID0ge1xuICAgICAgbGFzdE1vdmU6IHBhZ2VYXG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gIH1cblxuICBfb25Ub3VjaG1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCB0b3VjaGVzID0gZXZlbnQudG91Y2hlcyA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudFxuICAgIGNvbnN0IHsgcGFnZVggfSA9IHRvdWNoZXNcblxuICAgIGxldCBkZWx0YU1vdmUgPSBwYWdlWCAtIHRoaXMuX2RlbHRhLmxhc3RNb3ZlXG5cbiAgICB0aGlzLl9kZWx0YSA9IHtcbiAgICAgIHg6IHBhZ2VYIC0gdGhpcy5fdG91Y2hPZmZzZXQueCxcbiAgICAgIGxhc3RNb3ZlOiBwYWdlWFxuICAgIH1cblxuICAgIGlmICh0aGlzLl90b3VjaE9mZnNldCkge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZShkZWx0YU1vdmUpXG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSwgZGVsdGFNb3ZlKVxuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoZW5kKCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fdG91Y2hPZmZzZXQgPyBEYXRlLm5vdygpIC0gdGhpcy5fdG91Y2hPZmZzZXQudGltZSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgaXNWYWxpZCA9IE51bWJlcihkdXJhdGlvbikgPCBUT1VDSF9EVVJBVElPTiAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5fZGVsdGEueCkgPiBUT1VDSF9ERUxUQV9NSU4gfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuX2RlbHRhLngpID4gdGhpcy5fZnJhbWVXaWR0aCAvIDNcblxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBjbGFtcCh0aGlzLl9kZWx0YS54LCAtMSwgMSkgKiAtMVxuICAgICAgdGhpcy5zbGlkZShmYWxzZSwgZGlyZWN0aW9uLCB0cnVlKVxuXG4gICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmVuZERyYWcoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbGlkZSBiYWNrIHRvIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZyBvcGVyYXRpb25cbiAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuY2FuY2VsRHJhZygpXG4gICAgfVxuXG4gICAgdGhpcy5fdG91Y2hPZmZzZXQgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX2hhbmRsZVRvdWNobW92ZSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlZCBwYXJhbWV0ZXJzIGluIHJlZ2FyZCB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSByZXNwb25zaXZlXG4gICAqIGJyZWFrcG9pbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlUmVzcG9uc2l2ZU9wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX2lzQnJlYWtwb2ludEFjdGl2ZSh0aGlzLl9icmVha3BvaW50UGhvbmUpKSB7XG4gICAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDFcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCcmVha3BvaW50QWN0aXZlKHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQpKSB7XG4gICAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDJcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCcmVha3BvaW50QWN0aXZlKHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wKSkge1xuICAgICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAzXG4gICAgfVxuXG4gICAgdGhpcy5fZ3JvdXBTbGlkZXNFdmVuID0gdGhpcy5fc2xpZGVzUGVyR3JvdXAgJSAyID09PSAwXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5zbGlkZXNQZXJHcm91cCA9IHRoaXMuX3NsaWRlc1Blckdyb3VwXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSByZXF1ZXN0ZWQgc2xpZGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIG9yaWdpbmFsIHNsaWRlIGluZGV4IG9mIHRoZSB0ZW1wbGF0ZSBzbGlkZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0byBhZGQgdGhlIHNsaWRlcywgLTEgZm9yIGxlZnQsIDEgZm9yIHJpZ2h0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xvbmVTbGlkZShpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IGNsb25lID0gdGhpcy5fc2xpZGVzW2luZGV4XS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX0FDVElWRSlcbiAgICBEb20ucmVtb3ZlQ2xhc3MoY2xvbmUsIENMQVNTX1BSRVYpXG4gICAgRG9tLnJlbW92ZUNsYXNzKGNsb25lLCBDTEFTU19ORVhUKVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5hZGRTbGlkZShjbG9uZSwgZGlyZWN0aW9uKVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luTGVmdCA9IHNsaWRlTWFyZ2luXG4gICAgY2xvbmUuc3R5bGUubWFyZ2luUmlnaHQgPSBzbGlkZU1hcmdpblxuXG4gICAgcmV0dXJuIGNsb25lLm9mZnNldFdpZHRoXG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIGFuZCBhZGRzIHRoZSByZXF1ZXN0ZWQgYW1tb3VudCBvZiBzbGlkZXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlkZUNvdW50IC0gVGhlIG51bWJlciBvZiBzbGlkZXMgdG8gYWRkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIGFkZCB0aGUgc2xpZGVzLCAtMSBmb3IgbGVmdCwgMSBmb3IgcmlnaHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbG9uZVNsaWRlc0J5Q291bnQoc2xpZGVDb3VudCwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IG9yaWdpbmFsSW5kZXggPSBkaXJlY3Rpb24gPCAwID8gMCA6IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgIGxldCBpbmRleCA9IHBhcnNlSW50KHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5bb3JpZ2luYWxJbmRleF0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCksIDEwKVxuXG4gICAgd2hpbGUgKHNsaWRlQ291bnQgPiAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCArIGRpcmVjdGlvbiwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGUoaW5kZXgsIGRpcmVjdGlvbilcbiAgICAgIHNsaWRlQ291bnQtLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBzY3JvbGwgY2xvdW50IGFuZCBpbnNlcnRzIHRoZSByZXF1aXJlZCBhbW1vdW50IG9mIHNsaWRlc1xuICAgKiBpbiB0aGUgYXByb3ByaWF0ZSBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXh0SW5kZXggLSBUaGUgc2xpZGUgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzY3JvbGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbG9uZVNsaWRlc0J5U2Nyb2xsQ291bnQobmV4dEluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzY3JvbGxDb3VudCA9IHRoaXMuX3dyYXByb3VuZENvdW50KHRoaXMuX2luZGV4LCBuZXh0SW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgsIGRpcmVjdGlvbilcblxuICAgIGNvbnN0IG91dGVyU2xpZGVQcm9wcyA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKGRpcmVjdGlvbiA+IDAgPyB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwKVxuICAgIGNvbnN0IGluZGV4VG9PdXRlclNsaWRlQ291bnQgPSB0aGlzLl93cmFwcm91bmRDb3VudCh0aGlzLl9pbmRleCwgb3V0ZXJTbGlkZVByb3BzLmluZGV4LCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoLCBkaXJlY3Rpb24pXG5cbiAgICBjb25zdCBzbGlkZXNUb0luc2VydCA9IHNjcm9sbENvdW50IC0gaW5kZXhUb091dGVyU2xpZGVDb3VudFxuICAgIGlmIChzbGlkZXNUb0luc2VydCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlDb3VudChzbGlkZXNUb0luc2VydCwgZGlyZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIF9jbG9uZVNsaWRlc0J5VG9GaWxsKHNwYWNlVG9GaWxsLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgb3JpZ2luYWxJbmRleCA9IGRpcmVjdGlvbiA8IDAgPyAwIDogdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgbGV0IGluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltvcmlnaW5hbEluZGV4XS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSwgMTApXG5cbiAgICB3aGlsZSAoc3BhY2VUb0ZpbGwgPiAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCArIGRpcmVjdGlvbiwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICAgIHNwYWNlVG9GaWxsIC09IHRoaXMuX2Nsb25lU2xpZGUoaW5kZXgsIGRpcmVjdGlvbilcbiAgICB9XG4gIH1cblxuICBfY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoY2xlYW51cCwgc2xpZGVEZWx0YSA9IDApIHtcbiAgICBjb25zdCByZWFsSW5kZXggPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4XG4gICAgbGV0IGZpcnN0LCBsYXN0XG5cbiAgICBpZiAoY2xlYW51cCA9PT0gZmFsc2UpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMoMClcbiAgICAgIGxhc3QgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcyh0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFJlbW92YWJsZVNsaWRlcyhzbGlkZURlbHRhKVxuICAgICAgZmlyc3QgPSByZXN1bHQuZmlyc3RcbiAgICAgIGxhc3QgPSByZXN1bHQubGFzdFxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHNsaWRlcyBmcm9tIHZpZXdcbiAgICAgIGZvciAobGV0IGkgPSByZXN1bHQuc2xpZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChyZXN1bHQuc2xpZGVzW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5yZW1vdmVTbGlkZShpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNwYWNlVG9GaWxsID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRFbXB0eVNwYWNlKGZpcnN0LmxlZnQsIGxhc3QucmlnaHQpXG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIGxlZnRcbiAgICBpZiAoZmlyc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5sZWZ0ID4gMCkge1xuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNCeVRvRmlsbChzcGFjZVRvRmlsbC5sZWZ0LCAtMSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIHNsaWRlcyBhcmUgcmVxdWlyZWQgb24gdGhlIHJpZ2h0XG4gICAgaWYgKGxhc3QudmlzaWJsZSA9PT0gdHJ1ZSAmJiBzcGFjZVRvRmlsbC5yaWdodCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlUb0ZpbGwoc3BhY2VUb0ZpbGwucmlnaHQsIDEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWxJbmRleCAtIHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWFsICh3cmFwcGVyKSBpbmRleCBmb3IgdGhlIHNsaWRlIHdpdGggdGhlIGdpdmVuIG9yaWdpbmFsIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHNlYXJjaFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgd3JhcHBlciBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlYWxJbmRleEZvcihpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IGkgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBpIDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGxldCBzbGlkZUluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltpXS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSwgMTApXG4gICAgICBpZiAoc2xpZGVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cblxuICAgICAgaSArPSBkaXJlY3Rpb25cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENsb3VkIG5vdCBmaW5kIHJlYWwgaW5kZXggZm9yIHNsaWRlICR7aW5kZXh9IGluIGRpcmVjdGlvbiAke2RpcmVjdGlvbn1gKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBzbGlkZS4gSWYgdGhlIHNsaWRlcyBhcmUgZ3JvdXBlZCBldmVubHlcbiAgICogdGhlIGFjdGl2ZSBzbGlkZSBpcyBhbHdheXMgdGhlIGZpcnN0IGluIHRoZSBncm91cC5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgc2xpZGUuXG4gICAqL1xuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl9mcmFtZVdpZHRoID0gdGhpcy5fc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIC53aWR0aCB8fCB0aGlzLl9zbGlkZXIub2Zmc2V0V2lkdGhcblxuICAgIHRoaXMuX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKClcblxuICAgIGlmICh0aGlzLl9uZXh0Q3RybCkge1xuICAgICAgdGhpcy5fbmV4dEN0cmwuZGlzYWJsZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcmV2Q3RybCkge1xuICAgICAgdGhpcy5fcHJldkN0cmwuZGlzYWJsZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fc2xpZGVyLnBhcmVudEVsZW1lbnQpXG4gICAgICBsZXQgcGFyZW50V2lkdGggPSB0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aCArIChwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkxlZnQpIHx8IDApICsgKHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luUmlnaHQpIHx8IDApXG5cbiAgICAgIGxldCBvdXRlck1hcmdpbiA9IE1hdGguY2VpbChwYXJlbnRXaWR0aCAtIHRoaXMuX2ZyYW1lV2lkdGgpXG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSBNYXRoLmNlaWwob3V0ZXJNYXJnaW4gKiAwLjUpICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW4gPSAwXG4gICAgfVxuXG4gICAgbGV0IHNsaWRlTWFyZ2luID0gdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID4gMCA/IGAke3RoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbn1weGAgOiBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc2xpZGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW2ldXG4gICAgICBzbGlkZS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xpZGVNYXJnaW5cbiAgICAgIHNsaWRlLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2xpZGVNYXJnaW5cbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm9ucmVzaXplKClcbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm1vdmVUbyh0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4KVxuXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgbmV4dCBpdGVtLlxuICAgKi9cbiAgcHJldigpIHtcbiAgICB0aGlzLnNsaWRlKGZhbHNlLCAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgc2xpZGVyIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxuICAgKi9cbiAgbmV4dCgpIHtcbiAgICB0aGlzLnNsaWRlKGZhbHNlLCAxKVxuICB9XG5cbiAgc2xpZGUobmV4dEluZGV4LCBkaXJlY3Rpb24sIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0SW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHRoaXMuX2luZGV4ICsgdGhpcy5fc2xpZGVzUGVyR3JvdXBcbiAgICAgICAgZGlyZWN0aW9uID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5faW5kZXggLSB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICAgICAgICBkaXJlY3Rpb24gPSAtMVxuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRJbmRleCA9IHRoaXMuX2FkanVzdEluZGV4KG5leHRJbmRleClcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICBkaXJlY3Rpb24gPSBjbGFtcChuZXh0SW5kZXggLSB0aGlzLl9pbmRleCwgLTEsIDEpXG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBlbm91Z2h0IHNsaWRlcyBvbiBzY3JlZW5cbiAgICB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcihmYWxzZSlcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgZW5vdWdoIHNsaWRlcyBmb3IgdGhlIHNjcm9sbCBvcGVyYXRpb25cbiAgICB0aGlzLl9jbG9uZVNsaWRlc0J5U2Nyb2xsQ291bnQobmV4dEluZGV4LCBkaXJlY3Rpb24pXG5cbiAgICBsZXQgcmVhbEluZGV4ID0gdGhpcy5fZ2V0UmVhbEluZGV4Rm9yKG5leHRJbmRleCwgZGlyZWN0aW9uKVxuICAgIGxldCBzbGlkZURlbHRhID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZURlbHRhKHJlYWxJbmRleClcbiAgICByZWFsSW5kZXggPSBNYXRoLm1heChyZWFsSW5kZXggLSB0aGlzLl9jbG9uZVNsaWRlc1RvRml0V3JhcHBlcih0cnVlLCBzbGlkZURlbHRhKSwgMClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIubW92ZVRvKHJlYWxJbmRleCwgdW5kZWZpbmVkLCBhbmltYXRlKVxuXG4gICAgLy8gVXBkYXRlIHRoZSBhY3RpdmUgaW5kZXhcbiAgICB0aGlzLl9pbmRleCA9IG5leHRJbmRleFxuXG4gICAgLy8gTWFyayBzbGlkZXMgYXMgYWN0aXZlXG4gICAgdGhpcy5fdXBkYXRlUGFnaW5hdGlvbigpXG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlU2xpZGVzKHJlYWxJbmRleClcblxuICAgIC8vIGNvbnNvbGUubG9nKGBQZXJmb3JtZWQgc2xpZGUgdG8gJHt0aGlzLl9pbmRleH0sIHJlYWxJbmRleDogJHt0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4fWApXG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHNsaWRlciB0byB0aGUgc2VsZWN0ZWQgc2xpZGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc2xpZGUgdG8gc2xpZGUgdG8uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZSAtIGBUcnVlYCBpZiB0aGUgc2xpZGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgc2xpZGVUbyhpbmRleCwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICB0aGlzLnNsaWRlKGluZGV4LCB1bmRlZmluZWQsIGFuaW1hdGUpXG4gIH1cblxuICAvKipcbiAgICogRGVzdG9yeXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9zbGlkZUFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgdGhpcy5fYnJlYWtwb2ludFBob25lLnJlbW92ZSgpXG4gICAgdGhpcy5fYnJlYWtwb2ludFRhYmxldC5yZW1vdmUoKVxuICAgIHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wLnJlbW92ZSgpXG5cbiAgICBpZiAodGhpcy5fcHJldkN0cmwgJiYgdGhpcy5fbmV4dEN0cmwpIHtcbiAgICAgIHRoaXMuX3ByZXZDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2SGFuZGxlcilcbiAgICAgIHRoaXMuX25leHRDdHJsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9uZXh0SGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9wcmV2Q3RybCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX25leHRDdHJsID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5fcGFnaW5hdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlcilcbiAgICAgIHRoaXMuX3BhZ2luYXRpb24gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmRlc3RvcnkoKVxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIgPSB1bmRlZmluZWRcbiAgfVxufVxuXG5jbGFzcyBTbGlkZXJXcmFwcGVyIHtcbiAgY29uc3RydWN0b3Iod3JhcHBlckVsZW1lbnQsIHNsaWRlQXJlYUVsZW1lbnQsIGNhcm91c2VsRWxlbWVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnRcbiAgICB0aGlzLl9zbGlkZUFyZWFFbGVtZW50ID0gc2xpZGVBcmVhRWxlbWVudFxuICAgIHRoaXMuX2Nhcm91c2VsRWxlbWVudCA9IGNhcm91c2VsRWxlbWVudFxuXG4gICAgdGhpcy5fcG9zaXRpb24gPSAwXG4gICAgdGhpcy5fdHJhbnNsYXRlID0gMFxuICAgIHRoaXMuX2luZGV4ID0gMFxuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSBmYWxzZVxuICB9XG5cbiAgX2dldFNsaWRlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJ2luZGV4JyBpcyBvdXQgb2YgcmFuZ2UsIFZhbHVlOiAke2luZGV4fSBNaW46IDAsIE1heDogJHt0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuW2luZGV4XVxuICB9XG5cbiAgX3NldFRyYW5zZm9ybSh0YXJnZXRQb3NpdGlvbiwgYW5pbWF0ZWQgPSBmYWxzZSwgZHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04sIGVhc2UgPSBBTklNQVRJT05fRUFTSU5HKSB7XG4gICAgaWYgKGFuaW1hdGVkID09PSBmYWxzZSkge1xuICAgICAgZHVyYXRpb24gPSAwXG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgc3R5bGVbdGhpcy5fcHJlZml4ZXMuZHVyYXRpb25dID0gYCR7ZHVyYXRpb259bXNgXG4gICAgICBzdHlsZVt0aGlzLl9wcmVmaXhlcy50aW1pbmddID0gZWFzZVxuXG4gICAgICAvLyBObyBzdWIgcGl4ZWwgdHJhbnNpdGlvbnMuXG4gICAgICB0YXJnZXRQb3NpdGlvbiA9IE1hdGguZmxvb3IodGFyZ2V0UG9zaXRpb24pXG5cbiAgICAgIHN0eWxlW3RoaXMuX3ByZWZpeGVzLnRyYW5zZm9ybV0gPSBgdHJhbnNsYXRlKCR7dGFyZ2V0UG9zaXRpb259cHgsIDApYFxuICAgICAgdGhpcy5fcG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvblxuICAgIH1cbiAgfVxuXG4gIF9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHdyYXBwZXJDZW50ZXIgPSAoMC41ICogdGhpcy5fd3JhcHBlckVsZW1lbnQub2Zmc2V0V2lkdGgpXG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcblxuICAgIGxldCByZXN1bHQgPSAwXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2xpZGUgKGNlbnRlcmVkKVxuICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCAlIDIgPT09IDApIHtcbiAgICAgIGxldCBzbGlkZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2xpZGUsIG51bGwpXG4gICAgICBsZXQgc2xpZGVNYXJnaW4gPSBzbGlkZVN0eWxlID8gcGFyc2VJbnQoc2xpZGVTdHlsZS5tYXJnaW5SaWdodCwgMTApIDogMFxuICAgICAgLy8gQ2VudGVyZWQgdG8gdGhlIHNwYWNlIGJldHdlZW4gdGhlIHR3byBjZW50ZXIgc2xpZGVzIG9mIHRoZSBncm91cFxuICAgICAgcmVzdWx0ID0gLXNsaWRlLm9mZnNldExlZnQgLSAoc2xpZGUuY2xpZW50V2lkdGgpICsgd3JhcHBlckNlbnRlciAtIHNsaWRlTWFyZ2luXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IC1zbGlkZS5vZmZzZXRMZWZ0IC0gKDAuNSAqIHNsaWRlLmNsaWVudFdpZHRoKSArIHdyYXBwZXJDZW50ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uXG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH1cblxuICBzZXQgc2xpZGVzUGVyR3JvdXAodmFsdWUpIHtcbiAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IHZhbHVlXG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3ByZWZpeGVzID0ge1xuICAgICAgdHJhbnNpdGlvbjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICB0cmFuc2Zvcm06IFwidHJhbnNmb3JtXCIsXG4gICAgICBkdXJhdGlvbjogXCJ0cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgICB0aW1pbmc6IFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIlxuICAgIH1cblxuICAgIHRoaXMub25yZXNpemUoKVxuICB9XG5cbiAgb25yZXNpemUoKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBhcmVhIG9mZnNldCBmb3Igc2xpZGUgcG9zaXRpb24gY2FsY3VsYXRpb25cbiAgICB0aGlzLl9hcmVhT2Zmc2V0ID0gdGhpcy5fc2xpZGVBcmVhRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG5cbiAgICAvLyBHZXQgdGhlIGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMuX2Nhcm91c2VsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuX2NvbnRhaW5lck1pbiA9IGNvbnRhaW5lclJlY3QubGVmdFxuICAgIHRoaXMuX2NvbnRhaW5lck1heCA9IGNvbnRhaW5lclJlY3QucmlnaHRcbiAgICB0aGlzLl9jb250YWluZXJDZW50ZXIgPSAwLjUgKiAodGhpcy5fY29udGFpbmVyTWF4IC0gdGhpcy5fY29udGFpbmVyTWluKVxuICB9XG5cbiAgYmVnaW5EcmFnKCkge1xuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSB0cnVlXG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvblxuICAgIHRoaXMuX2RyYWdTdGFydEluZGV4ID0gdGhpcy5faW5kZXhcbiAgfVxuXG4gIGNhbmNlbERyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uLCB0cnVlLCBBTklNQVRJT05fRFVSQVRJT04sIEFOSU1BVElPTl9FQVNJTkcpXG5cbiAgICB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2RyYWdTdGFydEluZGV4ID0gdW5kZWZpbmVkXG4gIH1cblxuICBlbmREcmFnKCkge1xuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZHJhZ1N0YXJ0SW5kZXggPSB1bmRlZmluZWRcbiAgfVxuXG4gIG1vdmUoZGVsdGEsIGFuaW1hdGVkID0gZmFsc2UsIGR1cmF0aW9uID0gQU5JTUFUSU9OX0RVUkFUSU9OLCBlYXNlID0gQU5JTUFUSU9OX0VBU0lORykge1xuICAgIGRlbHRhID0gTWF0aC50cnVuYyhkZWx0YSlcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGEpIDw9IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICs9IGRlbHRhXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKHRhcmdldFBvc2l0aW9uLCBhbmltYXRlZCwgZHVyYXRpb24sIGVhc2UpXG4gIH1cblxuICBtb3ZlVG8oaW5kZXgsIGRlbHRhID0gdW5kZWZpbmVkLCBhbmltYXRlZCA9IGZhbHNlKSB7XG4gICAgbGV0IG5ld1Bvc2l0aW9uID0gMFxuICAgIGlmICghZGVsdGEpIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Bvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKz0gZGVsdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKG5ld1Bvc2l0aW9uLCBhbmltYXRlZClcbiAgfVxuXG4gIGFkZFNsaWRlKHNsaWRlLCBwb3NpdGlvbikge1xuICAgIGlmICghc2xpZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgYW4gdW5kZWZpbmVkIHNsaWRlXCIpXG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uICE9PSAtMSAmJiBwb3NpdGlvbiAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCBvdXQgb2YgcmFuZ2UsICdwb3NpdGlvbicgbXVzdCBiZSBlaXRoZXIgMSBvciAtMS4gVmFsdWUgJHtwb3NpdGlvbn1gKVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA+IDApIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHNsaWRlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5pbnNlcnRCZWZvcmUoc2xpZGUsIHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuWzBdKVxuICAgICAgdGhpcy5faW5kZXgrK1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgIGxldCB3aWR0aCA9IHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlLCBudWxsKVxuICAgICAgbGV0IG1hcmdpbkxlZnQgPSBzdHlsZSA/IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSA6IDBcbiAgICAgIGxldCBtYXJnaW5SaWdodCA9IHN0eWxlID8gcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKSA6IDBcblxuICAgICAgdGhpcy5tb3ZlKC0od2lkdGggKyBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQpKVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVNsaWRlKGluZGV4KSB7XG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcbiAgICBsZXQgd2lkdGggPSBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgaWYgKGluZGV4IDw9IHRoaXMuX2luZGV4KSB7XG4gICAgICB3aWR0aCAqPSAtMVxuICAgICAgdGhpcy5faW5kZXgtLVxuICAgIH1cblxuICAgIHJlbW92ZShzbGlkZSlcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgIHRoaXMubW92ZSgtd2lkdGgpXG4gICAgfVxuICB9XG5cbiAgZ2V0U2xpZGVEZWx0YShpbmRleCkge1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvblxuICAgIGlmICh0aGlzLl9pc2RyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICBjdXJyZW50UG9zaXRpb24gPSB0aGlzLl9kcmFnU3RhcnRQb3NpdGlvbiAtIHRoaXMuX3Bvc2l0aW9uXG4gICAgfVxuXG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLl9nZXRXcmFwcGVyU2xpZGVQb3NpdGlvbihpbmRleClcbiAgICByZXR1cm4gbmV3UG9zaXRpb24gLSBjdXJyZW50UG9zaXRpb25cbiAgfVxuXG4gIGdldFNsaWRlUHJvcGVydGllcyhpbmRleCwgZGVsdGEgPSB1bmRlZmluZWQpIHtcbiAgICBkZWx0YSA9IGRlbHRhIHx8IDBcbiAgICBsZXQgY3VycmVudE9mZnNldCA9IHRoaXMuX2FyZWFPZmZzZXQgKyB0aGlzLl9wb3NpdGlvbiArIGRlbHRhXG4gICAgbGV0IGN1cnJlbnRMZWZ0ID0gY3VycmVudE9mZnNldFxuICAgIGxldCBjdXJyZW50UmlnaHQgPSBjdXJyZW50T2Zmc2V0XG4gICAgbGV0IHsgY3VycmVudE1hcmdpbkxlZnQsIGN1cnJlbnRNYXJnaW5SaWdodCB9ID0gMFxuXG4gICAgbGV0IHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaW5kZXgpXG4gICAgbGV0IHNsaWRlSW5kZXggPSBwYXJzZUludChzbGlkZS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSwgMTApXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGkpXG4gICAgICBsZXQgc2xpZGVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNsaWRlKVxuXG4gICAgICBjdXJyZW50TWFyZ2luTGVmdCA9IHBhcnNlSW50KHNsaWRlU3R5bGUubWFyZ2luTGVmdCwgMTApXG4gICAgICBjdXJyZW50TWFyZ2luUmlnaHQgPSBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpblJpZ2h0LCAxMClcblxuICAgICAgY3VycmVudE9mZnNldCArPSBjdXJyZW50TWFyZ2luTGVmdFxuICAgICAgY3VycmVudExlZnQgPSBjdXJyZW50T2Zmc2V0XG4gICAgICBjdXJyZW50UmlnaHQgPSBjdXJyZW50TGVmdCArIHNsaWRlLm9mZnNldFdpZHRoXG5cbiAgICAgIGlmIChpIDwgaW5kZXgpIHtcbiAgICAgICAgY3VycmVudE9mZnNldCA9IGN1cnJlbnRSaWdodCArIGN1cnJlbnRNYXJnaW5SaWdodFxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB2aXNpYmxlID0gZmFsc2VcbiAgICBpZiAoKGN1cnJlbnRMZWZ0ID4gdGhpcy5fY29udGFpbmVyTWluICYmIGN1cnJlbnRMZWZ0IDwgdGhpcy5fY29udGFpbmVyTWF4KSB8fFxuICAgICAgIChjdXJyZW50UmlnaHQgPiB0aGlzLl9jb250YWluZXJNaW4gJiYgY3VycmVudFJpZ2h0IDwgdGhpcy5fY29udGFpbmVyTWF4KSkge1xuICAgICAgdmlzaWJsZSA9IHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZSxcbiAgICAgIGluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgbGVmdDogY3VycmVudExlZnQsXG4gICAgICByaWdodDogY3VycmVudFJpZ2h0LFxuICAgICAgd2lkdGg6IGN1cnJlbnRSaWdodCAtIGN1cnJlbnRMZWZ0LFxuICAgICAgbWFyZ2luTGVmdDogY3VycmVudE1hcmdpbkxlZnQsXG4gICAgICBtYXJnaW5SaWdodDogY3VycmVudE1hcmdpblJpZ2h0XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtb3ZhYmxlU2xpZGVzKGRlbHRhKSB7XG4gICAgbGV0IHNsaWRlcyA9IFtdXG4gICAgbGV0IGZpcnN0LCBsYXN0XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGhcbiAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICBpbmRleC0tXG5cbiAgICAgIGxldCBwcm9wc05vdyA9IHRoaXMuZ2V0U2xpZGVQcm9wZXJ0aWVzKGluZGV4KVxuICAgICAgbGV0IHByb3BzTmV3ID0gdGhpcy5nZXRTbGlkZVByb3BlcnRpZXMoaW5kZXgsIGRlbHRhKVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGFzdCA9IHByb3BzTmV3XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBmaXJzdCA9IHByb3BzTmV3XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wc05vdy52aXNpYmxlID09PSBmYWxzZSAmJiBwcm9wc05ldy52aXNpYmxlID09PSBmYWxzZSAmJlxuICAgICAgICAgIGluZGV4ICE9PSB0aGlzLl9pbmRleCAmJiB0aGlzLl9pc2RyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICBzbGlkZXMucHVzaCh0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVzLnB1c2goZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2xpZGVzLnJldmVyc2UoKVxuXG4gICAgbGV0IGZpcnN0VG9LZWVwID0gc2xpZGVzLmluZGV4T2YoZmFsc2UpXG4gICAgbGV0IGxhc3RUb0tlZXAgPSBzbGlkZXMubGFzdEluZGV4T2YoZmFsc2UpXG5cbiAgICBmb3IgKGxldCBpID0gZmlyc3RUb0tlZXA7IGkgPCBsYXN0VG9LZWVwOyBpKyspIHtcbiAgICAgIHNsaWRlc1tpXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gbGV0IGxvZzEgPSBcIlwiXG4gICAgLy8gbGV0IGxvZzIgPSBcIlwiXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgIGxldCBhZGRvbiA9IGkgPiA5ID8gXCIgXCIgOiBcIlwiXG4gICAgLy8gICBsb2cxICs9IGAke2FkZG9ufSAke2l9YFxuICAgIC8vICAgbG9nMiArPSBgJHthZGRvbn0ke2FkZG9ufSAke3NsaWRlc1tpXSA9PT0gdHJ1ZSA/IFwiWFwiIDogXCItXCJ9YFxuICAgIC8vIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKGxvZzEpXG4gICAgLy8gY29uc29sZS5sb2cobG9nMilcblxuICAgIHJldHVybiB7XG4gICAgICBzbGlkZXMsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3RcbiAgICB9XG4gIH1cblxuICBnZXRFbXB0eVNwYWNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IE1hdGgubWF4KE1hdGguY2VpbChsZWZ0IC0gdGhpcy5fY29udGFpbmVyTWluKSwgMCksXG4gICAgICByaWdodDogTWF0aC5tYXgoTWF0aC5jZWlsKHRoaXMuX2NvbnRhaW5lck1heCAtIHJpZ2h0KSwgMClcbiAgICB9XG4gIH1cblxuICBkZXN0b3J5KCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX3NsaWRlQXJlYUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fY2Fyb3VzZWxFbGVtZW50ID0gbnVsbFxuXG4gICAgdGhpcy5fcHJlZml4ZXMgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuY2Fyb3VzZWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQ2Fyb3VzZWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxcbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCB7IHRyeUdldERhdGEsIGNyZWF0ZUxlZ2VuZEl0ZW0sIGlzQ29sb3IsIHJlbW92ZUFsbENoaWxkcmVuIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuXG5pbXBvcnQgeyBUaW1lbGluZUxpdGUsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcblxuY29uc3QgUVVFUllfSU5ESUNBVE9SID0gXCIuYmFyLWNoYXJ0X19wcm9ncmVzc1wiXG5jb25zdCBRVUVSWV9ERVRBSUxfUklHSFQgPSBcIi5kZXRhaWwtcmlnaHRcIlxuY29uc3QgUVVFUllfREVUQUlMX0JPVFRPTSA9IFwiLmRldGFpbC1ib3R0b21cIlxuY29uc3QgUVVFUllfUFJPR1JFU1MgPSBcIi5iYXItY2hhcnRfX3Byb2dyZXNzXCJcblxuY29uc3QgQ0xBU1NfVU5MSU1JVEVEID0gXCJiYXItY2hhcnQtaG9yaXpvbnRhbC0tdW5saW1pdGVkXCJcbmNvbnN0IENMQVNTX0xJTUlURUQgPSBcImJhci1jaGFydC1ob3Jpem9udGFsLS1saW1pdGVkXCJcblxuY29uc3QgQ0xBU1NfREVUQUlMX1ZBTFVFID0gXCJ2YWx1ZVwiXG5jb25zdCBDTEFTU19ERVRBSUxfVU5JVCA9IFwidW5pdFwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlclwiXG5cbmNvbnN0IENMQVNTX1RPT0xUSVAgPSBcInRvb2x0aXBcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUgPSBcInRvb2x0aXAtLW11bHRpbGluZVwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDAuNVxuXG4vKipcbiAqIEJhciBDaGFydCBIb3Jpem9udGFsIENvbXBvbmVudC5cbiAqL1xuY2xhc3MgQmFyQ2hhcnRIb3Jpem9udGFsIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBiYXIgY2hhcnQgaG9yaXpvbnRhbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgZGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5fZGF0YSA9IGRhdGFcblxuICAgIHRoaXMuX2xlZ2VuZEl0ZW1zID0gW11cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5faW5kaWNhdG9yV3JhcHBlciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0lORElDQVRPUilcblxuICAgIHRoaXMuX3VuaXQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdW5pdFwiKSB8fCBcIlwiXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikpXG4gICAgdGhpcy5fcHJlY2lzaW9uID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNpc2lvblwiKSwgMTApIHx8IDBcblxuICAgIHRoaXMuX2lzVW5saW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19VTkxJTUlURUQpXG4gICAgdGhpcy5faXNMaW1pdGVkID0gdGhpcy5oYXNDbGFzcyhDTEFTU19MSU1JVEVEKVxuXG4gICAgdGhpcy5fcHJvZ2Vzc1dyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9QUk9HUkVTUylcblxuICAgIGlmICh0aGlzLl9pc0xpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfREVUQUlMX0JPVFRPTSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9ERVRBSUxfUklHSFQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVW5saW1pdGVkID09PSBmYWxzZSAmJiB0aGlzLl9pc0xpbWl0ZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9sZWdlbmQgPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGVnZW5kXCIpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdHJ5R2V0RGF0YSh0aGlzLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIF9yZW5kZXIoKSB7XG4gICAgbGV0IGRhdGFPbmUgPSB0aGlzLl9kYXRhWzBdXG4gICAgbGV0IGRhdGFUd28gPSB0aGlzLl9kYXRhWzFdXG5cbiAgICBsZXQgdGwgPSBuZXcgVGltZWxpbmVMaXRlKClcbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuX2lzTGltaXRlZCA9PT0gZmFsc2UgPyB0aGlzLl9nZXRUb29sdGlwQ29udGVudCh0aGlzLl9kYXRhKSA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGFuaW1hdGVkVmFsdWVFbGVtZW50XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fZGV0YWlsUmlnaHQpXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fcHJvZ2Vzc1dyYXBwZXIpXG5cbiAgICAvLyBDbGVhciBvbmx5IG93biBsZWdlbmQgaXRlbXNcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX2xlZ2VuZEl0ZW1zKSB7XG4gICAgICByZW1vdmUoaXRlbSlcbiAgICB9XG4gICAgdGhpcy5fbGVnZW5kSXRlbXMgPSBbXVxuXG4gICAgaWYgKGRhdGFPbmUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1VubGltaXRlZCA9PT0gZmFsc2UgfHwgKHRoaXMuX2lzVW5saW1pdGVkID09PSB0cnVlICYmICFkYXRhVHdvKSkge1xuXG4gICAgICAgIGxldCB2YWxFbGVtZW50ID0gYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoZGF0YU9uZSlcbiAgICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodmFsRWxlbWVudClcblxuICAgICAgICBpZiAodGhpcy5faXNMaW1pdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGxldCBzZXBhcmF0b3JFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19ERVRBSUxfVU5JVClcbiAgICAgICAgICAgIC5zZXRIdG1sKGAgJHt0aGlzLl91bml0fWApXG4gICAgICAgICAgICAuZWxlbWVudFxuXG4gICAgICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yRWxlbWVudClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGluZGljYXRvclxuICAgICAgbGV0IGluZGljYXRvciA9IHRoaXMuX2FkZEluZGljYXRvcihkYXRhT25lLCB0b29sdGlwKVxuXG4gICAgICB0bC5mcm9tKGluZGljYXRvciwgQU5JTUFUSU9OX0RVUkFUSU9OLCB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZUluT3V0XG4gICAgICB9KVxuXG4gICAgICAvLyBBbmltYXRlIHRoZSB2YWx1ZSBpZiByZXF1aXJlZFxuICAgICAgaWYgKGFuaW1hdGVkVmFsdWVFbGVtZW50ICYmIHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgY291bnRlciA9IHsgdmFyOiAwIH1cbiAgICAgICAgdGwudG8oY291bnRlciwgQU5JTUFUSU9OX0RVUkFUSU9OLCB7XG4gICAgICAgICAgdmFyOiBkYXRhT25lLnZhbHVlLFxuICAgICAgICAgIHJvdW5kUHJvcHM6IFwidmFyXCIsXG4gICAgICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGFuaW1hdGVkVmFsdWVFbGVtZW50LmlubmVySFRNTCA9IGAke2NvdW50ZXIudmFyfWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlT3V0XG4gICAgICAgIH0sIGAtPSR7QU5JTUFUSU9OX0RVUkFUSU9OfWApXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgbGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGRhdGFPbmUpXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtKVxuICAgICAgICB0aGlzLl9sZWdlbmRJdGVtcy5wdXNoKGxlZ2VuZEl0ZW0pXG5cbiAgICAgICAgdGwuZnJvbShsZWdlbmRJdGVtLCBBTklNQVRJT05fRFVSQVRJT04sIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXRcbiAgICAgICAgfSwgYC09JHtBTklNQVRJT05fRFVSQVRJT059YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YVR3bykge1xuICAgICAgbGV0IHZhbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoZGF0YVR3bylcblxuICAgICAgbGV0IHVuaXRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgICAgLnNldEh0bWwoYCAke3RoaXMuX3VuaXR9YClcbiAgICAgICAgICAuZWxlbWVudFxuXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodW5pdEVsZW1lbnQpXG5cbiAgICAgIC8vIEFkZCB0aGUgaW5kaWNhdG9yXG4gICAgICBsZXQgaW5kaWNhdG9yID0gdGhpcy5fYWRkSW5kaWNhdG9yKGRhdGFUd28sIHRvb2x0aXApXG4gICAgICB0bC5mcm9tKGluZGljYXRvciwgQU5JTUFUSU9OX0RVUkFUSU9OLCB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZUluT3V0XG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGxlZ2VuZFxuICAgICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kSXRlbShkYXRhVHdvKVxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSlcbiAgICAgICAgdGhpcy5fbGVnZW5kSXRlbXMucHVzaChsZWdlbmRJdGVtKVxuXG4gICAgICAgIHRsLmZyb20obGVnZW5kSXRlbSwgQU5JTUFUSU9OX0RVUkFUSU9OLCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZUluT3V0XG4gICAgICAgIH0sIGAtPSR7QU5JTUFUSU9OX0RVUkFUSU9OfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IHZhbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoeyB2YWx1ZTogdGhpcy5fbWF4VmFsdWUgfSlcblxuICAgICAgbGV0IHVuaXRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfREVUQUlMX1VOSVQpXG4gICAgICAgICAgLnNldEh0bWwoYCAke3RoaXMuX3VuaXR9YClcbiAgICAgICAgICAuZWxlbWVudFxuXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodW5pdEVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhKSB7XG4gICAgbGV0IHVubGltaXRlZFByZWZpeCA9IFwiXCJcblxuICAgIGlmICh0aGlzLl9pc1VubGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdW5saW1pdGVkUHJlZml4ID0gXCIrXCJcbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KGRhdGEudmFsdWUpXG4gICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgIHZhbHVlID0gXCIuMDBcIlxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9WQUxVRSlcbiAgICAgIC5zZXRIdG1sKGAke3VubGltaXRlZFByZWZpeH0ke3ZhbHVlfWApXG4gICAgICAuZWxlbWVudFxuICB9XG5cbiAgX2FkZEluZGljYXRvcihkYXRhLCB0b29sdGlwKSB7XG4gICAgbGV0IHdpZHRoID0gKCg5OS44IC8gdGhpcy5fbWF4VmFsdWUpICogZGF0YS52YWx1ZSlcblxuICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUilcblxuICAgIGlmIChpc0NvbG9yKGRhdGEuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZGF0YS5jb2xvcn07YClcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLmFkZENsYXNzKGRhdGEuY29sb3IpXG4gICAgfVxuXG4gICAgbGV0IGluZGljYXRvcldyYXBwZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9XUkFQUEVSKVxuICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB3aWR0aDogJHt3aWR0aH0lYClcbiAgICAgIC5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICAuc2V0QXR0cmlidXRlKFwib25jbGlja1wiLCBcInZvaWQoMClcIilcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAgIT09IFwiXCIpIHtcbiAgICAgIGluZGljYXRvcldyYXBwZXJcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVApXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQX01VTFRJTElORSlcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9vbHRpcClcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9nZXNzV3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3JXcmFwcGVyLmVsZW1lbnQpXG4gICAgcmV0dXJuIGluZGljYXRvcldyYXBwZXIuZWxlbWVudFxuICB9XG5cbiAgX2dldFRvb2x0aXBDb250ZW50KGRhdGFMaXN0KSB7XG4gICAgbGV0IHRvb2x0aXAgPSBcIlwiXG4gICAgZm9yIChsZXQgZGF0YSBvZiBkYXRhTGlzdCkge1xuICAgICAgdG9vbHRpcCArPSBgJHtkYXRhLnRpdGxlfTogJHtkYXRhLnZhbHVlfSAke3RoaXMuX3VuaXR9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwLnRyaW0oKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJhciBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBiYXIgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHVwZGF0ZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0b3J5KCkge1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWRcblxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2RldGFpbFJpZ2h0KVxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX3Byb2dlc3NXcmFwcGVyKVxuXG4gICAgdGhpcy5fZGV0YWlsUmlnaHQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wcm9nZXNzV3JhcHBlciA9IHVuZGVmaW5lZFxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9sZWdlbmRJdGVtcykge1xuICAgICAgcmVtb3ZlKGl0ZW0pXG4gICAgfVxuXG4gICAgdGhpcy5fbGVnZW5kSXRlbXMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9sZWdlbmQgPSB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5iYXItY2hhcnQtaG9yaXpvbnRhbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBCYXJDaGFydEhvcml6b250YWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFyQ2hhcnRIb3Jpem9udGFsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IHRleHQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCB7IGNyZWF0ZUxlZ2VuZEl0ZW0sIGlzQ29sb3IsIHJlbW92ZUFsbENoaWxkcmVuIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuXG5pbXBvcnQgeyBUaW1lbGluZUxpdGUsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcblxuY29uc3QgUVVFUllfREFUQV9DQVRFR09SSUVTID0gXCIuanMtZGF0YS1saXN0IC5qcy1jYXRlZ29yeVwiXG5jb25zdCBRVUVSWV9EQVRBX0lURU1TID0gXCIuanMtZGF0YS1saXN0IC5qcy1kYXRhXCJcbmNvbnN0IFFVRVJZX0NIQVJUID0gXCIuanMtY2hhcnRcIlxuY29uc3QgUVVFUllfTEVHRU5EID0gXCIuYmFyLWNoYXJ0X19sZWdlbmRcIlxuXG5jb25zdCBDTEFTU19JTkRJQ0FUT1IgPSBcImluZGljYXRvclwiXG5jb25zdCBDTEFTU19MQUJFTF9YID0gXCJheGlzLXgtbGFiZWxcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9JTk5FUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlci1pbm5lclwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfRU1QVFkgPSBcImVtcHR5XCJcblxuY29uc3QgQ0xBU1NfVE9PTFRJUCA9IFwidG9vbHRpcFwiXG5jb25zdCBDTEFTU19UT09MVElQX1JJR0hUID0gXCJ0b29sdGlwLS1yaWdodFwiXG5jb25zdCBDTEFTU19UT09MVElQX01VTFRJTElORSA9IFwidG9vbHRpcC0tbXVsdGlsaW5lXCJcblxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gMC41XG5cbi8qKlxuICogQmFyIENoYXJ0IEhvcml6b250YWwgQ29tcG9uZW50LlxuICovXG5jbGFzcyBCYXJDaGFydFZlcnRpY2FsIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBiYXIgY2hhcnQgaG9yaXpvbnRhbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCwgZGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5fZGF0YSA9IGRhdGFcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fdW5pdCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS11bml0XCIpIHx8IFwiXCJcblxuICAgIHRoaXMuX21pblZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtbWluXCIpKSB8fCAwXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikpIHx8IDEwMFxuXG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9DSEFSVClcbiAgICB0aGlzLl9sZWdlbmQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9MRUdFTkQpXG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl90cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgX3RyeUdldERhdGEoZWxlbWVudCkge1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgY2F0ZWdvcmllczogW10sXG4gICAgICBpdGVtczogW11cbiAgICB9XG5cbiAgICBsZXQgY2F0ZWdvcmllcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9EQVRBX0NBVEVHT1JJRVMpXG4gICAgbGV0IGl0ZW1zID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEFfSVRFTVMpXG5cbiAgICBmb3IgKGxldCBjYXRlZ29yeSBvZiBjYXRlZ29yaWVzKSB7XG4gICAgICBkYXRhLmNhdGVnb3JpZXMucHVzaChcbiAgICAgICAge1xuICAgICAgICAgIHRpdGxlOiB0ZXh0KGNhdGVnb3J5KSxcbiAgICAgICAgICBjb2xvcjogY2F0ZWdvcnkuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xuICAgICAgbGV0IGRhdGFFbnR5ID0ge1xuICAgICAgICB0aXRsZTogdGV4dChpdGVtKSxcbiAgICAgICAgY2xhc3M6IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGFzc1wiKSxcbiAgICAgICAgdmFsdWVzOiBbXVxuICAgICAgfVxuXG4gICAgICBsZXQgdmFscyA9IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgaWYgKHZhbHMpIHtcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHMuc3BsaXQoXCIsXCIpKSB7XG4gICAgICAgICAgZGF0YUVudHkudmFsdWVzLnB1c2gocGFyc2VGbG9hdCh2YWwpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRhdGEuaXRlbXMucHVzaChkYXRhRW50eSlcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgX2dldFRvb2x0aXBDb250ZW50KGVudHJ5LCBjYXRlZ29yaWVzKSB7XG4gICAgbGV0IHRvb2x0aXAgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyeS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvb2x0aXAgKz0gYCR7Y2F0ZWdvcmllc1tpXS50aXRsZX06ICR7ZW50cnkudmFsdWVzW2ldfSAke3RoaXMuX3VuaXR9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwLnRyaW0oKVxuICB9XG5cbiAgX3JlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpXG5cbiAgICAgIGZvciAobGV0IGNhdGVnb3J5IG9mIHRoaXMuX2RhdGEuY2F0ZWdvcmllcykge1xuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kSXRlbShjYXRlZ29yeSlcbiAgICAgICAgdGhpcy5fbGVnZW5kLmFwcGVuZENoaWxkKGxlZ2VuZEl0ZW0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fY2hhcnQpXG5cbiAgICBsZXQgYW5pbWF0aW9uU3RhZ2VzID0gW11cblxuICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fZGF0YS5pdGVtcykge1xuICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG5cbiAgICAgIGlmIChpdGVtLmNsYXNzICYmIGl0ZW0uY2xhc3MgIT09IFwiXCIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhpdGVtLmNsYXNzKVxuICAgICAgfVxuXG4gICAgICBsZXQgbGlzdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInVsXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUilcblxuICAgICAgbGV0IHdyYXBwZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0lOTkVSX1dSQVBQRVIpXG4gICAgICBsaXN0RWxlbWVudC5hcHBlbmRDaGlsZCh3cmFwcGVyKVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpc3RFbGVtZW50KVxuXG4gICAgICBsZXQgdG9vbHRpcCA9IHRoaXMuX2dldFRvb2x0aXBDb250ZW50KGl0ZW0sIHRoaXMuX2RhdGEuY2F0ZWdvcmllcylcbiAgICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAgIT09IFwiXCIpIHtcbiAgICAgICAgd3JhcHBlclxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQX1JJR0hUKVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRvb2x0aXApXG5cbiAgICAgICAgaWYgKGl0ZW0udmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB3cmFwcGVyLmFkZENsYXNzKENMQVNTX1RPT0xUSVBfTVVMVElMSU5FKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gKHRoaXMuX2NoYXJ0Lm9mZnNldEhlaWdodCAvIHRoaXMuX21heFZhbHVlKSAqIGl0ZW0udmFsdWVzW2ldXG5cbiAgICAgICAgbGV0IGluZGljYXRvciA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgaGVpZ2h0OiAke2hlaWdodH1weDtgKVxuXG4gICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5fZGF0YS5jYXRlZ29yaWVzW2ldLmNvbG9yXG4gICAgICAgICAgaWYgKGlzQ29sb3IoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9O2ApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGljYXRvci5hZGRDbGFzcyhjb2xvcilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW9uU3RhZ2VzLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICBhbmltYXRpb25TdGFnZXMucHVzaChbXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltYXRpb25TdGFnZXNbaV0ucHVzaChpbmRpY2F0b3IuZWxlbWVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0VNUFRZKVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0xBQkVMX1gpXG4gICAgICAgIC5zZXRIdG1sKGl0ZW0udGl0bGUpKVxuXG4gICAgICB0aGlzLl9jaGFydC5hcHBlbmRDaGlsZChlbGVtZW50LmVsZW1lbnQpXG4gICAgfVxuXG4gICAgbGV0IHRsID0gbmV3IFRpbWVsaW5lTGl0ZSgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmltYXRpb25TdGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRsLmZyb20oYW5pbWF0aW9uU3RhZ2VzW2ldLCBBTklNQVRJT05fRFVSQVRJT04sIHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZUluT3V0LFxuICAgICAgICBhdXRvUm91bmQ6IGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICAgIHRsLmZyb20odGhpcy5fbGVnZW5kLmNoaWxkcmVuW2ldLCBBTklNQVRJT05fRFVSQVRJT04sIHtcbiAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXRcbiAgICAgICAgfSwgYC09JHtBTklNQVRJT05fRFVSQVRJT059YClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmFyIGNoYXJ0IHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIGRlZmluaXRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIGJhciBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgdXBkYXRlKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuICAgICAgdGhpcy5fbGVnZW5kID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmJhci1jaGFydC12ZXJ0aWNhbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBCYXJDaGFydFZlcnRpY2FsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhckNoYXJ0VmVydGljYWxcbiIsImltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHRleHQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfREFUQSA9IFwiLmpzLWRhdGFcIlxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5R2V0RGF0YShlbGVtZW50KSB7XG4gIGxldCBkYXRhID0gW11cbiAgbGV0IGVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEEpXG5cbiAgZm9yIChsZXQgZW50cnkgb2YgZWxlbWVudHMpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZUZsb2F0KGVudHJ5LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikpXG4gICAgbGV0IGNvbG9yID0gZW50cnkuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKVxuICAgIGxldCB0aXRsZSA9IHRleHQoZW50cnkpXG5cbiAgICBsZXQgaXRlbSA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgdmFsdWUsXG4gICAgICBjb2xvclxuICAgIH1cblxuICAgIGRhdGEucHVzaChpdGVtKVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWdlbmRJdGVtKGRhdGEpIHtcbiAgY29uc3QgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgLmFkZENsYXNzKFwiYnVsbGV0XCIpXG5cbiAgaWYgKGlzQ29sb3IoZGF0YS5jb2xvcikgPT09IHRydWUpIHtcbiAgICBidWxsZXQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZGF0YS5jb2xvcn07YClcbiAgfSBlbHNlIHtcbiAgICBidWxsZXQuYWRkQ2xhc3MoZGF0YS5jb2xvcilcbiAgfVxuXG4gIGNvbnN0IGNhcHRpb24gPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAuc2V0SHRtbChkYXRhLnRpdGxlKVxuXG4gIHJldHVybiBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgLmFwcGVuZENoaWxkKGJ1bGxldClcbiAgICAuYXBwZW5kQ2hpbGQoY2FwdGlvbilcbiAgICAuZWxlbWVudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xvcihzdHIpIHtcbiAgY29uc3QgcGF0dGVybiA9IC9eIy9pXG4gIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyKVxufVxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyByZW1vdmVBbGxDaGlsZHJlbiwgdHJ5R2V0RGF0YSwgaXNDb2xvciB9IGZyb20gXCIuL0NoYXJ0RnVuY3Rpb25zXCJcbmltcG9ydCB7IFRpbWVsaW5lTGl0ZSwgUG93ZXI0IH0gZnJvbSBcImdzYXBcIlxuXG5jb25zdCBRVUVSWV9DSEFSVCA9IFwiLmpzLWNoYXJ0XCJcbmNvbnN0IFFVRVJZX0xFR0VORCA9IFwiLmpzLWxlZ2VuZFwiXG5cbmNvbnN0IERBU0hfU0VQQVJBVE9SX1dJRFRIID0gM1xuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OID0gMS41XG5cbmNvbnN0IFFVRVJZX01FVEFfVElUTEUgPSBcIi5tZXRhIC50aXRsZVwiXG5jb25zdCBRVUVSWV9NRVRBX1NVQlRJVExFID0gXCIubWV0YSAuc3VidGl0bGVcIlxuXG4vKipcbiAqIFBpZSBDaGFydCBDb21wb25lbnQuXG4gKi9cbmNsYXNzIFBpZUNoYXJ0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBQaWUgQ2hhcnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBjaGFydC5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBwaWUgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRhdGEgPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIHRoaXMuX2RhdGEgPSBkYXRhXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ0hBUlQpXG4gICAgdGhpcy5fbGVnZW5kID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTEVHRU5EKVxuICAgIHRoaXMuX3RpdGxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTUVUQV9USVRMRSlcbiAgICB0aGlzLl9zdWJ0aXRsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX01FVEFfU1VCVElUTEUpXG5cbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuXG4gICAgaWYgKCF0aGlzLl9kYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdHJ5R2V0RGF0YSh0aGlzLmVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIF9yZW5kZXIoKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApXG4gICAgY29uc3QgciA9IDE2XG4gICAgY29uc3QgZGFzaFRvdGFsID0gKDIgKiByICogTWF0aC5QSSlcblxuICAgIGxldCBjdXJyZW50Um90YXRlID0gOVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KVxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuICAgIH1cblxuICAgIGxldCB0bCA9IG5ldyBUaW1lbGluZUxpdGUoKVxuXG4gICAgbGV0IHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCA9IDBcbiAgICBsZXQgcGVyY2VudGFnZUFkanVzdCA9IDBcbiAgICBjb25zdCBzZXBhcmF0b3JQZXJjZW50YWdlID0gREFTSF9TRVBBUkFUT1JfV0lEVEggLyAxMDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9kYXRhW2ldXG5cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBlbnRyeS52YWx1ZSAvIHRvdGFsXG4gICAgICBpZiAocGVyY2VudGFnZSA8IHNlcGFyYXRvclBlcmNlbnRhZ2UpIHtcbiAgICAgICAgcGVyY2VudGFnZUFkanVzdFRvdGFsICs9IChzZXBhcmF0b3JQZXJjZW50YWdlIC0gcGVyY2VudGFnZSlcbiAgICAgICAgcGVyY2VudGFnZUFkanVzdCsrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBlcmNlbnRhZ2VBZGp1c3QgPiAwKSB7XG4gICAgICBwZXJjZW50YWdlQWRqdXN0ID0gcGVyY2VudGFnZUFkanVzdFRvdGFsIC8gKHRoaXMuX2RhdGEubGVuZ3RoIC0gcGVyY2VudGFnZUFkanVzdClcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fZGF0YVtpXVxuXG4gICAgICBjb25zdCBkaXNwbGF5UGVyY2VudGFnZSA9IGVudHJ5LnZhbHVlIC8gdG90YWxcbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSBNYXRoLm1heChzZXBhcmF0b3JQZXJjZW50YWdlLCBkaXNwbGF5UGVyY2VudGFnZSAtIHBlcmNlbnRhZ2VBZGp1c3QpXG5cbiAgICAgIGxldCBkYXNoV2lkdGggPSAocGVyY2VudGFnZSAqIGRhc2hUb3RhbCkgLSBEQVNIX1NFUEFSQVRPUl9XSURUSFxuXG4gICAgICBsZXQgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIDM0IDM0XCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBcInRpdGxlIGRlc2NcIilcblxuICAgICAgbGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJ0aXRsZVwiKVxuICAgICAgdGl0bGUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJ0aXRsZVwiKVxuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gYFBpZSBjaGFydCBzZWdtZW50ICR7TWF0aC5mbG9vcihkaXNwbGF5UGVyY2VudGFnZSAqIDEwMCkgfSVgXG5cbiAgICAgIGxldCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZGVzY1wiKVxuICAgICAgZGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJkZXNjXCIpXG4gICAgICBkZXNjcmlwdGlvbi5pbm5lckhUTUwgPSBgJHtlbnRyeS50aXRsZX06ICR7ZW50cnkudmFsdWV9YFxuXG4gICAgICBsZXQgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIilcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCAxNylcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCAxNylcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyXCIsIHIpXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBgJHtkYXNoV2lkdGh9ICR7ZGFzaFRvdGFsfWApXG5cbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInN0cm9rZS13aWR0aDogMFwiKVxuXG4gICAgICBpZiAoaXNDb2xvcihlbnRyeS5jb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBgJHtlbnRyeS5jb2xvcn1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGVudHJ5LmNvbG9yKVxuICAgICAgfVxuXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB0cmFuc2Zvcm06IHJvdGF0ZSgke2N1cnJlbnRSb3RhdGV9ZGVnKTtgKVxuXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQodGl0bGUpXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKVxuICAgICAgdGhpcy5fY2hhcnQuYXBwZW5kQ2hpbGQoc3ZnKVxuXG4gICAgICBsZXQgZHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04gICogcGVyY2VudGFnZVxuXG4gICAgICB0bC5zZXQoY2lyY2xlLCB7XG4gICAgICAgIGNsZWFyUHJvcHM6IFwic3Ryb2tlV2lkdGhcIlxuICAgICAgfSlcblxuICAgICAgaWYgKGNpcmNsZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgdGwuZnJvbShjaXJjbGUsIGR1cmF0aW9uLCB7XG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBcIjAuNSAxMDBcIixcbiAgICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgMTAgJiAxMSBmYWxsYmFjayBzaW5jZSBhbmltYXRpbmcgc3Ryb2tlLWRhc2hhcnJheSBkb2VzIG5vdCB3b3JrXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZG8gaXQgbWFudWFseVxuXG4gICAgICAgIGxldCBjb3VudGVyID0geyB2YXI6IDAuNSB9XG4gICAgICAgIHRsLnRvKGNvdW50ZXIsIGR1cmF0aW9uLCB7XG4gICAgICAgICAgdmFyOiBkYXNoV2lkdGgsXG4gICAgICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAke2NvdW50ZXIudmFyfSAke2Rhc2hUb3RhbH1gKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZWFzZTogUG93ZXI0LmVhc2VcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gTGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kICYmIHRoaXMuX2RhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICBsZXQgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgICAgLmFkZENsYXNzKFwiYnVsbGV0XCIpXG5cbiAgICAgICAgaWYgKGlzQ29sb3IoZW50cnkuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgYnVsbGV0LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke2VudHJ5LmNvbG9yfWApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVsbGV0LmFkZENsYXNzKGVudHJ5LmNvbG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNhcHRpb24gPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgICAuc2V0SHRtbChlbnRyeS50aXRsZSlcblxuICAgICAgICBsZXQgbGVnZW5kSXRlbSA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgICAgICAuYXBwZW5kQ2hpbGQoYnVsbGV0KVxuICAgICAgICAgIC5hcHBlbmRDaGlsZChjYXB0aW9uKVxuXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtLmVsZW1lbnQpXG5cbiAgICAgICAgdGwuZnJvbShsZWdlbmRJdGVtLmVsZW1lbnQsIGR1cmF0aW9uLCB7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICBlYXNlOiBQb3dlcjQuZWFzZUluT3V0XG4gICAgICAgIH0sIGAtPSR7ZHVyYXRpb259YClcbiAgICAgIH1cblxuICAgICAgY3VycmVudFJvdGF0ZSArPSAoMzYwICogcGVyY2VudGFnZSlcblxuICAgICAgaWYgKGkgPT09IHRoaXMuX2RhdGEubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSBgJHtlbnRyeS52YWx1ZX0gJHt0aGlzLl91bml0fWBcbiAgICAgICAgdGhpcy5fc3VidGl0bGUuaW5uZXJIVE1MID0gZW50cnkudGl0bGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGllIGNoYXJ0IHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIGRlZmluaXRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIHBpZSBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgdXBkYXRlKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RpdGxlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc3VidGl0bGUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl91bml0ID0gdW5kZWZpbmVkXG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9jaGFydClcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuICAgICAgdGhpcy5fbGVnZW5kID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLnBpZS1jaGFydFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQaWVDaGFydChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaWVDaGFydFxuIiwiaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgVHdlZW5MaXRlLCBQb3dlcjEsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IGFkZENsYXNzLCBoYXNDbGFzcywgcmVtb3ZlQ2xhc3MsIGlzSGlkZGVuIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDAuM1xuXG4vKipcbiAqIFRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gKi9cbmNsYXNzIENvbGxhcHNlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IGRhdGFUYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIilcbiAgICBpZiAoZGF0YVRhcmdldCA9PT0gbnVsbCB8fCBkYXRhVGFyZ2V0ID09PSBcIlwiKSB7XG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIGNvbGxhcHNpYmxlIGVsZW1lbnQgcmVxdWlyZXMgYSAnZGF0YS10YXJnZXQnIHRoYXQgc3BlY2lmaWVzIHRoZSBlbGVtZW50IHRvIGNvbGxhcHNlXCIpXG4gICAgICBjb25zb2xlLmluZm8odGhpcy5lbGVtZW50KVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBoaWRkZW5UYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1oaWRkZW5cIilcbiAgICBpZiAoaGlkZGVuVGFyZ2V0ICE9PSBudWxsICYmIGhpZGRlblRhcmdldCAhPT0gXCJcIikge1xuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoaWRkZW5UYXJnZXQpXG4gICAgfVxuXG4gICAgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YVRhcmdldClcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgfVxuXG4gIF9oYW5kbGVDbGljayhldmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBjb2xsYXBzZWlibGUuXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cykge1xuICAgICAgICB0aGlzLl9vcGVuQ29sbGFwc2UocylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuXG4gICAgICBmb3IgKGxldCBzIG9mIHRoaXMuX2NvbGxhcHNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VDb2xsYXBzZShzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9vcGVuQ29sbGFwc2UoZWwpIHtcbiAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKGVsKVxuXG4gICAgVHdlZW5MaXRlLnNldChlbCwge1xuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSlcblxuICAgIFR3ZWVuTGl0ZS50byhlbCwgQU5JTUFUSU9OX09QRU4sIHtcbiAgICAgIGNsYXNzTmFtZTogYCs9JHtDTEFTU19PUEVOfWAsXG4gICAgICBlYXNlOiBbXG4gICAgICAgIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0XG4gICAgICBdXG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0cnVlKVxuICB9XG5cbiAgX2Nsb3NlQ29sbGFwc2UoZWwpIHtcbiAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKGVsKVxuXG4gICAgVHdlZW5MaXRlLnRvKGVsLCBBTklNQVRJT05fT1BFTiwge1xuICAgICAgY2xhc3NOYW1lOiBgLT0ke0NMQVNTX09QRU59YCxcbiAgICAgIGVhc2U6IFtcbiAgICAgICAgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXRcbiAgICAgIF0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIFR3ZWVuTGl0ZS5zZXQoZWwsIHtcbiAgICAgICAgICBjbGVhclByb3BzOiBcImRpc3BsYXlcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBzZXQgYXJpYSBleHBhbmRlZFxuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jb2xsYXBzaWJsZUVsZW1lbnRzID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuX2NsaWNrSGFuZGxlcikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRvZ2dsZT0nY29sbGFwc2UnXVwiKVxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbml0XCIpID09PSBcImF1dG9cIikge1xuICAgICAgbmV3IENvbGxhcHNlKGUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHBhcmVudFdpdGhDbGFzcywgZ2V0Um9vdEVsZW1lbnQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgQ0xBU1NfQk9SREVSID0gXCJlbXB0eS1zdGF0ZV9fYm9yZGVyXCJcbmNvbnN0IENMQVNTX0JPUkRFUl9NT0RBTCA9IFwiZW1wdHktc3RhdGVfX2JvcmRlci0tbW9kYWxcIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfSEFTRklMRVMgPSBcImhhcy1maWxlc1wiXG5jb25zdCBDTEFTU19NT0RBTCA9IFwiZW1wdHktc3RhdGUtLW1vZGFsXCJcbmNvbnN0IENMQVNTX01PREFMX0NPTlRFTlQgPSBcIm1vZGFsX19jb250ZW50XCJcblxuY29uc3QgUVVFUllfTU9EQUxfQk9EWSA9IFwiLm1vZGFsX19ib2R5XCJcbmNvbnN0IFFVRVJZX0ZJTEUgPSBcImlucHV0W3R5cGU9J2ZpbGUnXVwiXG5cbi8qKlxuICogRW1wdHkgc3RhdGUgcGF0dGVyblxuICovXG5jbGFzcyBFbXB0eVN0YXRlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBFbXB0eS1TdGF0ZSBwYXR0ZXJuIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIHJvb3QgZWxlbWVudCBvZiB0aGUgZW1wdHktc3RhdGUgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fYm9yZGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19CT1JERVIpXG5cbiAgICB0aGlzLl9maWxlSW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9GSUxFKVxuICAgIHRoaXMuX2J1dHRvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwibGFiZWxcIilcblxuICAgIHRoaXMuX2ZpbGVDaGFuZ2VkSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlciA9IHRoaXMuX3ByZXZlbnREcmFnRXZlbnRzLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnRW50ZXJIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0VudGVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJhZ0xlYXZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9kcm9wSGFuZGxlciA9IHRoaXMuX2hhbmRsZURyb3AuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGlmICh0aGlzLmhhc0NsYXNzKENMQVNTX01PREFMKSkge1xuICAgICAgLy8gaGFuZGxlIG1vZGFsIGRpYWxvZ3NcbiAgICAgIHRoaXMuX2RyYWdBcmVhID0gcGFyZW50V2l0aENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfTU9EQUxfQ09OVEVOVClcbiAgICAgIGxldCBib3JkZXJBcmVhID0gdGhpcy5fZHJhZ0FyZWEucXVlcnlTZWxlY3RvcihRVUVSWV9NT0RBTF9CT0RZKVxuICAgICAgYm9yZGVyQXJlYS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvaW50ZXItZXZlbnRzOiBub25lO1wiKVxuXG4gICAgICB0aGlzLl9ib3JkZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSX01PREFMKVxuXG4gICAgICBib3JkZXJBcmVhLmFwcGVuZENoaWxkKHRoaXMuX2JvcmRlci5lbGVtZW50KVxuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9ybWFsIG1vZGFsIGRpYWxvZ1xuICAgICAgdGhpcy5fZHJhZ0FyZWEgPSB0aGlzLmVsZW1lbnRcbiAgICAgIGxldCBib3JkZXJBcmVhID0gZ2V0Um9vdEVsZW1lbnQoKVxuXG4gICAgICBpZiAoIWJvcmRlckFyZWEucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfQk9SREVSfWApKSB7XG4gICAgICAgIGJvcmRlckFyZWEuYXBwZW5kQ2hpbGQodGhpcy5fYm9yZGVyLmVsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVwiKVxuXG4gICAgZm9yIChsZXQgZXZlbnQgb2YgW1wiZHJhZ1wiLCBcImRyYWdzdGFydFwiLCBcImRyYWdlbmRcIiwgXCJkcmFnb3ZlclwiLCBcImRyYWdlbnRlclwiLCBcImRyYWdsZWF2ZVwiLCBcImRyb3BcIl0pIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5fcHJldmVudEV2ZW50c0hhbmRsZXIpXG4gICAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5fZHJhZ0VudGVySGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VudGVyXCIsIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIpXG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIpXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyKVxuXG4gICAgdGhpcy5fZHJhZ0FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5fZHJvcEhhbmRsZXIpXG4gICAgdGhpcy5fZmlsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5fZmlsZUNoYW5nZWRIYW5kbGVyKVxuICB9XG5cbiAgX3ByZXZlbnREcmFnRXZlbnRzKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIF9oYW5kbGVEcmFnRW50ZXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSB0cnVlXG4gICAgdGhpcy5fYnV0dG9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9pbnRlci1ldmVudHM6IG5vbmU7XCIpXG5cbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgICB0aGlzLl9ib3JkZXIuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgX2hhbmRsZURyYWdMZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2J1dHRvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gICAgdGhpcy5fYm9yZGVyLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIF9oYW5kbGVEcm9wKGUpIHtcbiAgICB0aGlzLl9maWxlSW5wdXQuZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xuICB9XG5cbiAgX2hhbmRsZUZpbGVDaGFuZ2VkKCkge1xuICAgIGxldCBmaWxlcyA9IHRoaXMuX2ZpbGVJbnB1dC5maWxlc1xuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfSEFTRklMRVMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBmaWxlcy5cbiAgICovXG4gIGdldCBmaWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZUlucHV0LmZpbGVzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuZW1wdHktc3RhdGVcIiwgKGUpID0+IHtcbiAgICBuZXcgRW1wdHlTdGF0ZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbXB0eVN0YXRlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBlbXB0eSwgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCBoYXNDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuXG5jb25zdCBRVUVSWV9EUk9QRE9XTiA9IFwiLmpzLWF1dG9jb21wbGV0ZVwiXG5jb25zdCBDTEFTU19SRVNVTFQgPSBcImF1dG9jb21wbGV0ZV9fcmVzdWx0XCJcbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfSE9WRVIgPSBcImpzLWhvdmVyXCJcbmNvbnN0IEFUVFJJQlVURV9WQUxVRSA9IFwiZGF0YS12YWx1ZVwiXG5cbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAqL1xuY2xhc3MgQXV0b2NvbXBsZXRlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IgKGVsZW1lbnQsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpXG4gICAgdGhpcy5fZHJvcGRvd24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9EUk9QRE9XTilcblxuICAgIC8vIFNldHVwIGV2ZW50IGNvbnRleHRcbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5VXBIYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5VXAuYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlQmx1ci5iaW5kKHRoaXMpXG5cbiAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSBjb25maWd1cmF0aW9uLm1pbkNoYXJzXG4gICAgICB0aGlzLl9zb3VyY2UgPSBjb25maWd1cmF0aW9uLnNvdXJjZVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWluQ2hhcnMgfHwgdGhpcy5fbWluQ2hhcnMgPCAwKSB7XG4gICAgICB0aGlzLl9taW5DaGFycyA9IDJcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2NsZWFyU3VnZ2VzdGlvbnMoKVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBicm93c2VyIGF1dG9maWxsXG4gICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpXG4gIH1cblxuLyoqXG4gKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQGNhbGxiYWNrIEF1dG9jb21wbGV0ZX5TdWdnZXN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdGVybSAtIFRoZSBjdXJyZW50IHNlYXJjaCB0ZXJtLlxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gbWF0Y2hlcyAtIFRoZSBsaXN0IG9mIG1hdGNoaW5nIHN0cmluZ3MuXG4gKi9cblxuLyoqXG4gKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQGNhbGxiYWNrIEF1dG9jb21wbGV0ZX5Tb3VyY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXJtIC0gVGhlIGN1cnJlbnQgc2VhcmNoIHRlcm0uXG4gKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5TdWdnZXN0fSBzdWdnZXN0IC0gVGhlIGF1dG9jb21wbGV0ZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZXBvcnQgdGhlIHJlc3VsdHMuXG4gKi9cblxuLyoqXG4gKiBUaGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIG9iamVjdFxuICogQHR5cGVkZWYge09iamVjdH0gQXV0b2NvbXBsZXRlfkNvbmZpZ1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pbkNoYXJzIC0gVGhlIG1pbmltYWwgcmVxdWlyZWQgY2hhcmFjdGVycyB0byBzdGFydCBxdWVyeWluZyBmb3IgYXV0b2NvbXBsZXRlIG1hdGNoZXMuXG4gKiBAcHJvcGVydHkge0F1dG9jb21wbGV0ZX5Tb3VyY2V9IHNvdXJjZSAtIFRoZSBhdXRvY29tcGxldGUgc291cmNlIGZ1bmN0aW9uLlxuICovXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgYXV0b2NvbXBsZXRlIGNvbXBvbmVudCBjb25maWd1cmF0aW9uIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtBdXRvY29tcGxldGV+Q29uZmlnfSBjb25maWd1cmF0aW9uIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG4gIGNvbmZpZ3VyZShjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKCFjb25maWd1cmF0aW9uKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5taW5DaGFycykge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSBNYXRoLm1pbihjb25maWd1cmF0aW9uLm1pbkNoYXJzLCAxKVxuICAgIH1cblxuICAgIGlmIChjb25maWd1cmF0aW9uLnNvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlID0gY29uZmlndXJhdGlvbi5zb3VyY2VcbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhclN1Z2dlc3Rpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2tleVVwSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3QgY29udHJvbCB0byB0aGUgZGlzYWJsZWQgc3RhdGUuXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lucHV0LmFkZEF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5VXBIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpXG5cbiAgICB0aGlzLl9rZXlVcEhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBzdWdnZXN0aW9ucyBkcm9wZG93bi5cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5fZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBzdWdnZXN0aW9ucyBkcm9wZG93bi5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuX2Ryb3Bkb3duLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIF9oYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY3VycmVudCA9IGV2ZW50LnRhcmdldFxuICAgIHdoaWxlIChjdXJyZW50Lm5vZGVOYW1lICE9PSBcIkxJXCIgJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQubm9kZU5hbWUgPT09IFwiTElcIikge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICB0aGlzLl9zZWxlY3RJdGVtKGN1cnJlbnQpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJsdXIoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9LCBUSU1FT1VUX0JMVVIpXG4gIH1cblxuICBfaGFuZGxlS2V5VXAoZXZlbnQpIHtcbiAgICBsZXQgZXZ0ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50XG4gICAgbGV0IGtleWNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG4gICAgY29uc3QgaXNPcGVuID0gaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFICYmIGlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZ0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzT3BlbiA9PT0gdHJ1ZSAmJiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04pKSB7XG4gICAgICAvLyBVcCBhbmQgZG93biBhcnJvd3NcblxuICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fc3VnZ2VzdGlvbkxpc3QucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSE9WRVJ9YClcbiAgICAgIGlmIChmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICByZW1vdmVDbGFzcyhmb2N1c2VkRWxlbWVudCwgQ0xBU1NfSE9WRVIpXG5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBuZXcgQXJyYXkoLi4udGhpcy5fc3VnZ2VzdGlvbkxpc3QuY2hpbGROb2RlcylcblxuICAgICAgICBjb25zdCB0b3RhbE5vZGVzID0gY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQID8gLTEgOiAxXG5cbiAgICAgICAgbGV0IGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihmb2N1c2VkRWxlbWVudClcblxuICAgICAgICBpbmRleCA9IE1hdGgubWF4KE1hdGgubWluKGluZGV4ICsgZGlyZWN0aW9uLCB0b3RhbE5vZGVzKSwgMClcbiAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSB0aGlzLl9zdWdnZXN0aW9uTGlzdC5jaGlsZE5vZGVzW2luZGV4XVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKVxuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhmb2N1c2VkRWxlbWVudCwgQ0xBU1NfSE9WRVIpXG4gICAgICBwcmV2ZW50RGVmYXVsdChldnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNPcGVuID09PSB0cnVlICYmIGtleWNvZGUgPT09IElucHV0cy5LRVlfRU5URVIpIHtcbiAgICAgIGxldCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoYC4ke0NMQVNTX0hPVkVSfWApXG5cbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW0oZm9jdXNlZEVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZ0LmN1cnJlbnRUYXJnZXQgJiYgZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUgJiYgZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUubGVuZ3RoID49IHRoaXMuX21pbkNoYXJzKSB7XG4gICAgICB0aGlzLl9nZXRTdWdnZXN0aW9uKGV2dC5jdXJyZW50VGFyZ2V0LnZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIF9zZWxlY3RJdGVtKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBpdGVtLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfVkFMVUUpXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdGV4dFxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgX2lzRHJvcGRvd25UYXJnZXQodGFyZ2V0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXRcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gdGhpcy5fZHJvcGRvd24gJiYgY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuX2Ryb3Bkb3duXG4gIH1cblxuICBfY2xlYXJTdWdnZXN0aW9ucygpIHtcbiAgICAvLyBDbGVhciB0aGUgZHJvcGRvd24gaXRlbVxuICAgIGVtcHR5KHRoaXMuX2Ryb3Bkb3duKVxuXG4gICAgdGhpcy5fc3VnZ2VzdGlvbkxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIilcbiAgICB0aGlzLl9kcm9wZG93bi5hcHBlbmRDaGlsZCh0aGlzLl9zdWdnZXN0aW9uTGlzdClcbiAgfVxuXG4gIF9hZGRTdWdnZXN0aW9uKHRleHQsIHRlcm0pIHtcbiAgICBjb25zdCBodG1sID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke3Rlcm19KWAsIFwiZ2lcIiksIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiKVxuXG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgIC5zZXRIdG1sKGh0bWwpXG5cbiAgICBjb25zdCBpbm5lckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1JFU1VMVClcbiAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudClcblxuICAgIGNvbnN0IGxpRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoQVRUUklCVVRFX1ZBTFVFLCB0ZXh0KVxuICAgICAgLmFwcGVuZENoaWxkKGlubmVyRWxlbWVudClcblxuICAgIHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmFwcGVuZENoaWxkKGxpRWxlbWVudC5lbGVtZW50KVxuICB9XG5cbiAgX2dldFN1Z2dlc3Rpb24odGVybSkge1xuICAgIGlmICghdGhpcy5fc291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc291cmNlIGZ1bmN0aW9uIGlzIHVuZGVmaW5lZCwgY2Fubm90IGxvYWQgc3VnZ2VzdGlvbnNcIilcbiAgICB9XG5cbiAgICB0aGlzLl9zb3VyY2UodGVybSwgKG1hdGNoZXMsIHRlcm11c2VkKSA9PiB7XG4gICAgICB0aGlzLl9vbk1hdGNoZXNSZWNlaXZlZChtYXRjaGVzLCB0ZXJtdXNlZClcbiAgICB9KVxuICB9XG5cbiAgX29uTWF0Y2hlc1JlY2VpdmVkKG1hdGNoZXMsIHRlcm0pIHtcbiAgICB0aGlzLl9jbGVhclN1Z2dlc3Rpb25zKClcblxuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIHRoZSBkcm9wZG93biBpdGVtXG4gICAgICBlbXB0eSh0aGlzLl9zdWdnZXN0aW9uTGlzdClcblxuICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICB0aGlzLl9hZGRTdWdnZXN0aW9uKG1hdGNoLCB0ZXJtKVxuICAgICAgfVxuXG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5pbnB1dC1maWVsZC0tYXV0b2NvbXBsZXRlXCIsIChlKSA9PiB7XG4gICAgbmV3IEF1dG9jb21wbGV0ZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdXRvY29tcGxldGVcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX0hBU19WQUxVRSA9IFwiaXMtZml4ZWRcIlxuY29uc3QgQ0xBU1NfTUVTU0FHRSA9IFwiLm1lc3NhZ2VcIlxuXG4vKipcbiAqIElucHV0IGZpZWxkIGNvbXBvbmVudFxuICovXG5jbGFzcyBJbnB1dEZpZWxkIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IgKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2hhbmdlZEhhbmRsZXIgPSB0aGlzLm9uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB0aGlzLl9vbkFuaW1hdGlvblN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW5wdXQgZmllbGQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl9jaGFuZ2VkSGFuZGxlcilcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIHRoaXMuX2FuaW1hdGlvblN0YXJ0SGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIF9vbkFuaW1hdGlvblN0YXJ0KGUpIHtcbiAgICBpZiAoZS5hbmltYXRpb25OYW1lID09PSBcIm9uQXV0b0ZpbGxTdGFydFwiKSB7XG4gICAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBpbnB1dCBmaWVsZCBjb21wb25lbnQgdGhhdCBpdCdzIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAqL1xuICBvblZhbHVlQ2hhbmdlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSAmJiB0aGlzLmVsZW1lbnQudmFsdWUgIT09IFwiXCIgfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfSEFTX1ZBTFVFKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0hBU19WQUxVRSlcbiAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IFwiXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgZnJlZXMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy5fY2hhbmdlZEhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwicGFzc3dvcmRcIikge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbmdlZEhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5cyB0aGUgc3BlY2lmaWVkIGVycm9yIHRleHQgdW5kZXJuZWF0aCB0aGUgaW5wdXQgZmllbGQuXG4gICAqIEBwYXJhbSB7dGV4dH0gdGV4dCBUaGUgZXJyb3IgdGV4dC9odG1sIHRvIGRpc3BsYXk7IG9yIHVuZGVmaW5lZCB0byBoaWRlIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgc2hvd0Vycm9yKHRleHQpIHtcbiAgICBsZXQgbWVzc2FnZVxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgbGV0IG1zZyA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoQ0xBU1NfTUVTU0FHRSlcblxuICAgICAgaWYgKG1zZykge1xuICAgICAgICBtZXNzYWdlID0gbmV3IERvbUVsZW1lbnQobXNnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dCB8fCB0ZXh0ID09PSBcIlwiKSB7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICByZW1vdmUobWVzc2FnZS5lbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKFwiaW52YWxpZFwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcyhcImludmFsaWRcIilcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhcIm1lc3NhZ2VcIilcblxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZS5lbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmVtcHR5KClcbiAgICB9XG5cbiAgICBjb25zdCBpY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyNi1leGNsYW1hdGlvbi1tYXJrLWNpcmNsZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpXG5cbiAgICBjb25zdCBtc2cgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgIC5zZXRIdG1sKHRleHQpXG5cbiAgICBtZXNzYWdlLmFwcGVuZENoaWxkKGljb24pXG4gICAgbWVzc2FnZS5hcHBlbmRDaGlsZChtc2cpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuaW5wdXQtZmllbGQgaW5wdXRcIiwgKGUpID0+IHtcbiAgICBuZXcgSW5wdXRGaWVsZChlKVxuICB9LCAoZSkgPT4gZS5wYXJlbnRFbGVtZW50KVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEZpZWxkXG4iLCJpbXBvcnQgeyBUd2VlbkxpdGUsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcblxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgY2xhbXAsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgTUFSR0lOX1RJQ0sgPSAzMlxuY29uc3QgQ0xBU1NfSFRNTDUgPSBcImh0bWw1XCJcbmNvbnN0IFJBTkdFX0xJR0hUID0gXCJyYW5nZS0tbGlnaHRcIlxuXG5jb25zdCBDTEFTU19DT05UQUlORVIgPSBcInJhbmdlLWNvbnRhaW5lclwiXG5jb25zdCBDTEFTU19TTElERVIgPSBcInJhbmdlLXNsaWRlclwiXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcInJhbmdlLS1hY3RpdmVcIlxuXG5jb25zdCBDTEFTU19UUkFDSyA9IFwicmFuZ2UtdHJhY2tcIlxuY29uc3QgQ0xBU1NfVFJBQ0tfUFJPR1JFU1MgPSBcInJhbmdlLXRyYWNrX19wcm9ncmVzc1wiXG5cbmNvbnN0IENMQVNTX1RJQ0sgPSBcInJhbmdlLXRpY2tcIlxuY29uc3QgQ0xBU1NfVElDS19MQUJFTCA9IFwicmFuZ2UtdGlja19fbGFiZWxcIlxuY29uc3QgQ0xBU1NfVElDS19BQ1RJVkUgPSBcInJhbmdlLXRpY2stLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX1RIVU1CID0gXCJyYW5nZS10aHVtYlwiXG5jb25zdCBDTEFTU19USFVNQl9WQUxVRSA9IFwicmFuZ2UtdGh1bWJfX3ZhbHVlXCJcbmNvbnN0IENMQVNTX0RJU0FCTEVEID0gXCJyYW5nZS0tZGlzYWJsZWRcIlxuXG5jb25zdCBDTEFTU19EUkFHR0lORyA9IFwicmFuZ2UtLWRyYWdnaW5nXCJcblxuLyoqXG4gKiBUaGUgcmFuZ2Ugc2xpZGVyIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgLy8gU2V0dXAgZXZlbnQgY29udGV4dFxuICAgIHRoaXMuX2Rvd25IYW5kZXIgPSB0aGlzLl9oYW5kbGVEb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9tb3ZlSGFuZGxlciA9IHRoaXMuX2hhbmRsZU1vdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuX2VuZEhhbmRlciA9IHRoaXMuX2hhbmRsZUVuZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUJsdXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSB0aGlzLmxheW91dC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHJhbmdlIHNsaWRlciBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGluc3BlY3RzIHRoZSBzZWxlY3QgZGVmaW5pdGlvbiBhbmQgaXRzIG9wdGlvbnMgYW5kXG4gICAqIGdlbmVyYXRlcyBuZXcgc3R5bGFibGUgRE9NIGVsZW1lbnRzIGFyb3VuZCB0aGUgb3JpZ2luYWwgcmFuZ2UgaW5wdXQtZWxlbWVudFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuXG4gICAgaWYgKHRoaXMuaGFzQ2xhc3MoQ0xBU1NfSFRNTDUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgdXNlcyBIVE1MNSBzdHlsaW5nLCBkbyBub3QgdG91Y2ggaXQuLi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQ09OVEFJTkVSKVxuXG4gICAgdGhpcy5fcmFuZ2VUcmFjayA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfVFJBQ0spXG5cbiAgICAvLyBjaGVjayBpZiByYW5nZS0tbGlnaHQgc2xpZGVyIHRoZW4gYWRkIHByb2dyZXNzXG4gICAgaWYgKHRoaXMuX3dyYXBwZXJFbGVtZW50Lmhhc0NsYXNzKFJBTkdFX0xJR0hUKSkge1xuICAgICAgdGhpcy5fcmFuZ2VQcm9ncmVzcyA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UUkFDS19QUk9HUkVTUylcblxuICAgICAgdGhpcy5fcmFuZ2VUcmFjay5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVByb2dyZXNzKVxuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlVGh1bWIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgdGhpcy5fdGlja3NXcmFwcGVyID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19TTElERVIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVRyYWNrKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3RpY2tzV3JhcHBlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVRodW1iKVxuXG4gICAgLy8gYWRkIGNvbnRhaW5lciB0byB3cmFwcGVyXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VDb250YWluZXIpXG5cbiAgICAvLyBnZXQgbWluICYgbWF4IGRlZmluaXRpb25zXG4gICAgdGhpcy5fbWluVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5taW4pIHx8IDBcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50Lm1heCkgfHwgMVxuXG4gICAgLy8gZ2V0IHRoZSBsYWJlbC9vdXRwdXQgZm9ybWF0IHN0cmluZ1xuICAgIHRoaXMuX2Zvcm1hdHRlciA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZShcImZvcm1hdHRlclwiKV1cblxuICAgIC8vIGdldCB0aGUgb3V0cHV0IGxhYmVsIGFuZCBtb3ZlIGl0IGJlbG93IHRoZSBjb250YWluZXJcbiAgICBpZiAodGhpcy5lbGVtZW50LmlkKSB7XG4gICAgICB0aGlzLl9vdXRwdXRMYWJlbCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmZpbmQoYG91dHB1dFtmb3I9JyR7dGhpcy5lbGVtZW50LmlkfSddYClcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX291dHB1dExhYmVsKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5lbGVtZW50LnN0ZXApIHtcbiAgICAgIC8vIGZpeCBpc3N1ZXMgd2l0aCBmbG9hdCBzbGlkZXJzIGlmIHRoZSBzdGVwIGlzIHVuZGVmaW5lZFxuICAgICAgdGhpcy5lbGVtZW50LnN0ZXAgPSBcImFueVwiXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KClcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX2FkZFRpY2tzKG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS19MQUJFTH1gKS5sZW5ndGggPD0gMSkge1xuICAgICAgdGhpcy5fdGh1bWJWYWx1ZSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQl9WQUxVRSlcblxuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYlZhbHVlKVxuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrVmFsdWVUb3RhbCA9IHRoaXMuX21heFZhbHVlIC0gdGhpcy5fbWluVmFsdWVcbiAgICB0aGlzLmxheW91dCgpXG5cbiAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIF9nZXRPcHRpb25zTGlzdCgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdXG5cbiAgICBsZXQgbGlzdElkID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJsaXN0XCIpXG4gICAgaWYgKGxpc3RJZCkge1xuICAgICAgbGV0IGRhdGFMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7bGlzdElkfWApXG4gICAgICBpZiAoZGF0YUxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgZGF0YUxpc3QucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvblwiKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoZW50cnkuaW5uZXJUZXh0KVxuICAgICAgICAgIGxldCBsYWJlbCA9IGVudHJ5LmdldEF0dHJpYnV0ZShcImxhYmVsXCIpIHx8IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgyKSlcblxuICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvcnQgdGhlIGxpc3QgdG8gZW5hYmxlIHNuYXBwaW5nXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpXG5cbiAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9taW5WYWx1ZSA9IE51bWJlci5NQVhfVkFMVUVcbiAgICAgIHRoaXMuX21heFZhbHVlID0gTnVtYmVyLk1JTl9WQUxVRVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbWluVmFsdWUgPSBNYXRoLm1pbih0aGlzLl9taW5WYWx1ZSwgb3B0aW9uc1tpXS52YWx1ZSlcbiAgICAgICAgdGhpcy5fbWF4VmFsdWUgPSBNYXRoLm1heCh0aGlzLl9tYXhWYWx1ZSwgb3B0aW9uc1tpXS52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgX2FkZFRpY2tzKGRhdGFJdGVtcykge1xuICAgIGZvciAobGV0IGVudHJ5IG9mIGRhdGFJdGVtcykge1xuICAgICAgbGV0IHRpY2tFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgZW50cnkudmFsdWUpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLKVxuXG4gICAgICBsZXQgdGlja0xhYmVsID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLX0xBQkVMKVxuICAgICAgICAuc2V0SHRtbChlbnRyeS5sYWJlbC50b1N0cmluZygpKVxuXG4gICAgICB0aWNrRWxlbWVudC5hcHBlbmRDaGlsZCh0aWNrTGFiZWwpXG4gICAgICB0aGlzLl90aWNrc1dyYXBwZXIuYXBwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfVElDS19MQUJFTClcbiAgfVxuXG4gIF9oYW5kbGVEb3duKGV2ZW50KSB7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRFJBR0dJTkcpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fZW5kSGFuZGVyKVxuXG4gICAgLy8gSWdub3JlIGNsaWNrcyBkaXJlY3RseSBvbiB0aGUgdGh1bWJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQgJiYgIXRoaXMuX2lzRXZlbnRPbkxhYmVsKGV2ZW50KSkge1xuICAgICAgbGV0IHBvcyA9IHRoaXMuX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQpXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3MsIHRydWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTW92ZShldmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMuX3VuZm9jdXMoKVxuXG4gICAgaWYgKCF0aGlzLl9pc0V2ZW50T25MYWJlbChldmVudCkpIHtcbiAgICAgIGxldCBwb3MgPSB0aGlzLl9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50KVxuICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zLCB0cnVlLCBmYWxzZSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUVuZChldmVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RSQUdHSU5HKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGVyKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2VuZEhhbmRlcilcblxuICAgIGxldCBwb3MgPSB0aGlzLl9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50KVxuICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICB0aGlzLl9oYW5kbGVCbHVyKClcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgbGV0IGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYmx1cigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1VwID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUXG4gICAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX1VQXG5cbiAgICBjb25zdCBpc0Rvd24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04gfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19MRUZUXG4gICAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX0RPV05cblxuICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcblxuICAgICAgbGV0IGRpcmVjdGlvbiA9IGlzRG93biA/IC0xIDogMVxuXG4gICAgICAvLyBtYWtlIGEgbGFyZ2VyIHN0ZXAgaWYgaXRzIHRoZSB2ZXJ0aWNhbCBhcnJvdyBvciBwYWdlIGtleXNcbiAgICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTiB8fFxuICAgICAga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9ET1dOKSB7XG4gICAgICAgIGRpcmVjdGlvbiAqPSAxMFxuICAgICAgfVxuXG4gICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVxuICAgICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLl9nZXROZXh0VmFsdWUodmFsLCBkaXJlY3Rpb24pXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxldCBzdGVwID0gdGhpcy5lbGVtZW50LnN0ZXBcbiAgICAgICAgaWYgKCFzdGVwIHx8IHN0ZXAgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICBzdGVwID0gMC4xXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1ZhbCA9IHZhbCArIChwYXJzZUZsb2F0KHN0ZXApICogZGlyZWN0aW9uKVxuICAgICAgICB2YWwgPSBuZXdWYWxcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0VmFsdWUodmFsLCB0cnVlLCB0cnVlKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUZvY3VzKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIF91bmZvY3VzKCkge1xuICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKVxuICAgIH1cbiAgfVxuXG4gIF9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50KSB7XG4gICAgbGV0IHBhZ2VYID0gZXZlbnQucGFnZVhcbiAgICBpZiAocGFnZVggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuICAgICAgcGFnZVggPSB0b3VjaC5wYWdlWFxuICAgIH1cblxuICAgIHJldHVybiBwYWdlWCAtIHRoaXMuX3RyYWNrTGVmdFBvc2l0aW9uICsgdGhpcy5fZ3JhYlBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGFuZCB1cGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgc2V0cyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvbiB0aGUgc2xpZGVyLlxuICAgKiBAcGFyYW0ge3Bvc2l0aW9ufSB0aGUgbmV3IHBvc2l0aW9uIHRvIHNldC5cbiAgICogQHBhcmFtIHt1cGRhdGVWYWx1ZX0gdHJ1ZSBpZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgd2VsbDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcGFyYW0ge3NuYXB9IHRydWUgaWYgc25hcHBpbmcgc2hvdWxkIGJlIHVzZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHBhcmFtIHthbmltYXRlfSB0cnVlIGlmIHRoZSBVSSB1cGRhdGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0UG9zaXRpb24ocG9zaXRpb24sIHVwZGF0ZVZhbHVlID0gdHJ1ZSwgc25hcCA9IGZhbHNlLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSBudWxsIHx8IE51bWJlci5pc05hTihwb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIGlzIG5vdCBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIC8vIENsYW1wIHRvIG1pbiBhbmQgbWF4IHJhbmdlXG4gICAgbGV0IG5ld1BvcyA9IGNsYW1wKHBvc2l0aW9uLCB0aGlzLl90cmFja1Bvc2l0aW9uTWluLCB0aGlzLl90cmFja1Bvc2l0aW9uTWF4KVxuICAgIGlmICh1cGRhdGVWYWx1ZSkge1xuICAgICAgbGV0IHZhbHVlID0gKHRoaXMuX3RyYWNrVmFsdWVUb3RhbCAvIHRoaXMuX3RyYWNrV2lkdGgpICogbmV3UG9zICsgdGhpcy5fbWluVmFsdWVcblxuICAgICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSAmJiBzbmFwKSB7XG4gICAgICAgIGxldCBzbmFwUG9zID0gdGhpcy5fZ2V0U25hcFBvc2l0aW9uKG5ld1BvcylcbiAgICAgICAgbmV3UG9zID0gc25hcFBvcy5wb3NpdGlvblxuICAgICAgICB2YWx1ZSA9IHNuYXBQb3MudmFsdWVcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LnN0ZXAgJiYgdGhpcy5lbGVtZW50LnN0ZXAgIT09IFwiYW55XCIpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gdGhpcy5lbGVtZW50LnN0ZXAsIDApICogdGhpcy5lbGVtZW50LnN0ZXBcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0VmFsdWUodmFsdWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGUgJiYgdXBkYXRlVmFsdWUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpY2tTdGF0ZSgpXG4gICAgfVxuXG4gICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgIFR3ZWVuTGl0ZS50byh0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQsIDAuMiwge1xuICAgICAgICBsZWZ0OiBuZXdQb3MsXG4gICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXRcbiAgICAgIH0pXG5cbiAgICAgIGlmICh0aGlzLl9yYW5nZVByb2dyZXNzKSB7XG4gICAgICAgIFR3ZWVuTGl0ZS50byh0aGlzLl9yYW5nZVByb2dyZXNzLmVsZW1lbnQsIDAuMiwge1xuICAgICAgICAgIHdpZHRoOiBuZXdQb3MsXG4gICAgICAgICAgZWFzZTogUG93ZXI0LmVhc2VJbk91dFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBUd2VlbkxpdGUuc2V0KHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudCwgeyBsZWZ0OiBuZXdQb3MgfSlcblxuICAgICAgaWYgKHRoaXMuX3JhbmdlUHJvZ3Jlc3MpIHtcbiAgICAgICAgVHdlZW5MaXRlLnNldCh0aGlzLl9yYW5nZVByb2dyZXNzLmVsZW1lbnQsIHsgd2lkdGg6IG5ld1BvcyB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbmFwIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc25hcCBwb3NpdGlvbiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U25hcFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzXG4gICAgbGV0IGN1cnJlbnRQb3NpdGlvbiA9IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcblxuICAgICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaV0pXG4gICAgICBsZXQgY3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKVxuICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IGN1cnJlbnRFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGhcblxuICAgICAgbGV0IG5leHRFbGVtZW50XG4gICAgICBsZXQgbmV4dFZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRVxuXG4gICAgICBpZiAoaSA8IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpICsgMV0pXG4gICAgICAgIG5leHRWYWx1ZSA9IHBhcnNlRmxvYXQobmV4dEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSlcbiAgICAgIH1cblxuICAgICAgLy8gbGVmdCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmIChpID09PSAwICYmIHZhbHVlIDw9IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IE1BUkdJTl9USUNLIC0gdGhpcy5fZ3JhYlBvc2l0aW9uIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmlnaHQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoIW5leHRFbGVtZW50ICYmIHZhbHVlID49IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArIChjdXJyZW50V2lkdGggLSBNQVJHSU5fVElDSykgLSB0aGlzLl9ncmFiUG9zaXRpb24gLSAxIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID49IGN1cnJlbnRWYWx1ZSAmJiB2YWx1ZSA8IG5leHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArICgwLjUgKiBjdXJyZW50V2lkdGgpIC0gdGhpcy5fZ3JhYlBvc2l0aW9uIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudFBvc2l0aW9uICs9IGN1cnJlbnRXaWR0aFxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgc25hcCB2YWx1ZVwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNuYXAgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7cG9zaXRpb259IHRoZSB0YXJnZXQgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzbmFwIHBvc2l0aW9uIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRTbmFwUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3NpdGlvbiBpcyBub3QgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXNcbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikpXG4gICAgICBsZXQgY3VycmVudFdpZHRoID0gY3VycmVudEVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgICBsZXQgbmV4dEVsZW1lbnRcblxuICAgICAgaWYgKGkgPCB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaSArIDFdKVxuICAgICAgfVxuXG4gICAgICAvLyBsZWZ0IG1vc3QgZWxlbWVudFxuICAgICAgaWYgKGkgPT09IDAgJiYgcG9zaXRpb24gPD0gY3VycmVudFBvc2l0aW9uICsgY3VycmVudFdpZHRoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogTUFSR0lOX1RJQ0sgLSB0aGlzLl9ncmFiUG9zaXRpb24gfVxuICAgICAgfVxuXG4gICAgICAvLyByaWdodCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmICghbmV4dEVsZW1lbnQgJiYgcG9zaXRpb24gPj0gY3VycmVudFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKGN1cnJlbnRXaWR0aCAtIE1BUkdJTl9USUNLKSAtIHRoaXMuX2dyYWJQb3NpdGlvbiAtIDEgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zaXRpb24gPj0gY3VycmVudFBvc2l0aW9uICYmIHBvc2l0aW9uIDwgKGN1cnJlbnRQb3NpdGlvbiArIGN1cnJlbnRXaWR0aCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gKyAoMC41ICogY3VycmVudFdpZHRoKSAtIHRoaXMuX2dyYWJQb3NpdGlvbiB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSBjdXJyZW50V2lkdGhcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHNuYXAgcG9zaXRpb25cIilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24gd2l0aCByZWdhcmRzIHRvIHNuYXBwaW5nLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtkaXJlY3Rpb259IFRoZSBkaXJlY3Rpb24gKHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIpLlxuICAgKiBAcmV0dXJucyBUaGUgbmV4dCB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0VmFsdWUodmFsdWUsIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsID0gcGFyc2VGbG9hdChjdXJyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKVxuXG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWwpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gY2xhbXAoaSArIGRpcmVjdGlvbiwgMCwgdGlja3MubGVuZ3RoIC0gMSlcbiAgICAgICAgdmFsdWUgPSB0aWNrc1tpbmRleF0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgX3VwZGF0ZVRpY2tTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgYWN0aXZlVGljayA9IHRoaXMuX3RpY2tzV3JhcHBlci5maW5kKGAuJHtDTEFTU19USUNLX0FDVElWRX1gKVxuICAgICAgaWYgKGFjdGl2ZVRpY2spIHtcbiAgICAgICAgYWN0aXZlVGljay5yZW1vdmVDbGFzcyhDTEFTU19USUNLX0FDVElWRSlcbiAgICAgIH1cbiAgICAgIGxldCBuZXdBY3RpdmVUaWNrID0gdGhpcy5fdGlja3NXcmFwcGVyLmZpbmQoYC4ke0NMQVNTX1RJQ0t9W2RhdGEtdmFsdWU9JyR7dGhpcy52YWx1ZX0nXWApXG4gICAgICBpZiAobmV3QWN0aXZlVGljaykge1xuICAgICAgICBuZXdBY3RpdmVUaWNrLmFkZENsYXNzKENMQVNTX1RJQ0tfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hZGp1c3RUaWNrTGFiZWxQb3NpdGlvbih0aWNrSXRlbSwgb3V0ZXJJdGVtc1dpZHRoLCBsZWZ0KSB7XG4gICAgY29uc3QgbGFiZWwgPSBuZXcgRG9tRWxlbWVudCh0aWNrSXRlbS5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19USUNLX0xBQkVMfWApKVxuXG4gICAgbGV0IGR1bW15RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0tfTEFCRUwpXG4gICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ2aXNpYmlsaXR5OiBoaWRkZW47IGRpc3BsYXk6IGlubGluZS1ibG9jaztcIilcbiAgICAgIC5zZXRIdG1sKGxhYmVsLmlubmVyVGV4dClcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGxldCB3aWR0aCA9IGR1bW15RWxlbWVudC5lbGVtZW50LmNsaWVudFdpZHRoIC8gMlxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNoaWxkKGR1bW15RWxlbWVudClcblxuICAgIGNvbnN0IGZsb2F0UG9zaXRpb24gPSBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJcblxuICAgIGlmICh3aWR0aCA8IE1BUkdJTl9USUNLKSB7XG4gICAgICAvLyBjZW50ZXIgc21hbGwgaXRlbXMgb24gdGhlIHRpY2tcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGAke2Zsb2F0UG9zaXRpb259OiAke01BUkdJTl9USUNLIC0gTWF0aC5mbG9vcih3aWR0aCl9cHg7IHRleHQtYWxpZ246ICR7ZmxvYXRQb3NpdGlvbn07YClcbiAgICB9XG4gIH1cblxuICBfZm9ybWF0T3V0cHV0KHZhbHVlLCBzaG9ydCkge1xuICAgIGlmICh0aGlzLl9mb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXIodmFsdWUsIHNob3J0KVxuICAgIH1cblxuICAgIGNvbnN0IHN0ciA9IHBhcnNlRmxvYXQodmFsdWUudG9GaXhlZCgyKSlcbiAgICByZXR1cm4gc3RyLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHVwZGF0ZXMgdGhlIHJhbmdlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgbmV3IHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHt1cGRhdGV9IHRydWUgaWYgdGhlIFVJIHNob3VsZCBiZSB1cGRhdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwYXJhbSB7YW5pbWF0ZX0gdHJ1ZSBpZiB0aGUgVUkgdXBkYXRlIHNob3VsZCBiZSBhbmltYXRlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFZhbHVlKHZhbHVlLCB1cGRhdGUgPSB0cnVlLCBhbmltYXRlID0gZmFsc2UpIHtcbiAgICBsZXQgdmFsID0gY2xhbXAodmFsdWUsIHRoaXMuX21pblZhbHVlLCB0aGlzLl9tYXhWYWx1ZSlcbiAgICBsZXQgcG9zaXRpb25cblxuICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNuYXBWYWx1ZSA9IHRoaXMuX2dldFNuYXBWYWx1ZSh2YWwpXG4gICAgICBwb3NpdGlvbiA9IHNuYXBWYWx1ZS5wb3NpdGlvblxuICAgICAgdmFsID0gc25hcFZhbHVlLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uID0gKHRoaXMuX3RyYWNrV2lkdGggLyB0aGlzLl90cmFja1ZhbHVlVG90YWwpICogKHZhbHVlIC0gdGhpcy5fbWluVmFsdWUpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gdmFsXG5cbiAgICBpZiAodGhpcy5fdGh1bWJWYWx1ZSkge1xuICAgICAgdGhpcy5fdGh1bWJWYWx1ZS5zZXRIdG1sKHRoaXMuX2Zvcm1hdE91dHB1dCh2YWwsIHRydWUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vdXRwdXRMYWJlbCkge1xuICAgICAgdGhpcy5fb3V0cHV0TGFiZWwuc2V0SHRtbCh0aGlzLl9mb3JtYXRPdXRwdXQodmFsLCBmYWxzZSkpXG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlLCBmYWxzZSwgYW5pbWF0ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVRpY2tTdGF0ZSgpXG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiaW5wdXRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcmFuZ2Ugc2xpZGVyLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5fc2V0VmFsdWUodmFsdWUsIHRydWUsIHRydWUsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgdGhlIGNvbXBvbmVudCB0byByZS1sYXlvdXQgaXRzZWxmLlxuICAgKi9cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMuX2dyYWJQb3NpdGlvbiA9IE1hdGgucm91bmQodGhpcy5fcmFuZ2VUaHVtYi5lbGVtZW50Lm9mZnNldFdpZHRoIC8gMilcbiAgICBjb25zdCB0aWNrSXRlbXMgPSB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RJQ0t9YClcbiAgICBjb25zdCB0aWNrc09mZnNldCA9IHRpY2tJdGVtcyAmJiB0aWNrSXRlbXMubGVuZ3RoID4gMCA/ICgyICogTUFSR0lOX1RJQ0spIDogTUFSR0lOX1RJQ0tcblxuICAgIHRoaXMuX3RyYWNrV2lkdGggPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQub2Zmc2V0V2lkdGggLSB0aWNrc09mZnNldFxuXG4gICAgdGhpcy5fdHJhY2tQb3NpdGlvbk1pbiA9IDBcbiAgICB0aGlzLl90cmFja1Bvc2l0aW9uTWF4ID0gdGhpcy5fcmFuZ2VUcmFjay5lbGVtZW50LmNsaWVudFdpZHRoIC0gdGhpcy5fcmFuZ2VUaHVtYi5lbGVtZW50Lm9mZnNldFdpZHRoICsgMVxuICAgIHRoaXMuX3RyYWNrTGVmdFBvc2l0aW9uID0gdGhpcy5fcmFuZ2VUcmFjay5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBNQVJHSU5fVElDS1xuXG4gICAgbGV0IGl0ZW1Db3VudCA9IHRpY2tJdGVtcy5sZW5ndGggLSAxXG5cbiAgICB0aGlzLl9pdGVtV2lkdGggPSB0aGlzLl90cmFja1dpZHRoIC8gaXRlbUNvdW50XG4gICAgY29uc3Qgb3V0ZXJJdGVtc1dpZHRoID0gKHRoaXMuX2l0ZW1XaWR0aCAqIDAuNSkgKyBNQVJHSU5fVElDS1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaXRlbUNvdW50OyBpKyspIHtcbiAgICAgIGxldCB3aWR0aCA9IHRoaXMuX2l0ZW1XaWR0aFxuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBpdGVtQ291bnQpIHtcbiAgICAgICAgd2lkdGggPSBvdXRlckl0ZW1zV2lkdGhcbiAgICAgIH1cblxuICAgICAgbGV0IGl0ZW0gPSBuZXcgRG9tRWxlbWVudCh0aWNrSXRlbXNbaV0pXG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB3aWR0aDogJHtNYXRoLmZsb29yKHdpZHRoKX1weDtgKVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBmaXJzdCBhbmQgbGFzdCBsYWJlbCBwb3NpdGlvbnNcbiAgICBpZiAodGlja0l0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX2FkanVzdFRpY2tMYWJlbFBvc2l0aW9uKHRpY2tJdGVtc1swXSwgb3V0ZXJJdGVtc1dpZHRoLCB0cnVlKVxuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zW3RpY2tJdGVtcy5sZW5ndGggLSAxXSwgb3V0ZXJJdGVtc1dpZHRoLCBmYWxzZSlcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHZhbHVlXG4gICAgdGhpcy5fc2V0VmFsdWUodGhpcy5lbGVtZW50LnZhbHVlLCB0cnVlLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHNlbGVjdCBjb250cm9sLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnRzIGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIGRlc3RveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX2Rvd25IYW5kZXIgPSBudWxsXG4gICAgdGhpcy5fbW92ZUhhbmRsZXIgPSBudWxsXG4gICAgdGhpcy5fZW5kSGFuZGVyID0gbnVsbFxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IG51bGxcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IG51bGxcblxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lciA9IG51bGxcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGVuYWJsZWQgc3RhdGUuXG4gICAqL1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZG93bkhhbmRlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2Rvd25IYW5kZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19ESVNBQkxFRClcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9kb3duSGFuZGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiaW5wdXRbdHlwZT0ncmFuZ2UnXVwiLCAoZSkgPT4ge1xuICAgIG5ldyBSYW5nZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBSYW5nZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIGZpbmQsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX1BMQUNFSE9MREVSID0gXCJzZWxlY3RfX3BsYWNlaG9sZGVyXCJcbmNvbnN0IENMQVNTX1RIVU1CID0gXCJzZWxlY3RfX3RodW1iXCJcbmNvbnN0IENMQVNTX0JVVFRPTiA9IFwic2VsZWN0X19idXR0b25cIlxuY29uc3QgQ0xBU1NfRFJPUERPV04gPSBcInNlbGVjdF9fZHJvcGRvd25cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJzZWxlY3QtLW9wZW5cIlxuY29uc3QgQ0xBU1NfQ0xPU0VEID0gXCJzZWxlY3QtLWNsb3NlZFwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwic2VsZWN0LS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0lURU0gPSBcImRyb3Bkb3duLWl0ZW1cIlxuY29uc3QgQ0xBU1NfSVRFTV9TRUxFQ1RFRCA9IFwiZHJvcGRvd24taXRlbS0tc2VsZWN0ZWRcIlxuY29uc3QgQ0xBU1NfSVRFTV9GT0NVU0VEID0gXCJkcm9wZG93bi1pdGVtLS1mb2N1c2VkXCJcbmNvbnN0IENMQVNTX0lURU1fRElTQUJMRUQgPSBcImRyb3Bkb3duLWl0ZW0tLWRpc2FibGVkXCJcblxuY29uc3QgQ0xBU1NfR1JPVVBfSVRFTSA9IFwiZHJvcGRvd24tZ3JvdXBcIlxuY29uc3QgQ0xBU1NfR1JPVVBfSEVBREVSID0gXCJkcm9wZG93bi1ncm91cF9faXRlbVwiXG5cbmNvbnN0IFFVRVJZX01FU1NBR0UgPSBcIi5tZXNzYWdlXCJcblxuY29uc3QgVElNRU9VVF9DTE9TRSA9IDE1MFxuY29uc3QgVElNRU9VVF9CTFVSID0gNDAwXG5cbi8qKlxuICogVGhlIHNlbGVjdCBjb21wb25lbnQgQVBJLlxuICovXG5jbGFzcyBTZWxlY3QgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgIC8vIENoZWNrIGZvciBtdWx0aS1zZWxlY3Rpb25cbiAgICB0aGlzLl9tdWx0aXNlbGVjdGlvbiA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA9PT0gdHJ1ZVxuXG4gICAgLy8gU2V0dXAgZXZlbnQgY29udGV4dFxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZm9jdXNIYW5kbGVyID0gdGhpcy5faGFuZGxlRm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlQmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc2VsZWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW5zcGVjdHMgdGhlIHNlbGVjdCBkZWZpbml0aW9uIGFuZCBpdHMgb3B0aW9ucyBhbmRcbiAgICogZ2VuZXJhdGVzIG5ldyBzdHlsYWJsZSBET00gZWxlbWVudHMgYXJvdW5kIHRoZSBvcmlnaW5hbCBzZWxlY3QtZWxlbWVudFxuICAgKiBkZWZpbml0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQ0xPU0VEKVxuXG4gICAgZm9yIChsZXQgY2xzIG9mIHRoaXMuY2xhc3Nlcykge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoY2xzKVxuICAgIH1cblxuICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfRFJPUERPV04pXG5cbiAgICB0aGlzLl9zZXR1cFRhcmdldCgpXG4gICAgdGhpcy5fc2V0dXBQbGFjZWhvbGRlcigpXG5cbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9kcm9wZG93bkVsZW1lbnQpXG5cbiAgICB0aGlzLl9jcmVhdGVPcHRpb25zKHRoaXMuZWxlbWVudClcblxuICAgIHRoaXMuX3VwZGF0ZVNpemUoKVxuICAgIHRoaXMuX3VwZGF0ZU1lc3NhZ2UoKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKVxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cFRhcmdldCgpIHtcbiAgICAvLyBtb3ZlIHRoZSBpZCBmcm9tIHRoZSBzZWxlY3QgZWxlbWVudCB0byB0aGUgd3JhcHBlclxuICAgIGNvbnN0IGlkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpXG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKVxuICAgIGlmICh0YWJJbmRleCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuICB9XG5cbiAgX3NldHVwUGxhY2Vob2xkZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0JVVFRPTilcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RodW1iRWxlbWVudCkge1xuICAgICAgdGhpcy5fdGh1bWJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RIVU1CKVxuXG4gICAgICBsZXQgdGh1bWJJY29uID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKFwidGh1bWItaWNvblwiKVxuXG4gICAgICB0aGlzLl90aHVtYkVsZW1lbnQuYXBwZW5kQ2hpbGQodGh1bWJJY29uKVxuICAgICAgdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYkVsZW1lbnQpXG4gICAgfVxuXG4gICAgbGV0IHBsYWNlaG9sZGVyVGV4dCA9IFwiXCJcblxuICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bdmFsdWU9JyddXCIpXG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICBwbGFjZWhvbGRlclRleHQgPSBEb20udGV4dCh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbilcbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uLnNlbGVjdGVkID0gZmFsc2VcbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0ZWRPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvbltzZWxlY3RlZF1cIilcbiAgICBpZiAoc2VsZWN0ZWRPcHRpb24pIHtcbiAgICAgIHBsYWNlaG9sZGVyVGV4dCA9IERvbS50ZXh0KHNlbGVjdGVkT3B0aW9uKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1BMQUNFSE9MREVSKVxuXG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnRcbiAgICAgIC5zZXRIdG1sKHBsYWNlaG9sZGVyVGV4dClcblxuICAgIHRoaXMuX3BsYWNlaG9sZGVyVGV4dCA9IHBsYWNlaG9sZGVyVGV4dFxuXG4gICAgaWYgKHNlbGVjdGVkT3B0aW9uICE9PSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikge1xuICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIodHJ1ZSlcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTWVzc2FnZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlTm9kZSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVNTQUdFKVxuICAgIGlmIChtZXNzYWdlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3IERvbUVsZW1lbnQobWVzc2FnZU5vZGUpKVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVPcHRpb25zKGVsZW1lbnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldXG5cbiAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgdGhpcy5fYXBwZW5kR3JvdXAoY2hpbGQpXG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgIGxldCBvcHRpb24gPSB0aGlzLl9jcmVhdGVPcHRpb24oY2hpbGQpXG5cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlT3B0aW9uKG9wdGlvbikge1xuICAgIGxldCBvcHQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lURU0pXG4gICAgICAuc2V0SHRtbChvcHRpb24uaW5uZXJIVE1MKVxuXG4gICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgb3B0LmFkZENsYXNzKENMQVNTX0lURU1fU0VMRUNURUQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgb3B0LmFkZENsYXNzKENMQVNTX0lURU1fRElTQUJMRUQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi52YWx1ZSkge1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgb3B0aW9uLnZhbHVlKVxuICAgICAgcmV0dXJuIG9wdFxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIF9hcHBlbmRHcm91cChvcHRncm91cCkge1xuICAgIGxldCBsYWJlbCA9IG9wdGdyb3VwLmdldEF0dHJpYnV0ZShcImxhYmVsXCIpXG5cbiAgICBsZXQgZ3JvdXAgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0dST1VQX0lURU0pXG5cbiAgICBsZXQgZ3JvdXBIZWFkZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0dST1VQX0hFQURFUilcbiAgICAgIC5zZXRIdG1sKGxhYmVsKVxuXG4gICAgZ3JvdXAuYXBwZW5kQ2hpbGQoZ3JvdXBIZWFkZXIpXG5cbiAgICBsZXQgb3B0aW9ucyA9IG9wdGdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoXCJvcHRpb25cIilcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBvcHRpb25zKSB7XG4gICAgICBsZXQgb3B0aW9uID0gdGhpcy5fY3JlYXRlT3B0aW9uKGVudHJ5KVxuICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICBncm91cC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmFwcGVuZENoaWxkKGdyb3VwKVxuICAgIHJldHVybiBncm91cFxuICB9XG5cbiAgX3VwZGF0ZVNpemUoKSB7XG4gICAgLy8gTm90ZTogTWlycm9yaW5nIHRoZSBET00gYW5kIG1lYXN1cmluZyB0aGUgaXRlbXMgdXNpbmcgdGhlaXIgY2xpZW50V2lkdGggd2FzIHZlcnlcbiAgICAvLyB1bnJlbGlhYmxlLCB0aGVyZWZvcmUgbWVhc3VyaW5nIHdhcyBzd2l0Y2hlZCB0byB0aGUgbmV3IEhUTUw1IG1lYXN1cmVUZXh0IG1ldGhvZFxuICAgIC8vIG1hcmdpbnMgYW5kIHBhZGRpbmdzIGFycm91bmQgdGhlIHRleHQgYXJlIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBwbGFjZWhvbGRlciBpdGVtc1xuICAgIC8vIGRpbWVuc2lvblxuICAgIGNvbnN0IHBsYWNlaG9sZGVyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudCwgbnVsbClcblxuICAgIGxldCBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KHBsYWNlaG9sZGVyU3R5bGUucGFkZGluZ1JpZ2h0KVxuICAgIGxldCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQocGxhY2Vob2xkZXJTdHlsZS5wYWRkaW5nTGVmdClcblxuICAgIGxldCBmb250ID0gdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmNzcyhcImZvbnRcIilcbiAgICBsZXQgdGV4dFdpZHRoID0gRG9tLnRleHRXaWR0aCh0aGlzLl9wbGFjZWhvbGRlclRleHQsIGZvbnQpXG4gICAgbGV0IG1heFdpZHRoID0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQgKyB0ZXh0V2lkdGhcblxuICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApXG4gICAgZm9yIChsZXQgZW50cnkgb2Ygb3B0aW9ucykge1xuICAgICAgbGV0IHdpZHRoID0gRG9tLnRleHRXaWR0aChEb20udGV4dChlbnRyeSksIGZvbnQpICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHRcblxuICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgbWF4V2lkdGggPSB3aWR0aFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYG1pbi13aWR0aDogJHtNYXRoLnJvdW5kKG1heFdpZHRoICsgNCl9cHg7YClcbiAgfVxuXG4gIF9pc0J1dHRvblRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gKHRhcmdldCA9PT0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmVsZW1lbnQgfHxcbiAgICAgIHRhcmdldCA9PT0gdGhpcy5fdGh1bWJFbGVtZW50LmVsZW1lbnQpXG4gIH1cblxuICBfaXNEcm9wZG93blRhcmdldCh0YXJnZXQpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldFxuICAgIHdoaWxlIChjdXJyZW50ICE9PSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudCAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGVcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudCA9PT0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBVSSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkIGFuZCBtYWtlcyBzdXJlIHRoZVxuICAgKiBzZWxlY3QgY29udHJvbCBhbmQgdGhlIGdlbmVyYXRlZCBtYXJrdXAgYXJlIHN5bmNocm9uaXplZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZWxlY3RlZEl0ZW1DaGFuZ2VkKG9sZEl0ZW1zLCBuZXdJdGVtLCBhdXRvQ2xvc2UgPSB0cnVlLCBtdWx0aXNlbGVjdCA9IGZhbHNlKSB7XG4gICAgaWYgKERvbS5oYXNDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKChvbGRJdGVtcy5sZW5ndGggPT09IDApICYmICFuZXdJdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbGVjdCB1bmRlZmluZWQgZWxlbWVudHNcIilcbiAgICB9XG5cbiAgICBsZXQgb2xkSXRlbSA9IG9sZEl0ZW1zWzBdXG4gICAgaWYgKG11bHRpc2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICBvbGRJdGVtID0gZmluZChvbGRJdGVtcywgKHgpID0+IHguZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSA9PT0gbmV3SXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKVxuICAgIH1cblxuICAgIGlmIChuZXdJdGVtICYmIG9sZEl0ZW0gJiYgb2xkSXRlbSA9PT0gbmV3SXRlbSkge1xuICAgICAgLy8gQ2xpY2sgb24gYSBwcmV2aW91c2x5IHNlbGVjdGVkIGVsZW1lbnQgLT4gZGVzZWxlY3RcbiAgICAgIG5ld0l0ZW0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAob2xkSXRlbSkge1xuICAgICAgLy8gUmVtb3ZlIHNlbGVjdGlvbiBvbiB0aGUgZWxlbWVudFxuICAgICAgbGV0IG9sZFZhbHVlID0gb2xkSXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpIHx8IC0xXG4gICAgICBsZXQgb3B0RWxlbWVudCA9IGZpbmQodGhpcy5lbGVtZW50Lm9wdGlvbnMsICh4KSA9PiB4LnZhbHVlID09PSBvbGRWYWx1ZSlcblxuICAgICAgaWYgKCFvcHRFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIG9wdGlvbiB3aXRoIHZhbHVlICR7b2xkVmFsdWV9IGRvZXMgbm90IGV4aXN0YClcbiAgICAgIH1cblxuICAgICAgb3B0RWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICBEb20ucmVtb3ZlQ2xhc3Mob2xkSXRlbSwgQ0xBU1NfSVRFTV9TRUxFQ1RFRClcbiAgICB9XG5cbiAgICBpZiAobmV3SXRlbSkge1xuICAgICAgLy8gU2VsZWN0IGEgbmV3IGl0ZW1cbiAgICAgIGxldCBuZXdWYWx1ZSA9IG5ld0l0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSB8fCAtMVxuICAgICAgbGV0IG9wdEVsZW1lbnQgPSBmaW5kKHRoaXMuZWxlbWVudC5vcHRpb25zLCAoeCkgPT4geC52YWx1ZSA9PT0gbmV3VmFsdWUpXG5cbiAgICAgIGlmICghb3B0RWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBvcHRpb24gd2l0aCB2YWx1ZSAke25ld1ZhbHVlfSBkb2VzIG5vdCBleGlzdGApXG4gICAgICB9XG5cbiAgICAgIG9wdEVsZW1lbnQuc2VsZWN0ZWQgPSB0cnVlXG4gICAgICBEb20uYWRkQ2xhc3MobmV3SXRlbSwgQ0xBU1NfSVRFTV9TRUxFQ1RFRClcbiAgICB9XG5cbiAgICBsZXQgaGFzU2VsZWN0ZWRJdGVtcyA9IHRydWVcbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24gPT09IGZhbHNlICYmICFuZXdJdGVtKSB7XG4gICAgICAvLyBIYW5kbGUgbm8gc2VsZWN0aW9uIGZvciBub24gbXVsdGlzZWxlY3Qgc3RhdGVzXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbi5zZWxlY3RlZCA9IHRydWVcbiAgICAgIGhhc1NlbGVjdGVkSXRlbXMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnQuc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaGFzU2VsZWN0ZWRJdGVtcyA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoaGFzU2VsZWN0ZWRJdGVtcylcblxuICAgIC8vIERpc3BhdGNoIHRoZSBjaGFuZ2VkIGV2ZW50XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpXG5cbiAgICBpZiAoYXV0b0Nsb3NlICYmICFtdWx0aXNlbGVjdCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfSwgVElNRU9VVF9DTE9TRSlcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUGxhY2Vob2xkZXIoaGFzU2VsZWN0ZWRJdGVtcykge1xuICAgIGxldCB0ZXh0ID0gdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24gPyBEb20udGV4dCh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikgOiBcIiBcIlxuXG4gICAgaWYgKGhhc1NlbGVjdGVkSXRlbXMgPT09IHRydWUpIHtcbiAgICAgIGxldCBzZWxlY3RlZEl0ZW1zID0gQXJyYXkoLi4udGhpcy5lbGVtZW50LnNlbGVjdGVkT3B0aW9ucylcblxuICAgICAgaWYgKHNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0ID0gXCJcIlxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNlbGVjdGVkSXRlbXMpIHtcbiAgICAgICAgICB0ZXh0ICs9IGAke0RvbS50ZXh0KGl0ZW0pfSwgYFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIDIpXG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBwbGFjZWhvbGRlciB0ZXh0XG4gICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LnNldEh0bWwodGV4dClcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5vcGVuKClcbiAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IHRydWVcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuICAgIH0sIFRJTUVPVVRfQkxVUilcbiAgfVxuXG4gIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgX2hhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMuX2xhc3RIYW5kbGVkRXZlbnQgPT09IGV2ZW50KSB7XG4gICAgICB0aGlzLl9sYXN0SGFuZGxlZEV2ZW50ID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCdXR0b25UYXJnZXQoZXZlbnQudGFyZ2V0KSAmJiB0aGlzLl9vcGVuQnlGb2N1cyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGhhbmRsZSBoZWFkZXIgaXRlbSBjbGlja3MgYW5kIHRvZ2dsZSBkcm9wZG93blxuICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgbmV3SXRlbSA9IGV2ZW50LnRhcmdldFxuXG4gICAgaWYgKCFoYW5kbGVkICYmIERvbS5oYXNDbGFzcyhuZXdJdGVtLCBDTEFTU19JVEVNKSkge1xuICAgICAgLy8gaGFuZGxlIGNsaWNrcyBvbiBkcm9wZG93biBpdGVtc1xuICAgICAgbGV0IG9sZEl0ZW1zID0gQXJyYXkoLi4udGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNX1NFTEVDVEVEfWApKVxuICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ2hhbmdlZChvbGRJdGVtcywgbmV3SXRlbSwgdHJ1ZSwgdGhpcy5fbXVsdGlzZWxlY3Rpb24pXG4gICAgICBoYW5kbGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICB0aGlzLl9sYXN0SGFuZGxlZEV2ZW50ID0gZXZlbnRcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVXaW5kb3dDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLl9pc0Ryb3Bkb3duVGFyZ2V0KGV2ZW50LnRhcmdldCkgfHwgdGhpcy5faXNCdXR0b25UYXJnZXQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGxldCBldnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTikge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApXG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG5ld0luZGV4ID0gMFxuICAgICAgICBsZXQgb2xkT3B0aW9uXG5cbiAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApXG4gICAgICAgIGxldCBzZWFyY2hGb3IgPSBmb2N1c2VkRWxlbWVudCA/IENMQVNTX0lURU1fRk9DVVNFRCA6IENMQVNTX0lURU1fU0VMRUNURURcblxuICAgICAgICBsZXQgbmV3RWxlbWVudFxuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04gPyAxIDogLTFcblxuICAgICAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG5cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNlbGVjdGVkIG9yIGZvY3VzZWRFbGVtZW50IGVsZW1lbnRzXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3Moc2VhcmNoRm9yKSkge1xuICAgICAgICAgICAgb2xkT3B0aW9uID0gaXRlbVxuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleFxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgbm90IGRpc2FibGVkIGVsZW1lbnQgaW4gdGhlIGFwcm9wcmlhdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgb3B0aW9ucy5sZW5ndGg7IGNvdW50KyspIHtcbiAgICAgICAgICAgICAgbmV3SW5kZXggKz0gZGlyZWN0aW9uXG4gICAgICAgICAgICAgIG5ld0luZGV4ICU9IG9wdGlvbnMubGVuZ3RoXG5cbiAgICAgICAgICAgICAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gb3B0aW9ucy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZXdFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgICAgICAgIGlmICghbmV3RWxlbWVudC5oYXNDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBlbGVtZW50IGZvY3VzZWRcbiAgICAgICAgbGV0IG5ld09wdGlvbiA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICBuZXdPcHRpb24uYWRkQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKVxuXG4gICAgICAgIGlmIChvbGRPcHRpb24pIHtcbiAgICAgICAgICBvbGRPcHRpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FTlRFUikge1xuICAgICAgLy8gSGFuZGxlIGVudGVyIGtleSBieSBzZWxlY3RpbmcgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIGxldCBuZXdJdGVtID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19JVEVNX0ZPQ1VTRUR9YClcbiAgICAgIGxldCBvbGRJdGVtcyA9IEFycmF5KC4uLnRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfSVRFTV9TRUxFQ1RFRH1gKSlcbiAgICAgIHRoaXMuX3NlbGVjdGVkSXRlbUNoYW5nZWQob2xkSXRlbXMsIG5ld0l0ZW0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbi5cbiAgICogSWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGVuYWJsZWQgdGhpcyBwcm9wZXJ0eSByZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBBcnJheSguLi50aGlzLmVsZW1lbnQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKHgpID0+IHgudmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2VsZWN0IGNvbXBvbmVudCBkZXBlbmRpbmcgb24gdGhlXG4gICAqICd2YWx1ZScgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSBJZiB0cnVlIGRpc2FibGVzIHRoZSBjb250cm9sOyBmYWxzZSBlbmFibGVzIGl0LlxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgc2VsZWN0IGNvbnRyb2wuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgZHJvcGRvd24ncyBvcHRpb24gZGF0YSBkZWZpbml0aW9ucyBmcm9tIHRoZSBET00gYW5kIHVwZGF0ZXNcbiAgICogdGhlIGdlbmVyYXRlZCBkcm9wZG93biBkaXNwbGF5IGl0ZW1zLlxuICAgKi9cbiAgcmVsb2FkKCkge1xuICAgIC8vIFJlbW92ZSBhbGwgZXhpc3RpbmcgY2hpbGQgZWxlbWVudHNcbiAgICB3aGlsZSAodGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR1cFBsYWNlaG9sZGVyKClcbiAgICB0aGlzLl9jcmVhdGVPcHRpb25zKHRoaXMuZWxlbWVudClcblxuICAgIHRoaXMuX3VwZGF0ZVNpemUoKVxuICAgIHRoaXMuX3VwZGF0ZU1lc3NhZ2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBlbmFibGVkIHN0YXRlLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0IGRyb3Bkb3duLlxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLmNsb3NlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBpZiB0aGUgc2VsZWN0IGRyb3Bkb3duIGlzIG9wZW4gb3IgY2xvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9wZW47IG90aGVyd2lzZSBmYWxzZS5cbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2VsZWN0IGRyb3Bkb3duLlxuICAgKi9cbiAgb3BlbigpIHtcbiAgICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfQ0xPU0VEKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc2VsZWN0IGRyb3Bkb3duLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX0NMT1NFRClcblxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIGxldCBmb2N1c2VkSXRlbSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmZpbmQoYC4ke0NMQVNTX0lURU1fRk9DVVNFRH1gKVxuICAgICAgaWYgKGZvY3VzZWRJdGVtKSB7XG4gICAgICAgIGZvY3VzZWRJdGVtLnJlbW92ZUNsYXNzKENMQVNTX0lURU1fRk9DVVNFRClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudCBhbmQgY2xlYXJzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuXG4gICAgaWYgKHRoaXMuX2Ryb3Bkb3duRWxlbWVudCkge1xuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIHJlbW92ZSh0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudClcbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl93cmFwcGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmVsZW1lbnQpXG4gICAgICB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19DTE9TRUQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCJzZWxlY3RcIiwgKGUpID0+IHtcbiAgICBuZXcgU2VsZWN0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdFxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1RFWFRBUkVBID0gXCJ0ZXh0YXJlYVwiXG5jb25zdCBDTEFTU19IQVNfVkFMVUUgPSBcImlzLWZpeGVkXCJcblxuLyoqXG4gKiBUZXh0YXJlYSBjb21wb25lbnRcbiAqL1xuY2xhc3MgVGV4dGFyZWEgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvciAoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9hcmVhID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfVEVYVEFSRUEpXG5cbiAgICB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyID0gdGhpcy5fZm9jdXNDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kZXIgPSB0aGlzLl9vblZhbHVlQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX3VwZGF0ZUhlaWdodC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdGV4dGFyZWEgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fbWluUm93cyA9IHRoaXMuX2FyZWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1taW4tcm93c1wiKSB8fCAzXG4gICAgdGhpcy5fbWF4Um93cyA9IHRoaXMuX2FyZWEuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXgtcm93c1wiKSB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiBhbiBtYXggYXJlIHByb3BlcnR5IHNwZWNpZmllZFxuICAgIHRoaXMuX21pblJvd3MgPSBNYXRoLm1pbih0aGlzLl9taW5Sb3dzLCB0aGlzLl9tYXhSb3dzKVxuICAgIHRoaXMuX21heFJvd3MgPSBNYXRoLm1heCh0aGlzLl9taW5Sb3dzLCB0aGlzLl9tYXhSb3dzKVxuXG4gICAgdGhpcy5fbGluZUhlaWdodCA9IHBhcnNlSW50KHRoaXMuX2Nzcyh0aGlzLl9hcmVhLCBcImxpbmUtaGVpZ2h0XCIpLCAxMClcblxuICAgIHRoaXMuX3VwZGF0ZUJhc2VIZWlnaHQgPSBEb20uaXNIaWRkZW4odGhpcy5fYXJlYSwgdHJ1ZSlcbiAgICB0aGlzLl9jYWxjdWxhdGVCYXNlSGVpZ2h0KClcblxuICAgIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kZXIpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX29uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIF9jYWxjdWxhdGVCYXNlSGVpZ2h0KCkge1xuICAgIC8vIHRlbXBvcmFyeSBjbGVhciB0aGUgY29udGVudCB0byB0YWtlIG1lYXN1cmVtZW50c1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuX2FyZWEudmFsdWVcbiAgICB0aGlzLl9hcmVhLnZhbHVlID0gXCJcIlxuXG4gICAgdGhpcy5fYmFzZUhlaWdodCA9IHRoaXMuX2FyZWEub2Zmc2V0SGVpZ2h0IC0gdGhpcy5fbGluZUhlaWdodFxuICAgIHRoaXMuX2Jhc2VTY3JvbGxIZWlnaHQgPSB0aGlzLl9hcmVhLnNjcm9sbEhlaWdodCAtIHRoaXMuX2xpbmVIZWlnaHRcblxuICAgIC8vIHJlc3RvcmUgaW5pdGlhbCBjb250ZW50XG4gICAgdGhpcy5fYXJlYS52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICBfZm9jdXNDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3VwZGF0ZUhlaWdodCgpXG4gIH1cblxuICBfY3NzKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXG4gIH1cblxuICBfdXBkYXRlSGVpZ2h0KCkge1xuICAgIGxldCBoYXNGb2N1cyA9IHRoaXMuX2FyZWEgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICBsZXQgbWF4Um93cywgcm93cyA9IDBcblxuICAgIGlmICh0aGlzLl91cGRhdGVCYXNlSGVpZ2h0ID09PSB0cnVlICYmIERvbS5pc0hpZGRlbih0aGlzLl9hcmVhLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKVxuICAgICAgdGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhcHJvcHJpYXRlIHNpemUgZm9yIHRoZSBjb250cm9sXG4gICAgaWYgKCF0aGlzLl9oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBIYW5kbGUgZW1wdHkgc3RhdGVzXG4gICAgICByb3dzID0gaGFzRm9jdXMgPT09IHRydWUgPyB0aGlzLl9taW5Sb3dzIDogMVxuICAgICAgbWF4Um93cyA9IHJvd3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIGhlaWdodCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIHJvdyBjb3VudFxuICAgICAgdGhpcy5fYXJlYS5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuXG4gICAgICAvLyBHZXQgdGhlIG5ldyBoZWlnaHRcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoKHRoaXMuX2FyZWEuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fYmFzZVNjcm9sbEhlaWdodCkgLyB0aGlzLl9saW5lSGVpZ2h0KSArIDFcbiAgICAgIG1heFJvd3MgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9tYXhSb3dzLCByb3dzKSwgdGhpcy5fbWluUm93cylcbiAgICB9XG5cbiAgICBpZiAocm93cyA+IHRoaXMuX21heFJvd3MpIHtcbiAgICAgIHRoaXMuX2FyZWEuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIlxuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9ICgobWF4Um93cyAtIDEpICAqIHRoaXMuX2xpbmVIZWlnaHQpICsgdGhpcy5fYmFzZUhlaWdodFxuICAgIHRoaXMuX2FyZWEuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuICB9XG5cbiAgX2hhc1ZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcmVhLnZhbHVlICYmIHRoaXMuX2FyZWEudmFsdWUubGVuZ3RoID4gMFxuICB9XG5cbiAgX29uVmFsdWVDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLl9oYXNWYWx1ZSgpKSB7XG4gICAgICBEb20uYWRkQ2xhc3ModGhpcy5fYXJlYSwgQ0xBU1NfSEFTX1ZBTFVFKVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fYXJlYSwgQ0xBU1NfSEFTX1ZBTFVFKVxuICAgICAgdGhpcy5fYXJlYS52YWx1ZSA9IFwiXCJcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVIZWlnaHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fZm9jdXNDaGFuZ2VkSGFuZGxlcilcbiAgICB0aGlzLl9hcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl92YWx1ZUNoYW5nZWRIYW5kZXIpXG5cbiAgICB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyID0gbnVsbFxuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRlciA9IG51bGxcbiAgICB0aGlzLl9hcmVhID0gbnVsbFxuICAgIHRoaXMuX21pblJvd3MgPSBudWxsXG4gICAgdGhpcy5fbWF4Um93cyA9IG51bGxcbiAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbnVsbFxuICAgIHRoaXMuX2Jhc2VIZWlnaHQgPSBudWxsXG4gICAgdGhpcy5fYmFzZVNjcm9sbEhlaWdodCA9IG51bGxcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuaW5wdXQtbXVsdGlsaW5lXCIsIChlKSA9PiB7XG4gICAgbmV3IFRleHRhcmVhKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRhcmVhXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuLyoqXG4gKiBMb2FkZXIgYmFyIGNvbXBvbmVudFxuICovXG5jbGFzcyBMb2FkZXJCYXIgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIExvYWRlckJhciBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBMb2FkZXJCYXIgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIuaW5kaWNhdG9yXCIpIHx8IHRoaXMuZWxlbWVudFxuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50ID0gdGhpcy5maW5kKFwiLmRldGFpbCA+IC5uYW1lXCIpXG4gICAgdGhpcy5wcm9ncmVzc0xhYmVsRWxlbWVudCA9IHRoaXMuZmluZChcIi5wcm9ncmVzc1wiKVxuICAgIHRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoXCIucHJvZ3Jlc3MgPiAuZmlsZS1zaXplXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgMC4uMS5cbiAgICovXG4gIGdldCBwcm9ncmVzcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDAuLjEuXG4gICAqL1xuICBzZXQgcHJvZ3Jlc3ModmFsKSB7XG4gICAgLy8gdmFsID0gY2xhbXAodmFsLCAwLCAxKVxuXG4gICAgbGV0IHBlcmNlbnRhZ2UgPSAodmFsICogMTAwKS50b0ZpeGVkKDApXG5cbiAgICB0aGlzLnZhbHVlID0gdmFsXG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gdmFsXG5cbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgd2lkdGg6ICR7dmFsICogMTAwfSVgKVxuXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQuZWxlbWVudC50ZXh0Q29udGVudCA9IGAke3BlcmNlbnRhZ2V9JWBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsZW5hbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGZpbGVuYW1lLlxuICAgKi9cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIGlmICghdGhpcy5maWxlTmFtZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maWxlTmFtZUVsZW1lbnQuZWxlbWVudC5pbm5lckh0bWxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxlbmFtZS5cbiAgICovXG4gIHNldCBmaWxlbmFtZSh2YWwpIHtcbiAgICBpZiAoIXRoaXMuZmlsZU5hbWVFbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBmaWxlbmFtZSwgbWlzc2luZyBkZXRhaWwgZWxlbWVudFwiKVxuICAgIH1cblxuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50LnNldEh0bWwodmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbGUgc2l6ZSBsYWJlbC5cbiAgICovXG4gIHNldCBmaWxlU2l6ZSh2YWwpIHtcbiAgICBpZiAoIXRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIGZpbGVTaXplLCBtaXNzaW5nIGRldGFpbCBlbGVtZW50XCIpXG4gICAgfVxuXG4gICAgdGhpcy5maWxlU2l6ZS5zZXRIdG1sKHZhbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5sb2FkZXItYmFyXCIsIChlKSA9PiB7XG4gICAgbmV3IExvYWRlckJhcihlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXJCYXJcbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IFR3ZWVuTGl0ZSwgUG93ZXIxLCBQb3dlcjQgfSBmcm9tIFwiZ3NhcFwiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCBpc0hpZGRlbiwgcGFyZW50V2l0aENsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfTUVOVSA9IFwianMtZmx5b3V0XCJcblxuY29uc3QgQU5JTUFUSU9OX09QRU4gPSAwLjNcblxuLyoqXG4gKiBUaGUgZmx5b3V0IG1lbnUgY29tcG9uZW50LlxuICovXG5jbGFzcyBNZW51Rmx5b3V0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgZmx5b3V0IG1lbnUgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9hbmltYXRpb25EdXJhdGlvbiA9IEFOSU1BVElPTl9PUEVOXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZmx5b3V0IGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBmbHlvdXQgbWVudSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaGlkZGVuVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaGlkZGVuXCIpXG4gICAgaWYgKGhpZGRlblRhcmdldCAhPT0gbnVsbCAmJiBoaWRkZW5UYXJnZXQgIT09IFwiXCIpIHtcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaGlkZGVuVGFyZ2V0KVxuICAgIH1cblxuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRhdGFUYXJnZXQpXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG5cbiAgfVxuXG4gIF9oYW5kbGVDbGljayhldmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIF9oYW5kbGVXaW5kb3dDbGljayhldmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXRcblxuICAgIGlmIChwYXJlbnRXaXRoQ2xhc3ModGFyZ2V0LCBDTEFTU19NRU5VKSA9PT0gdGhpcy5fZmx5b3V0RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX29wZW5NZW51KGVsKSB7XG4gICAgVHdlZW5MaXRlLmtpbGxUd2VlbnNPZihlbClcblxuICAgIFR3ZWVuTGl0ZS5zZXQoZWwsIHtcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0pXG5cbiAgICBUd2VlbkxpdGUudG8oZWwsIHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uLCB7XG4gICAgICBjbGFzc05hbWU6IGArPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgZWFzZTogW1xuICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgXVxuICAgIH0pXG5cbiAgICAvLyBzZXQgYXJpYSBleHBhbmRlZFxuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSlcbiAgfVxuXG4gIF9jbG9zZU1lbnUoZWwpIHtcbiAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKGVsKVxuXG4gICAgVHdlZW5MaXRlLnRvKGVsLCBBTklNQVRJT05fT1BFTiwge1xuICAgICAgY2xhc3NOYW1lOiBgLT0ke0NMQVNTX09QRU59YCxcbiAgICAgIGVhc2U6IFtcbiAgICAgICAgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXRcbiAgICAgIF0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIFR3ZWVuTGl0ZS5zZXQoZWwsIHtcbiAgICAgICAgICBjbGVhclByb3BzOiBcImRpc3BsYXlcIlxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBzZXQgYXJpYSBleHBhbmRlZFxuICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BlbmluZyBhbmltYXRpb24gZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZHVyYXRpb25JblNlY29uZHN9IC0gVGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgKi9cbiAgc2V0IGFuaW1hdGlvbkR1cmF0aW9uKGR1cmF0aW9uSW5TZWNvbmRzKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24gPSBkdXJhdGlvbkluU2Vjb25kc1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBmbHlvdXQgbWVudS5cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICB0aGlzLl9vcGVuTWVudSh0aGlzLl9mbHlvdXRFbGVtZW50KVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGZseW91dCBtZW51LlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG5cbiAgICB0aGlzLl9jbG9zZU1lbnUodGhpcy5fZmx5b3V0RWxlbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBmbHlvdXQgbWVudS5cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQgPSBudWxsXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG5cbiAgICBpZiAodGhpcy5fY2xpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gbnVsbFxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyID0gbnVsbFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRvZ2dsZT0nZmx5b3V0J11cIilcbiAgZm9yIChsZXQgZSBvZiBlbGVtZW50cykge1xuICAgIGlmIChlLmdldEF0dHJpYnV0ZShcImRhdGEtaW5pdFwiKSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIG5ldyBNZW51Rmx5b3V0KGUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lbnVGbHlvdXRcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IGdldFJvb3RFbGVtZW50IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX0JBQ0tEUk9QID0gXCJiYWNrZHJvcFwiXG5jb25zdCBDTEFTU19CQUNLRFJPUF9PUEVOID0gXCJiYWNrZHJvcC0tb3BlblwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcIm1vZGFsLS1vcGVuXCJcbmNvbnN0IENMQVNTX1RSSUdHRVIgPSBcIm1vZGFsLXRyaWdnZXJcIlxuXG5jb25zdCBDTEFTU19CVVRUT05TX09LQVkgPSBcIi5tb2RhbC1jbG9zZVwiXG5jb25zdCBDTEFTU19CVVRUT05TX0NMT1NFID0gXCIubW9kYWwtY2FuY2VsXCJcblxuLyoqXG4gKiBUaGUgbW9kYWwgZGlhbG9nIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBNb2RhbCBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fb2theUhhbmRsZXIgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9jYW5jZWxIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2UgbW9kYWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGJhY2tkcm9wXG4gICAgdGhpcy5fYmFja2Ryb3AgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QKVxuXG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQgPSBnZXRSb290RWxlbWVudCgpXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9UcmlnZ2VyKClcbiAgfVxuXG4gIF9zdWJzY3JpYmVUb1RyaWdnZXIoKSB7XG4gICAgY29uc3QgdHJpZ2dlcklkID0gdGhpcy5lbGVtZW50LmlkXG4gICAgaWYgKCF0cmlnZ2VySWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRlciA9IHRoaXMub3Blbi5iaW5kKHRoaXMpXG5cbiAgICBsZXQgdHJpZ2dlckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19UUklHR0VSfVtocmVmPSR7dHJpZ2dlcklkfV1gKVxuICAgIGlmICh0cmlnZ2VyRWxlbWVudCkge1xuICAgICAgdHJpZ2dlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRlcilcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGxldCBldnQgPSBldnQgfHwgd2luZG93LmV2ZW50XG4gICAgbGV0IGtleWNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUpIHtcbiAgICAgIC8vIGhhbmRsZSBFc2NhcGUga2V5IChFU0MpXG4gICAgICB0aGlzLmNhbmNlbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBfaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLmNhbmNlbCgpXG4gIH1cblxuICBfY2xvc2UoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fYmFja2Ryb3AuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2FuY2VsSGFuZGxlcilcblxuICAgIHRoaXMuX2JhY2tkcm9wLnJlbW92ZUNsYXNzKENMQVNTX0JBQ0tEUk9QX09QRU4pXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgZm9yIChsZXQgY2xvc2VCdXR0b24gb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoQ0xBU1NfQlVUVE9OU19DTE9TRSkpIHtcbiAgICAgIGNsb3NlQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuICAgIH1cblxuICAgIGZvciAobGV0IG9rYXlCdXR0b24gb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoQ0xBU1NfQlVUVE9OU19PS0FZKSkge1xuICAgICAgb2theUJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb2theUhhbmRsZXIpXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBhZGQgdGhlIGJhY2tkcm9wIHRvIHRoZSBib2R5XG4gICAgICB0aGlzLl9iYWNrZHJvcFBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9iYWNrZHJvcC5lbGVtZW50KVxuICAgIH0sIDMwMClcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKi9cbiAgb3BlbigpIHtcbiAgICAvLyBhZGQgdGhlIGJhY2tkcm9wIHRvIHRoZSBib2R5XG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcblxuICAgIC8vIHNldCB0aGUgZWxlbWVudCB0byBmbGV4IGFzIGl0IGlzIGluaXRpYWxseSBoaWRkZW5cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiXG5cbiAgICAvLyByZW1vdmUgdGhlIHN0eWxlIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICB9LCA4MDApXG5cbiAgICAvLyB3YWl0IGEgYml0IHRvIGFsbG93IHRoZSBicm93c2VyIHRvIGNhdGNoIHVwIGFuZCBzaG93IHRoZSBhbmltYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QX09QRU4pXG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5faGFuZGxlQnV0dG9uRG93bilcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG5cbiAgICAgIGZvciAobGV0IGNsb3NlQnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfQ0xPU0UpKSB7XG4gICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBva2F5QnV0dG9uIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0JVVFRPTlNfT0tBWSkpIHtcbiAgICAgICAgb2theUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fb2theUhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcIm9wZW5lZFwiKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgKGFuZCBjbG9zZXMpIHRoZSBtb2RhbCBkaWFsb2cuXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2FuY2VsbGVkXCIpXG4gICAgdGhpcy5fY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fY2xvc2UoKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLm1vZGFsXCIsIChlKSA9PiB7XG4gICAgbmV3IE1vZGFsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IFRpbWVsaW5lTGl0ZSwgUG93ZXI0LCBQb3dlcjEgfSBmcm9tIFwiZ3NhcFwiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgU2VhcmNoSW5wdXQgZnJvbSBcIi4uL3NlYXJjaC9TZWFyY2hJbnB1dFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9OQVZfSEFNQlVSR0VSID0gXCIubmF2LWhhbWJ1cmdlclwiXG5jb25zdCBRVUVSWV9OQVZfSEJfQk9EWSA9IFwiLm5hdl9fcHJpbWFyeVwiXG5cbmNvbnN0IENMQVNTX05BVl9MSU5LID0gXCJuYXYtbGluay0taGVhZGVyXCJcbmNvbnN0IFFVRVJZX05BVl9MSU5LX0FDVElWRSA9IFwiLm5hdi1saW5rLS1oZWFkZXIuaXMtYWN0aXZlXCJcblxuY29uc3QgUVVFUllfTkFWX01PQklMRSA9IFwiLm5hdl9fbGV2ZWwxIC5uYXZfX21haW5uYXYgLm5hdl9fcHJpbWFyeVwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwID0gXCIubmF2X19sZXZlbDBcIlxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9DT05UQUlORVIgPSBcIi5uYXZfX2xldmVsMCAubmF2X19zdWJuYXZcIlxuY29uc3QgUVVFUllfU0VDVElPTl9PUEVOID0gXCIubmF2LXNlY3Rpb24uaXMtb3BlblwiXG5cbmNvbnN0IFFVRVJZX05BVl9MRVZFTDEgPSBcIi5uYXZfX2xldmVsMSAubmF2X19tYWlubmF2XCJcblxuY29uc3QgUVVFUllfTkFWX0xFVkVMMF9MSU5LID0gXCIubmF2LWxpbmsubmF2LWxpbmstLWhlYWRlclwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwxX0xJTksgPSBcIi5uYXYtbGluay0taGVhZGVyXCJcblxuY29uc3QgUVVFUllfTkFWX0NPTFVNTiA9IFwiLm5hdi1jb2xcIlxuY29uc3QgUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUgPSBcIi5uYXYtY29sLmlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX05BVl9CT0RZID0gXCIubmF2LWJvZHlcIlxuY29uc3QgUVVFUllfTkFWX0ZPT1RFUiA9IFwiLm5hdi1mb290ZXJcIlxuXG5jb25zdCBRVUVSWV9TRUFSQ0hfSUNPTiA9IFwiLm5hdi1zZWFyY2hcIlxuY29uc3QgUVVFUllfU0VBUkNIX0ZJRUxEID0gXCIuc2VhcmNoX19pbnB1dFwiXG5jb25zdCBDTEFTU19TRUFSQ0hfREVTS1RPUCA9IFwic2VhcmNoLS1kZXNrdG9wXCJcblxuY29uc3QgQU5JTUFUSU9OX1NUQVJUX0RFTEFZID0gMC4yXG5jb25zdCBBTklNQVRJT05fT0ZGU0VUID0gMC4wNVxuXG5jb25zdCBBTklNQVRJT05fQk9EWV9EVVJBVElPTiA9IDAuM1xuY29uc3QgQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTiA9IDAuMVxuXG4vKipcbiAqIFRoZSBuYXZpZ2F0aW9uIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBOYXZpZ2F0aW9uIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9uYXZMZXZlbDAgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTEVWRUwwKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2TGV2ZWwwQm9keSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MRVZFTDBfQ09OVEFJTkVSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2TGV2ZWwxID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xFVkVMMSkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuXG4gICAgdGhpcy5fbmF2TW9iaWxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX01PQklMRSlcbiAgICBpZiAoIXRoaXMuX25hdk1vYmlsZSkge1xuICAgICAgbGV0IGR1bW15UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgdGhpcy5fbmF2TW9iaWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgZHVtbXlQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fbmF2TW9iaWxlKVxuICAgIH1cblxuICAgIHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cyA9IFtdXG5cbiAgICB0aGlzLl9sZXZlbDBDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVMZXZlbDBDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlTGV2ZWwxQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNlYXJjaENsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX3Jlc2V0TWFpblRpbWVsaW5lKCkge1xuICAgIGlmICh0aGlzLl90bE1haW4pIHtcbiAgICAgIHRoaXMuX3RsTWFpbi5zdG9wKClcbiAgICB9XG5cbiAgICB0aGlzLl90bE1haW4gPSBuZXcgVGltZWxpbmVMaXRlKHtcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGxNYWluID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF9pc01vYmlsZSgpIHtcbiAgICByZXR1cm4gRG9tLmlzSGlkZGVuKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIHRydWUpID09PSBmYWxzZVxuICB9XG5cbiAgX2hhbmRsZUxldmVsMENsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgaXNEZXNrdG9wID0gIXRoaXMuX2lzTW9iaWxlKClcblxuICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgIHRoaXMuX3Jlc2V0TWFpblRpbWVsaW5lKClcblxuICAgICAgbGV0IG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKVxuICAgICAgICAuZnJvbUxldmVsMChldmVudC50YXJnZXQpXG5cbiAgICAgIGlmICghbmF2SXRlbXMuc2VjdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IHByZXZpb3VzTmF2TGluayA9IHRoaXMuX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSlcbiAgICAgIGxldCBwcmV2aW91c05hdlNlY3Rpb24gPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9TRUNUSU9OX09QRU4pXG5cbiAgICAgIHRoaXMuX3RvZ2dsZUNvbnRhaW5lcihuYXZJdGVtcy5saW5rLCB0aGlzLl9uYXZMZXZlbDBCb2R5LCBuYXZJdGVtcy5zZWN0aW9uLCB1bmRlZmluZWQsXG4gICAgICAgIHByZXZpb3VzTmF2TGluaywgdGhpcy5fbmF2TGV2ZWwwQm9keSwgcHJldmlvdXNOYXZTZWN0aW9uLCB1bmRlZmluZWQsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUxldmVsMUNsaWNrKGV2ZW50KSB7XG4gICAgbGV0IG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKVxuICAgICAgLmZyb21MZXZlbDEoZXZlbnQudGFyZ2V0KVxuXG4gICAgbGV0IHByZXZJdGVtcyA9IG5hdkl0ZW1zLnByZXZpb3VzTGV2ZWwxKClcblxuICAgIHRoaXMuX3RvZ2dsZUNvbnRhaW5lcihuYXZJdGVtcy5saW5rLCBuYXZJdGVtcy5jb250YWluZXIsIG5hdkl0ZW1zLnNlY3Rpb24sIG5hdkl0ZW1zLmZvb3RlciwgcHJldkl0ZW1zLmxpbmssXG4gICAgICBwcmV2SXRlbXMuY29udGFpbmVyLCBwcmV2SXRlbXMuc2VjdGlvbiwgcHJldkl0ZW1zLmZvb3RlciwgZmFsc2UpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIF90b2dnbGVDb250YWluZXIobmF2TGluaywgbmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCBuYXZGb290ZXIsXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c05hdkxpbmssIHByZXZpb3VzTmF2Q29udGFpbmVyLCBwcmV2aW91c05hdlNlY3Rpb24sIHByZXZpb3VzTmF2Rm9vdGVyLCBhbmltYXRlQ29udGFpbmVyID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc0Rlc2t0b3AgPSAhdGhpcy5faXNNb2JpbGUoKVxuXG4gICAgaWYgKHByZXZpb3VzTmF2TGluayAmJiBwcmV2aW91c05hdkxpbmsgIT09IG5hdkxpbmsgJiYgbmF2TGluayAhPT0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudCkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHByZXZpb3VzTmF2TGluaywgQ0xBU1NfQUNUSVZFKVxuICAgIH1cblxuICAgIGlmIChEb20uaGFzQ2xhc3MobmF2TGluaywgQ0xBU1NfQUNUSVZFKSkge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKG5hdkxpbmssIENMQVNTX0FDVElWRSlcblxuICAgICAgaWYgKGlzRGVza3RvcCkge1xuICAgICAgICB0aGlzLl9vbk5hdmlnYXRpb25DbG9zZWQoKVxuXG4gICAgICAgIHRoaXMuX3Jlc2V0TWFpblRpbWVsaW5lKClcbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0aGlzLl90bE1haW4sIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9IGVsc2UgaWYgKG5hdkxpbmsgPT09IHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ2xvc2UgbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcblxuICAgICAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG4gICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIHVuZGVmaW5lZCwgdGhpcy5fdGxNYWluLCBmYWxzZSwgZmFsc2UpXG4gICAgICB9IGVsc2UgaWYgKCFpc0Rlc2t0b3ApIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNlY3Rpb25cbiAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB1bmRlZmluZWQsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5hZGRDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG5cbiAgICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHRoaXMuX25hdk1vYmlsZSwgQ0xBU1NfT1BFTilcbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcbiAgICAgICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUoKVxuXG4gICAgICAgIGlmIChwcmV2aW91c05hdkNvbnRhaW5lciAmJiBwcmV2aW91c05hdlNlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24ocHJldmlvdXNOYXZDb250YWluZXIsIHByZXZpb3VzTmF2U2VjdGlvbiwgcHJldmlvdXNOYXZGb290ZXIsIHRoaXMuX3RsTWFpbiwgdHJ1ZSwgYW5pbWF0ZUNvbnRhaW5lcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIG5hdkZvb3RlciwgdGhpcy5fdGxNYWluLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChuYXZMaW5rID09PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICAgIC8vIE9wZW4gbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcblxuICAgICAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgdW5kZWZpbmVkLCB0aGlzLl90bE1haW4sIGZhbHNlLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVza3RvcCkge1xuICAgICAgICAvLyBPcGVuIHNlY3Rpb25cbiAgICAgICAgaWYgKHByZXZpb3VzTmF2Q29udGFpbmVyICYmIHByZXZpb3VzTmF2U2VjdGlvbikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihwcmV2aW91c05hdkNvbnRhaW5lciwgcHJldmlvdXNOYXZTZWN0aW9uLCBwcmV2aW91c05hdkZvb3RlciwgdW5kZWZpbmVkLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB1bmRlZmluZWQsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX29uTmF2aWdhdGlvbk9wZW5lZCgpIHtcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICB9XG5cbiAgX29uTmF2aWdhdGlvbkNsb3NlZCgpIHtcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICB9XG5cbiAgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0bCwgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLCBhbmltYXRlQ29udGFpbmVyID0gZmFsc2UpIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVJdGVtcyA9IG5hdlNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKVxuXG4gICAgaWYgKGFuaW1hdGVDb250YWluZXIgPT09IHRydWUpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBuYXZDb250YWluZXJcbiAgICAgIG5hdkNvbnRhaW5lciA9IG5hdlNlY3Rpb25cbiAgICAgIG5hdlNlY3Rpb24gPSBjb250YWluZXJcbiAgICB9XG5cbiAgICBpZiAoIXRsKSB7XG4gICAgICB0bCA9IG5ldyBUaW1lbGluZUxpdGUoKVxuICAgIH1cblxuICAgIHRsLnNldChuYXZDb250YWluZXIsIHtcbiAgICAgIGNsYXNzTmFtZTogYCs9JHtDTEFTU19PUEVOfWBcbiAgICB9KVxuXG4gICAgdGwuc2V0KG5hdlNlY3Rpb24sIHtcbiAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0pXG5cbiAgICB0bC50byhuYXZTZWN0aW9uLCBBTklNQVRJT05fQk9EWV9EVVJBVElPTiwge1xuICAgICAgY2xhc3NOYW1lOiBgKz0ke0NMQVNTX09QRU59YCxcbiAgICAgIGNsZWFyUHJvcHM6IFwiYWxsXCIsXG4gICAgICBlYXNlOiBbXG4gICAgICAgIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0XG4gICAgICBdXG4gICAgfSlcblxuICAgIGlmIChuYXZGb290ZXIpIHtcbiAgICAgIHRsLnNldChuYXZGb290ZXIucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKSwge1xuICAgICAgICBjbGFzc05hbWU6IGArPSR7Q0xBU1NfQUNUSVZFfWBcbiAgICAgIH0pXG5cbiAgICAgIHRsLnNldChuYXZGb290ZXIsIHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICB9LCAwKVxuXG4gICAgICB0bC50byhuYXZGb290ZXIsIEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04sIHtcbiAgICAgICAgY2xhc3NOYW1lOiBgKz0ke0NMQVNTX09QRU59YCxcbiAgICAgICAgY2xlYXJQcm9wczogXCJoZWlnaHQsIGRpc3BsYXlcIixcbiAgICAgICAgZWFzZTogW1xuICAgICAgICAgIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0XG4gICAgICAgIF1cbiAgICAgIH0sIFwiLT0wLjFcIilcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZUNvbHVtbnMgPT09IHRydWUpIHtcbiAgICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuICAgICAgbGV0IGl0ZW1zID0gYWN0aXZlSXRlbXNcblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB0bC50byhpdGVtc1tpbmRleF0sIDAsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IGArPSR7Q0xBU1NfQUNUSVZFfWBcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgICAgIGRlbGF5ICs9IEFOSU1BVElPTl9PRkZTRVRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2xvc2VTZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0bCwgYW5pbWF0ZUNvbHVtbnMgPSB0cnVlLCBhbmltYXRlQ29udGFpbmVyID0gZmFsc2UpIHtcbiAgICBpZiAoIW5hdlNlY3Rpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVJdGVtcyA9IG5hdlNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OX0FDVElWRSlcblxuICAgIGlmIChhbmltYXRlQ29udGFpbmVyID09PSB0cnVlKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gbmF2Q29udGFpbmVyXG4gICAgICBuYXZDb250YWluZXIgPSBuYXZTZWN0aW9uXG4gICAgICBuYXZTZWN0aW9uID0gY29udGFpbmVyXG4gICAgfVxuXG4gICAgaWYgKCF0bCkge1xuICAgICAgdGwgPSBuZXcgVGltZWxpbmVMaXRlKClcbiAgICB9XG5cbiAgICB0bC5zZXQobmF2U2VjdGlvbiwge1xuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSlcblxuICAgIGlmIChhbmltYXRlQ29sdW1ucyA9PT0gdHJ1ZSkge1xuICAgICAgdGwuc2V0KGFjdGl2ZUl0ZW1zLCB7XG4gICAgICAgIGNsYXNzTmFtZTogYC09JHtDTEFTU19BQ1RJVkV9YFxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB0bC50byhuYXZTZWN0aW9uLCBBTklNQVRJT05fQk9EWV9EVVJBVElPTiwge1xuICAgICAgY2xhc3NOYW1lOiBgLT0ke0NMQVNTX09QRU59YCxcbiAgICAgIGVhc2U6IFtcbiAgICAgICAgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXRcbiAgICAgIF0sXG4gICAgICBjbGVhclByb3BzOiBcImFsbFwiLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2Q29udGFpbmVyLCBDTEFTU19PUEVOKVxuXG4gICAgICAgIGlmIChhbmltYXRlQ29sdW1ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBhY3RpdmVJdGVtcykge1xuICAgICAgICAgICAgRG9tLnJlbW92ZUNsYXNzKGFjdGl2ZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDApXG5cbiAgICBpZiAobmF2Rm9vdGVyKSB7XG4gICAgICB0bC5zZXQobmF2Rm9vdGVyLCB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgICAgfSwgMClcblxuICAgICAgdGwudG8obmF2Rm9vdGVyLCBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLCB7XG4gICAgICAgIGNsYXNzTmFtZTogYC09JHtDTEFTU19PUEVOfWAsXG4gICAgICAgIGVhc2U6IFtcbiAgICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgICBdLFxuICAgICAgICBjbGVhclByb3BzOiBcImhlaWdodCxkaXNwbGF5XCIsXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgbmF2Rm9vdGVyLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUpKSB7XG4gICAgICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYWN0aXZlLCBDTEFTU19BQ1RJVkUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVTZWFyY2hDbGljaygpIHtcbiAgICB0aGlzLl9zZWFyY2hEZXNrdG9wLm9wZW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBuYXZpZ2F0aW9uIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIGZvciAobGV0IG5hdkxpbmsgb2YgdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0xFVkVMMF9MSU5LKSkge1xuICAgICAgbmF2TGluay5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbGV2ZWwwQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIGZvciAobGV0IG5hdkxpbmsgb2YgdGhpcy5fbmF2TGV2ZWwxLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0xFVkVMMV9MSU5LKSkge1xuICAgICAgbmF2TGluay5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2xldmVsMUNsaWNrSGFuZGxlcilcblxuICAgIC8vIERlc2t0b3Agc2VhcmNoIGljb25cbiAgICBsZXQgc2VhcmNoSWNvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NFQVJDSF9JQ09OKVxuICAgIGlmIChzZWFyY2hJY29uKSB7XG4gICAgICBzZWFyY2hJY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9zZWFyY2hDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgc2VhcmNoIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX1NFQVJDSF9GSUVMRCkpIHtcbiAgICAgIGxldCBzZWFyY2hDb21wb25lbnQgPSBuZXcgU2VhcmNoSW5wdXQoc2VhcmNoKVxuXG4gICAgICBpZiAoRG9tLmhhc0NsYXNzKHNlYXJjaCwgQ0xBU1NfU0VBUkNIX0RFU0tUT1ApIHx8IERvbS5oYXNDbGFzcyhzZWFyY2gucGFyZW50Tm9kZSwgQ0xBU1NfU0VBUkNIX0RFU0tUT1ApKSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaERlc2t0b3AgPSBzZWFyY2hDb21wb25lbnRcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cy5wdXNoKHNlYXJjaENvbXBvbmVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgbGV0IGlzTW9ibGUgPSB0aGlzLl9pc01vYmlsZSgpXG4gICAgdGhpcy5fcmVzZXRNYWluVGltZWxpbmUoKVxuXG4gICAgbGV0IGxldmVsMSA9IHRoaXMuX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSlcbiAgICBsZXQgbGV2ZWwwID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKVxuXG4gICAgaWYgKCFsZXZlbDEgJiYgaXNNb2JsZSAmJiBEb20uaGFzQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKSkge1xuICAgICAgbGV2ZWwxID0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudFxuICAgIH1cblxuICAgIGlmIChsZXZlbDEpIHtcbiAgICAgIGxldCBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcylcbiAgICAgICAgLmZyb21MZXZlbDEobGV2ZWwxKVxuXG4gICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2SXRlbXMubGluaywgQ0xBU1NfQUNUSVZFKVxuICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcbiAgICAgIHRoaXMuX2Nsb3NlU2VjdGlvbihuYXZJdGVtcy5jb250YWluZXIsIG5hdkl0ZW1zLnNlY3Rpb24sIG5hdkl0ZW1zLmZvb3RlciwgdGhpcy5fdGxNYWluLCAhaXNNb2JsZSwgZmFsc2UpXG4gICAgfVxuXG4gICAgaWYgKGxldmVsMCkge1xuICAgICAgbGV0IG5hdkl0ZW1zID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzKVxuICAgICAgICAuZnJvbUxldmVsMChsZXZlbDApXG5cbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZJdGVtcy5saW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgICB0aGlzLl9vbk5hdmlnYXRpb25DbG9zZWQoKVxuICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkl0ZW1zLmNvbnRhaW5lciwgbmF2SXRlbXMuc2VjdGlvbiwgbmF2SXRlbXMuZm9vdGVyLCB0aGlzLl90bE1haW4sICFpc01vYmxlLCB0cnVlKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uSXRlbXMge1xuICBjb25zdHJ1Y3RvcihuYXYpIHtcbiAgICB0aGlzLl9uYXZpZ2F0aW9uID0gbmF2XG5cbiAgICB0aGlzLl9saW5rID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29udGFpbmVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VjdGlvbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2Zvb3RlciA9IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IGxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgZ2V0IHNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25cbiAgfVxuXG4gIGdldCBmb290ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvb3RlclxuICB9XG5cbiAgZnJvbUxldmVsMChuYXZMaW5rKSB7XG4gICAgd2hpbGUgKCFEb20uaGFzQ2xhc3MobmF2TGluaywgQ0xBU1NfTkFWX0xJTkspICYmIG5hdkxpbmsucGFyZW50RWxlbWVudCkge1xuICAgICAgbmF2TGluayA9IG5hdkxpbmsucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIHRoaXMuX2xpbmsgPSBuYXZMaW5rXG5cbiAgICBsZXQgdG9nZ2xlSWQgPSBuYXZMaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtdG9nZ2xlXCIpXG4gICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fbmF2aWdhdGlvbi5fbmF2TGV2ZWwwQm9keVxuICAgIHRoaXMuX3NlY3Rpb24gPSB0aGlzLl9uYXZpZ2F0aW9uLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihgIyR7dG9nZ2xlSWR9YClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmcm9tTGV2ZWwxKG5hdkxpbmspIHtcbiAgICB3aGlsZSAobmF2TGluay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpZiAoKG5hdkxpbmsgPT09IHRoaXMuX25hdmlnYXRpb24uX2hhbWJ1cmdlckVsZW1lbnQpIHx8IERvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19OQVZfTElOSykpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgbmF2TGluayA9IG5hdkxpbmsucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIHRoaXMuX2xpbmsgPSBuYXZMaW5rXG4gICAgdGhpcy5fY29udGFpbmVyID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9CT0RZKVxuICAgIHRoaXMuX2Zvb3RlciA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpXG5cbiAgICBpZiAobmF2TGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudCkge1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fbmF2aWdhdGlvbi5fbmF2TGV2ZWwxXG4gICAgICB0aGlzLl9zZWN0aW9uID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0hCX0JPRFkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByZXZpb3VzTGV2ZWwxKCkge1xuICAgIGxldCBwcmV2ID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzLl9uYXZpZ2F0aW9uKVxuXG4gICAgcHJldi5fbGluayA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSlcbiAgICBwcmV2Ll9jb250YWluZXIgPSBwcmV2Ll9saW5rID8gcHJldi5fbGluay5wYXJlbnRFbGVtZW50IDogdW5kZWZpbmVkXG4gICAgcHJldi5fc2VjdGlvbiA9IHByZXYuX2NvbnRhaW5lciA/IHByZXYuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9CT0RZKSA6IHVuZGVmaW5lZFxuICAgIHByZXYuX2Zvb3RlciA9IHByZXYuX2NvbnRhaW5lciA/IHByZXYuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpIDogdW5kZWZpbmVkXG5cbiAgICByZXR1cm4gcHJldlxuICB9XG5cbiAgaXNIYW1idXJnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmsgPT09IHRoaXMuX25hdmlnYXRpb24uX2hhbWJ1cmdlckVsZW1lbnRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5uYXZcIiwgKGUpID0+IHtcbiAgICBuZXcgTmF2aWdhdGlvbihlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyBUaW1lbGluZUxpdGUsIFBvd2VyNCwgUG93ZXIxLCBUd2VlbkxpdGUgfSBmcm9tIFwiZ3NhcFwiXG5pbXBvcnQgeyBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9TSVRFX1dSQVBQRVIgPSBcIi5qcy1zaXRlLXdyYXBwZXJcIlxuY29uc3QgUVVFUllfTkFWX0hBTUJVUkdFUiA9IFwiLmpzLXNpdGUtd3JhcHBlciAuanMtaGFtYnVyZ2VyXCJcblxuY29uc3QgUVVFUllfTkFWX0lURU0gPSBcIi5qcy1uYXYtaXRlbVwiXG5cbmNvbnN0IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEUgPSAwLjlcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MSU5LUyA9IDAuMVxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX05BViA9IDAuM1xuXG5jb25zdCBBTklNQVRJT05fU1RBR0dFUl9ERUxBWSA9IDAuMDVcblxuLyoqXG4gKiBUaGUgbmF2aWdhdGlvbiBzaWRlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBOYXZpZ2F0aW9uU2lkZSBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fc2l0ZVdyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1NJVEVfV1JBUFBFUilcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2SXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfSVRFTSlcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgX2hhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldFxuXG4gICAgd2hpbGUgKHRhcmdldCAhPT0gdGhpcy5lbGVtZW50ICYmIHRhcmdldC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHNpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2xpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgbGV0IGVsZW1lbnRzID0gW3RoaXMuZWxlbWVudCwgdGhpcy5fc2l0ZVdyYXBwZXJdXG4gICAgVHdlZW5MaXRlLmtpbGxUd2VlbnNPZihlbGVtZW50cylcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG4gICAgfSwgNTApXG5cbiAgICBsZXQgdGwgPSBuZXcgVGltZWxpbmVMaXRlKClcblxuICAgIGFkZENsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcblxuICAgIHRsLnRvKGVsZW1lbnRzLCBBTklNQVRJT05fRFVSQVRJT05fTkFWLCB7XG4gICAgICBjbGFzc05hbWU6IGArPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgZWFzZTogW1xuICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgXVxuICAgIH0pXG5cbiAgICB0bC5zdGFnZ2VyRnJvbSh0aGlzLl9uYXZJdGVtcywgQU5JTUFUSU9OX0RVUkFUSU9OX0xJTktTLCB7XG4gICAgICBhdXRvQWxwaGE6IDAsXG4gICAgICBzY2FsZVg6IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEUsXG4gICAgICBzY2FsZVk6IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEVcbiAgICB9LCBBTklNQVRJT05fU1RBR0dFUl9ERUxBWSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNpZGUgbmF2aWdhdGlvbi5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcblxuICAgIGxldCBlbGVtZW50cyA9IFt0aGlzLmVsZW1lbnQsIHRoaXMuX3NpdGVXcmFwcGVyXVxuICAgIFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2YoZWxlbWVudHMpXG5cbiAgICByZW1vdmVDbGFzcyh0aGlzLl9oYW1idXJnZXJFbGVtZW50LCBDTEFTU19BQ1RJVkUpXG5cbiAgICBsZXQgdGwgPSBuZXcgVGltZWxpbmVMaXRlKClcblxuICAgIHRsLnRvKGVsZW1lbnRzLCBBTklNQVRJT05fRFVSQVRJT05fTkFWLCB7XG4gICAgICBjbGFzc05hbWU6IGAtPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgZWFzZTogW1xuICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgXVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzdG9yeXMgdGhlIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnRcbiAgICogc3Vic2NyaXB0aW9ucyBhbmQgcmVmZXJlbmNlcy5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSBudWxsXG5cbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSBudWxsXG4gICAgdGhpcy5fc2l0ZVdyYXBwZXIgPSAgbnVsbFxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9uYXZJdGVtcyA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5uYXYtc2lkZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uU2lkZShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBOYXZpZ2F0aW9uU2lkZVxuIiwiaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19OT1RJRklDQVRJT04gPSBcIm5vdGlmaWNhdGlvbi1oZWFkZXJcIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJub3RpZmljYXRpb24tLW9wZW5cIlxuY29uc3QgQ0xBU1NfQlVUVE9OX0NMT1NFID0gXCJub3RpZmljYXRpb25fX2Nsb3NlXCJcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBzaG93cyBhIG5vdGlmaWNhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZS5cbiAqIEBwYXJhbSB7Y29udGFpbmVySWR9IFRoZSBpZCBvZiB0aGUgY29udGFpbmVyIG9uIHdoZXJlIHRvIHNob3cgdGhlIG5vdGlmaWNhdGlvbi5cbiAqIEBwYXJhbSB7bWVzc2FnZX0gVGhlIG1lc3NhZ2UgdG8gc2hvdy5cbiAqIEBwYXJhbSB7bWVzc2FnZUNsaWNrQ2FsbGJhY2t9IFRoZSBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZSB0ZXh0LlxuICogQHBhcmFtIHtjYW5jZWxDYWxsYmFja30gVGhlIGNhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBub3RpZmljYXRpb24gYnkgY2xvc2luZyBpdC5cbiAqIEBwYXJhbSB7bW9kaWZpZXJDbGFzc30gVGhlIGNzcyBtb2RpZmllciBjbGFzcyBmb3IgdGhlIG5vdGlmaWNhdGlvbjsgdGhpcyBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dPbkhlYWRlcihjb250YWluZXJJZCwgbWVzc2FnZSwgbWVzc2FnZUNsaWNrQ2FsbGJhY2sgPSB1bmRlZmluZWQsIGNhbmNlbENhbGxiYWNrID0gdW5kZWZpbmVkLCBtb2RpZmllckNsYXNzID0gdW5kZWZpbmVkKSB7XG5cbiAgY29uc3QgY29udGFpbmVyRSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2NvbnRhaW5lcklkfWApXG4gIGlmICghY29udGFpbmVyRSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGNvbnRhaW5lciB3aXRoIGlkICR7Y29udGFpbmVySWR9YClcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChjb250YWluZXJFKVxuICBjb25zdCBub3RpZmljYXRpb25FbGVtZW50ID0gbmV3IE5vdGlmaWNhdGlvbkhlYWRlcigpXG5cbiAgaWYgKG1vZGlmaWVyQ2xhc3MpIHtcbiAgICBub3RpZmljYXRpb25FbGVtZW50LmFkZENsYXNzKG1vZGlmaWVyQ2xhc3MpXG4gIH1cblxuICBub3RpZmljYXRpb25FbGVtZW50Lm1lc3NhZ2UgPSBtZXNzYWdlXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQubWVzc2FnZUNsaWNrQ2FsbGJhY2sgPSBtZXNzYWdlQ2xpY2tDYWxsYmFja1xuICBub3RpZmljYXRpb25FbGVtZW50LmNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2tcblxuICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbkVsZW1lbnQpXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQuX29wZW4oKVxuXG4gIHJldHVybiBub3RpZmljYXRpb25FbGVtZW50XG59XG5cbi8qKlxuICogVGhlIG5vdGlmaWNhdGlvbiBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTm90aWZpY2F0aW9uSGVhZGVyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJkaXZcIilcblxuICAgIHRoaXMuX2Nsb3NlSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2UgbW9kYWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19OT1RJRklDQVRJT04pXG4gICAgdGhpcy5hZGRDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJub3RpZmljYXRpb25fX2NvbnRlbnRcIilcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm90aWZpY2F0aW9uQ29udGVudClcblxuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uX19ib2R5XCIpXG5cbiAgICBub3RpZmljYXRpb25Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuX25vdGlmaWNhdGlvbkJvZHkpXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbiA9IG5ldyBEb21FbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQlVUVE9OX0NMT1NFKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uLWNhbmNlbFwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJDbG9zZVwiKVxuXG4gICAgY29uc3QgY2xvc2VJY29uID0gbmV3IERvbUVsZW1lbnQoXCJpXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uXCIpXG4gICAgICAuYWRkQ2xhc3MoXCJpY29uLTAyMi1jbG9zZVwiKVxuICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbi5hcHBlbmRDaGlsZChjbG9zZUljb24pXG4gICAgbm90aWZpY2F0aW9uQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9jbG9zZUJ1dHRvbilcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgX2hhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMpXG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICBfaGFuZGxlQ2xvc2UoZXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKHRoaXMuX2NhbmNlbENhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9jYW5jZWxDYWxsYmFjayh0aGlzKVxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgX2Nsb3NlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICB0aGlzLl9jbG9zZUJ1dHRvbi5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbG9zZUhhbmRsZXIpXG5cbiAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGRvbVxuICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbClcbiAgICB9LCAzMDApXG4gIH1cblxuICBfb3BlbigpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG5cbiAgICB0aGlzLl9jbG9zZUJ1dHRvbi5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbG9zZUhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwib3BlbmVkXCIpXG4gIH1cblxuICBzZXQgbWVzc2FnZUNsaWNrQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFja1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhbmNlbCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICovXG4gIHNldCBjYW5jZWxDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYW5jZWxDYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbm90aWZpY2F0aW9uIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBtZXNzYWdlIHRvIHNldC5cbiAgICovXG4gIHNldCBtZXNzYWdlKHZhbHVlKSB7XG4gICAgdGhpcy5fbm90aWZpY2F0aW9uQm9keS5zZXRIdG1sKHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbm90aWZpY2F0aW9uLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fY2xvc2UoKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG59XG4iLCJpbXBvcnQgeyBUd2VlbkxpdGUsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX0hFQURFUiA9IFwiLnByb2dyZXNzLWZ1bGxfX2JhclwiXG5jb25zdCBDTEFTU19TRUNUSU9OUyA9IFwiLnByb2dyZXNzLWZ1bGxfX3NlY3Rpb25zID4gc3BhblwiXG5jb25zdCBDTEFTU19TRUNUSU9OX0FDVElWRSA9IFwic2VjdGlvbi0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SID0gXCJpbmRpY2F0b3JcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQgPSBcImluZGljYXRvci0tY3VycmVudFwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfQ09NUExFVEVEID0gXCJpbmRpY2F0b3ItLWNvbXBsZXRlZFwiXG5cbi8qKlxuICogRnVsbCBwcm9ncmVzcyBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzRnVsbCBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgUHJvZ3Jlc3NGdWxsIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIFByb2dyZXNzRnVsbCBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVCdXR0b25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2hlYWRlckVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfSEVBREVSKVxuXG4gICAgdGhpcy5fcGFnZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19TRUNUSU9OUylcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3ZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gdGhpcy5fcGFnZXMubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcGFnZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodGhpcy5fcGFnZXNbaW5kZXhdLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19TRUNUSU9OX0FDVElWRSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBpbmRleCArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hZGRJbmNpY2F0b3JzKClcbiAgICB0aGlzLl91cGRhdGUoLTEsIHRoaXMuX3ZhbHVlLCBmYWxzZSlcblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIilcbiAgICBpZiAodGFiSW5kZXgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCJcIilcbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICB9XG5cbiAgX2FkZEluY2ljYXRvcnMoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX3BhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgaW5kaWNhdG9yRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1IpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIGkgKyAxKVxuICAgICAgICAuc2V0SHRtbCgoaSArIDEpLnRvU3RyaW5nKCkpXG5cbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQucHJlcGVuZENoaWxkKGluZGljYXRvckVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZShvbGRWYWx1ZSwgbmV3VmFsdWUsIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgbGV0IGluZGljYXRvcnMgPSB0aGlzLl9oZWFkZXJFbGVtZW50LmVsZW1lbnQuY2hpbGROb2Rlc1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGluZGljYXRvcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBsZXQgaW5kaWNhdG9yRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KGluZGljYXRvcnNbaW5kZXhdKVxuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgaW5kaWNhdG9yRWxlbWVudFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ1VSUkVOVClcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMSA9PT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgaW5kaWNhdG9yRWxlbWVudFxuICAgICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ09NUExFVEVEKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfQ1VSUkVOVClcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMSA+IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbGV0IGRpcmVjdGlvbiA9IE1hdGguc2lnbihvbGRWYWx1ZSAtIG5ld1ZhbHVlKVxuXG4gICAgICBpZiAob2xkVmFsdWUgPiAwICYmIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkU2VjdGlvbiA9IG5ldyBEb21FbGVtZW50KHRoaXMuX3BhZ2VzW29sZFZhbHVlIC0gMV0pXG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICBUd2VlbkxpdGUudG8ob2xkU2VjdGlvbi5lbGVtZW50LCAwLjMsIHtcbiAgICAgICAgICAgIGxlZnQ6IDEwMCAqIGRpcmVjdGlvbixcbiAgICAgICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXQsXG4gICAgICAgICAgICBhdXRvQWxwaGE6IDAsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgb2xkU2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdTZWN0aW9uID0gbmV3IERvbUVsZW1lbnQodGhpcy5fcGFnZXNbbmV3VmFsdWUgLSAxXSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgVHdlZW5MaXRlLmZyb20obmV3U2VjdGlvbi5lbGVtZW50LCAwLjMsIHtcbiAgICAgICAgICBsZWZ0OiAtMTAwICogZGlyZWN0aW9uLFxuICAgICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXQsXG4gICAgICAgICAgYXV0b0FscGhhOiAwLFxuICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIG5ld1NlY3Rpb24uYWRkQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VjdGlvbi5hZGRDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgbmV3U2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVCdXR0b25DbGljayhldmVudCkge1xuICAgIGxldCBlbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoZXZlbnQudGFyZ2V0KVxuICAgIGlmICghZWxlbWVudC5oYXNDbGFzcyhDTEFTU19JTkRJQ0FUT1IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgbGV0IGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUKSB7XG4gICAgICB0aGlzLnZhbHVlKytcblxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19MRUZUKSB7XG4gICAgICB0aGlzLnZhbHVlLS1cblxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA+PSBJbnB1dHMuS0VZX05SXzAgJiYga2V5Y29kZSA8PSBJbnB1dHMuS0VZX05SXzkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBrZXljb2RlIC0gSW5wdXRzLktFWV9OUl8wXG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGhlIHByb2dyZXNzIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3ZhbHVlXG5cbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHZhbCwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuICAgIHRoaXMuX3VwZGF0ZShvbGRWYWx1ZSwgdGhpcy5fdmFsdWUsIHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgb24gdGhpcyBjb21wb25lbnQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIucHJvZ3Jlc3MtZnVsbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0Z1bGwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NGdWxsXG4iLCJpbXBvcnQgeyBUd2VlbkxpdGUsIFBvd2VyNCB9IGZyb20gXCJnc2FwXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfQkFSID0gXCIucHJvZ3Jlc3MtbGlnaHRfX2JhclwiXG5jb25zdCBDTEFTU19QUk9HUkVTUyA9IFwiLmJhcl9fcHJvZ3Jlc3NcIlxuY29uc3QgQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEID0gXCJiYXJfX3Byb2dyZXNzLS1jb21wbGV0ZVwiXG5jb25zdCBDTEFTU19USUNLID0gXCJiYXJfX3RpY2tcIlxuY29uc3QgQ0xBU1NfUEFHRV9DVVJSRU5UID0gXCIuZGV0YWlsX19jdXJyZW50cGFnZVwiXG5jb25zdCBDTEFTU19QQUdFX1RPVEFMID0gXCIuZGV0YWlsX190b3RhbHBhZ2VcIlxuXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwiYXJyb3ctLWRpc2FibGVkXCJcbmNvbnN0IENMQVNTX0JVVFRPTl9MRUZUID0gXCIuYXJyb3ctLWxlZnRcIlxuY29uc3QgQ0xBU1NfQlVUVE9OX1JJR0hUID0gXCIuYXJyb3ctLXJpZ2h0XCJcblxuLyoqXG4gKiBMaWdodCBwcm9ncmVzcyBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzTGlnaHQgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFByb2dyZXNzTGlnaHQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgUHJvZ3Jlc3NMaWdodCBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9hZGVyIGJhciBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyID0gdGhpcy5faGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2JhckVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfQkFSKVxuICAgIHRoaXMuX3Byb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QUk9HUkVTUylcbiAgICB0aGlzLl9wYWdlQ3VycmVudEVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfUEFHRV9DVVJSRU5UKVxuICAgIHRoaXMuX3BhZ2VUb3RhbEVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfUEFHRV9UT1RBTClcbiAgICB0aGlzLl9idXR0b25MZWZ0ID0gdGhpcy5maW5kKENMQVNTX0JVVFRPTl9MRUZUKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0ID0gdGhpcy5maW5kKENMQVNTX0JVVFRPTl9SSUdIVClcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gTWF0aC5tYXgocGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJ0b3RhbFwiKSwgMTApLCB0aGlzLl9taW5WYWx1ZSlcbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKFwidmFsdWVcIiksIDEwKSwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuXG4gICAgdGhpcy5fbGF5b3V0KClcblxuICAgIHRoaXMuX2FkZFRpY2tzKClcbiAgICB0aGlzLl91cGRhdGUoZmFsc2UpXG5cbiAgICB0aGlzLmVuYWJsZSgpXG4gIH1cblxuICBfYWRkVGlja3MoKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl90b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2l0ZW1XaWR0aCAqIGlcblxuICAgICAgbGV0IHRpY2tFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RJQ0spXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgbGVmdDogJHtwb3NpdGlvbn0lYClcblxuICAgICAgdGhpcy5fYmFyRWxlbWVudC5wcmVwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZShhbmltYXRlID0gdHJ1ZSkge1xuICAgIHRoaXMuX3BhZ2VDdXJyZW50RWxlbWVudC5zZXRIdG1sKHRoaXMuX3ZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdGhpcy5fcGFnZVRvdGFsRWxlbWVudC5zZXRIdG1sKHRoaXMuX3RvdGFsLnRvU3RyaW5nKCkpXG5cbiAgICBsZXQgcG9zaXRpb24gPSB0aGlzLl92YWx1ZSAqIHRoaXMuX2l0ZW1XaWR0aFxuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgd2lkdGggdG8gdGhlIGxhc3QgZWxlbWVudCB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgcm91bmRlZCBib3JkZXIgb24gdGhlIGxlZnQgaXMgZmlsbGVkIGFzIHdlbGxcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICBwb3NpdGlvbiArPSA1XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlID49IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9idXR0b25SaWdodC5hZGRDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnV0dG9uUmlnaHQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlIDw9IHRoaXMuX21pblZhbHVlKSB7XG4gICAgICB0aGlzLl9idXR0b25MZWZ0LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idXR0b25MZWZ0LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH1cblxuICAgIGlmIChhbmltYXRlKSB7XG4gICAgICBUd2VlbkxpdGUudG8odGhpcy5fcHJvZ3Jlc3NFbGVtZW50LmVsZW1lbnQsIDAuMiwge1xuICAgICAgICB3aWR0aDogYCR7cG9zaXRpb259JWAsXG4gICAgICAgIGVhc2U6IFBvd2VyNC5lYXNlSW5PdXQsXG4gICAgICAgIG9uQ29tcGxldGU6IHRoaXMuX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIFR3ZWVuTGl0ZS5zZXQodGhpcy5fcHJvZ3Jlc3NFbGVtZW50LmVsZW1lbnQsIHtcbiAgICAgICAgd2lkdGg6IGAke3Bvc2l0aW9ufSVgLFxuICAgICAgICBvbkNvbXBsZXRlOiB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5faXRlbVdpZHRoID0gTWF0aC5mbG9vcigxMDAgLyB0aGlzLl90b3RhbClcbiAgfVxuXG4gIF9oYW5kbGVCdXR0b25DbGljayhldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudCkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX3ZhbHVlIC0gMVxuICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9idXR0b25SaWdodC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgKyAxXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZCgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGhlIHByb2dyZXNzIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHZhbCwgdGhpcy5fbWluVmFsdWUsIHRoaXMuX3RvdGFsKVxuICAgIHRoaXMuX3VwZGF0ZSh0cnVlKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRvdGFsIHByb2dyZXNzIHZhbHVlLlxuICAgKi9cbiAgZ2V0IHRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRvdGFsIHByb2dyZXNzIHZhbHVlIGFuZCB1cGRhdGVzIHRoZSBVSSBhY2NvcmRpbmdseS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGhlIHRvdGFsIHByb2dyZXNzIHBvc2l0aXZlIGludGVnZXIgdmFsdWUuXG4gICAqL1xuICBzZXQgdG90YWwodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fdG90YWwgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl90b3RhbCA9IE1hdGgubWF4KHZhbHVlLCB0aGlzLl9taW5WYWx1ZSlcbiAgICB0aGlzLl92YWx1ZSA9IGNsYW1wKHRoaXMuX3ZhbHVlLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG5cbiAgICAvLyBDbGVhciB0aGUgdGhpY2tzXG4gICAgZm9yIChsZXQgdGljayBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS31gKSkge1xuICAgICAgdGhpcy5fYmFyRWxlbWVudC5lbGVtZW50LnJlbW92ZUNoaWxkKHRpY2spXG4gICAgfVxuXG4gICAgdGhpcy5fbGF5b3V0KClcbiAgICB0aGlzLl9hZGRUaWNrcygpXG5cbiAgICB0aGlzLl91cGRhdGUoZmFsc2UpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJ0b3RhbGNoYW5nZWRcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9idXR0b25MZWZ0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9idXR0b25SaWdodC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIucHJvZ3Jlc3MtbGlnaHRcIiwgKGUpID0+IHtcbiAgICBuZXcgUHJvZ3Jlc3NMaWdodChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9ncmVzc0xpZ2h0XG4iLCJpbXBvcnQgeyBUaW1lbGluZUxpdGUsIFBvd2VyNCwgUG93ZXIxIH0gZnJvbSBcImdzYXBcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIG1zSUVWZXJzaW9uIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IGdldEF0dHJpYnV0ZVJlZmVyZW5jZSwgaGFzQ2xhc3MsIHBhcmVudFdpdGhDbGFzcyB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuXG5jb25zdCBRVUVSWV9TRUFSQ0hfSU5QVVQgPSBcImlucHV0LnNlYXJjaF9fZmllbGRcIlxuY29uc3QgUVVFUllfQlROX0NMT1NFID0gXCIuc2VhcmNoX19pY29uLWNsb3NlXCJcblxuY29uc3QgUVVFUllfTElWRV9TVUdFU1RJT05TID0gXCIuanMtc3VnZ2VzdGlvbnNcIlxuY29uc3QgUVVFUllfTElWRV9GT09URVIgPSBcIi5qcy1mb290ZXJcIlxuXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcblxuY29uc3QgQ0xBU1NfU0VBUkNIID0gXCJzZWFyY2hcIlxuXG5jb25zdCBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04gPSAwLjNcbmNvbnN0IEFOSU1BVElPTl9GT09URVJfRFVSQVRJT04gPSAwLjFcblxuLyoqXG4gKiBUaGUgc2VhcmNoIGlucHV0IGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBTZWFyY2hJbnB1dCBleHRlbmRzIERvbUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TRUFSQ0hfSU5QVVQpXG4gICAgdGhpcy5fZm9ybSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVwiKVxuICAgIHRoaXMuX2J0bkNsb3NlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX0NMT1NFKVxuXG4gICAgbGV0IGxpdmVTZWFyY2ggPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGl2ZVwiKVxuICAgIGlmIChsaXZlU2VhcmNoKSB7XG4gICAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9TVUdFU1RJT05TKVxuICAgICAgdGhpcy5fbGl2ZUZvb3RlciA9IGxpdmVTZWFyY2gucXVlcnlTZWxlY3RvcihRVUVSWV9MSVZFX0ZPT1RFUilcbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUlucHV0Qmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcylcbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gdGhpcy5faGFuZGxlUmVzaXplLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIGlmIChtc0lFVmVyc2lvbigpID4gMCkge1xuICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIElFIGJyb3dzZXJzIHdoZXJlIGEgZm9jdXNlZFxuICAgICAgLy8gaW5wdXQncyBjdXJzb3IgYmxlZWRzIHRyb3VnaCBldmVuIGlmIGhpZGRlblxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9idG5DbG9zZSkge1xuICAgICAgdGhpcy5fYnRuQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlSW5wdXRGb2N1cygpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIF9oYW5kbGVJbnB1dEJsdXIoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0XG5cbiAgICBpZiAoIXBhcmVudFdpdGhDbGFzcyh0YXJnZXQsIENMQVNTX1NFQVJDSCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgbGV0IGV2dCA9IGV2dCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlUmVzaXplKCkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCwgbnVsbClcbiAgICBpZiAoc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHRoaXMuX2lucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxuXG4gIF9yZXNldE1haW5UaW1lbGluZSgpIHtcbiAgICBpZiAodGhpcy5fdGxNYWluKSB7XG4gICAgICB0aGlzLl90bE1haW4uc3RvcCgpXG4gICAgfVxuXG4gICAgdGhpcy5fdGxNYWluID0gbmV3IFRpbWVsaW5lTGl0ZSh7XG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3RsTWFpbiA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2VhcmNoIGlucHV0IHRleHQgY29udGVudC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvYWN0aXZhdGVzIHRoZSBzZWFyY2ggaW5wdXQuXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICB0aGlzLl9pbnB1dC5mb2N1cygpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3Nlcy9kZWFjdGl2YXRlcyB0aGUgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fZm9ybS5yZXNldCgpXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuXG4gICAgdGhpcy5jbG9zZUxpdmVTZWFyY2goKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBvcGVuTGl2ZVNlYXJjaCgpIHtcbiAgICBpZiAoIXRoaXMuX2xpdmVTdWdnZXN0aW9ucyB8fCBoYXNDbGFzcyh0aGlzLl9saXZlU3VnZ2VzdGlvbnMsIENMQVNTX09QRU4pID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl90bE1haW4uc2V0KHRoaXMuX2xpdmVTdWdnZXN0aW9ucywge1xuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSlcblxuICAgIHRoaXMuX3RsTWFpbi50byh0aGlzLl9saXZlU3VnZ2VzdGlvbnMsIEFOSU1BVElPTl9TVUdHRVNUSU9OU19EVVJBVElPTiwge1xuICAgICAgY2xhc3NOYW1lOiBgKz0ke0NMQVNTX09QRU59YCxcbiAgICAgIGNsZWFyUHJvcHM6IFwiYWxsXCIsXG4gICAgICBlYXNlOiBbXG4gICAgICAgIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0XG4gICAgICBdXG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl90bE1haW4uc2V0KHRoaXMuX2xpdmVGb290ZXIsIHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICB9LCAwKVxuXG4gICAgICB0aGlzLl90bE1haW4udG8odGhpcy5fbGl2ZUZvb3RlciwgQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTiwge1xuICAgICAgICBjbGFzc05hbWU6IGArPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgICBjbGVhclByb3BzOiBcImhlaWdodCwgZGlzcGxheVwiLFxuICAgICAgICBlYXNlOiBbXG4gICAgICAgICAgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXRcbiAgICAgICAgXVxuICAgICAgfSwgXCItPTAuMVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGxpdmUgc2VhcmNoIHN1Z2dlc3Rpb25zLlxuICAgKi9cbiAgY2xvc2VMaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8IGhhc0NsYXNzKHRoaXMuX2xpdmVTdWdnZXN0aW9ucywgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl90bE1haW4uc2V0KHRoaXMuX2xpdmVTdWdnZXN0aW9ucywge1xuICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgfSlcblxuICAgIGlmICh0aGlzLl9saXZlRm9vdGVyKSB7XG4gICAgICB0aGlzLl90bE1haW4uc2V0KHRoaXMuX2xpdmVGb290ZXIsIHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICB9LCAwKVxuXG4gICAgICB0aGlzLl90bE1haW4udG8odGhpcy5fbGl2ZUZvb3RlciwgQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTiwge1xuICAgICAgICBjbGFzc05hbWU6IGAtPSR7Q0xBU1NfT1BFTn1gLFxuICAgICAgICBjbGVhclByb3BzOiBcImhlaWdodCwgZGlzcGxheVwiLFxuICAgICAgICBlYXNlOiBbXG4gICAgICAgICAgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXRcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLl90bE1haW4udG8odGhpcy5fbGl2ZVN1Z2dlc3Rpb25zLCBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sIHtcbiAgICAgIGNsYXNzTmFtZTogYC09JHtDTEFTU19PUEVOfWAsXG4gICAgICBjbGVhclByb3BzOiBcImFsbFwiLFxuICAgICAgZWFzZTogW1xuICAgICAgICBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dFxuICAgICAgXVxuICAgIH0sIFwiLT0wLjFcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5fYnRuQ2xvc2UpIHtcbiAgICAgIHRoaXMuX2J0bkNsb3NlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbG9zZUhhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXQgPSBudWxsXG4gICAgdGhpcy5fZm9ybSA9IG51bGxcbiAgICB0aGlzLl9idG5DbG9zZSA9IG51bGxcblxuICAgIHRoaXMuX2ZvY3VzSGFuZGxlciA9IG51bGxcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IG51bGxcbiAgICB0aGlzLl9jbG9zZUhhbmRsZXIgPSBudWxsXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kZXIgPSBudWxsXG4gICAgdGhpcy5fa2V5ZG93bkhhbmRsZXIgPSBudWxsXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMgPSBudWxsXG4gICAgdGhpcy5fbGl2ZUZvb3RlciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBTZWFyY2hJbnB1dCBpcyBvcGVuL3Zpc2libGUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gVHJ1ZSBpZiBvcGVuOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5zZWFyY2guc2VhcmNoX19pbnB1dFwiLCAoZSkgPT4ge1xuICAgIG5ldyBTZWFyY2hJbnB1dChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2hJbnB1dFxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX0hFQURFUiA9IFwidGhlYWQgdGhcIlxuXG5jb25zdCBDTEFTU19TT1JURURfQVNDRU5ESU5HID0gXCJqcy1hc2NlbmRpbmdcIlxuY29uc3QgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcgPSBcImpzLWRlc2NlbmRpbmdcIlxuY29uc3QgQ0xBU1NfQVJST1cgPSBcImFycm93LWljb25cIlxuXG4vKipcbiAqIFRoZSBUYWJsZSBjb21wb25lbnQuIEFkZHMgYWRkaXRpb25hbCBjYXBhYmlsaXRpZXMgdG8gc3RhbmRhcmQgSFRNTCA1IHRhYmxlcy5cbiAqL1xuY2xhc3MgVGFibGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgdGFibGUgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVIZWFkZXJDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9ib2R5ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0Ym9keVwiKVxuICAgIHRoaXMuX3Jvd3MgPSB0aGlzLl9ib2R5LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIilcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikpIHtcbiAgICAgIGlmIChoZWFkZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpKSB7XG4gICAgICAgIGhlYWRlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGVhZGVyQ2xpY2tIYW5kbGVyKVxuXG4gICAgICAgIGxldCBhcnJvd0VsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhDTEFTU19BUlJPVylcbiAgICAgICAgICAuZWxlbWVudFxuXG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChhcnJvd0VsZW1lbnQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUhlYWRlckNsaWNrKGUpIHtcbiAgICBjb25zdCB0aCA9IGUudGFyZ2V0XG4gICAgdGhpcy5zb3J0KHRoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIHRoZSB0YWJsZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0YWJsZSBoZWFkZXIgZWxlbWVudC5cbiAgICogVGhlIGNvbHVtbiBpcyBzb3J0ZWQgYXNjZW5kaW5nIGJ5IGRlZmF1bHQgaWYgbm8gZGlyZWN0aW9uIGlzIHNwZWNpZmllZCBhbmQgbm9cbiAgICogZXhpc3Rpbmcgc29ydCBvcmRlciBjbGFzcyBpcyBmb3VuZCBpbiB0aGUgbWFya3VwLlxuICAgKlxuICAgKiBJZiB0aGUgZGlzcGxheWVkIGRhdGEgaXMgbm90IHN1aXRhYmxlIGZvciBzb3J0aW5nIGA8dGQvPmAgZWxlbWVudHMgY2FuIGRlZmluZSBhIGBkYXRhLXZhbHVlYCBhdHRyaWJ1dGVcbiAgICogd2hpY2ggaXMgdGhlbiB1c2VkIGZvciB0aGUgZGF0YS1zb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFibGVIZWFkZXJ9IHRhYmxlSGVhZGVyIFRoZSBoZWFkZXIgZWxlbWVudCBvZiB0aGUgcm93IHRvIHNvcnQgYnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBzb3J0LCBgMWAgZm9yIGFzY2VuZGluZywgYC0xYCBmb3IgZGVzY2VuZGluZyBvcmRlci4gVGhpcyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGVxdWFsaXR5Q29tcGFyZXIgVGhlIGVxdWlhbGl0eSBjb21wYXJlciBmdW5jdGlvbiB0byBjb21wYXJlIGluZGl2aWR1YWwgY2VsbCB2YWx1ZXMuXG4gICAqL1xuICBzb3J0KHRhYmxlSGVhZGVyLCBkaXJlY3Rpb24gPSB1bmRlZmluZWQsIGVxdWFsaXR5Q29tcGFyZXIgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXRhYmxlSGVhZGVyIHx8IHRhYmxlSGVhZGVyLnRhZ05hbWUgIT09IFwiVEhcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhcmFtZXRlciAndGFibGVIZWFkZXInIG11c3QgYmUgYSB2YWxpZCBjb2x1bW4gaGVhZGVyIG5vZGVcIilcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAxICYmIGRpcmVjdGlvbiAhPT0gLTEgJiYgZGlyZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBvdXQgb2YgcmFuZ2UsIHBhcmFtZXRlciAnZGlyZWN0aW9uJyB3aXRoIHZhbHVlICcke2RpcmVjdGlvbn0nIG11c3QgYmUgZWl0aGVyIC0xLCAxIG9yIHVuZGVmaW5lZGApXG4gICAgfVxuXG4gICAgY29uc3QgY29sdW1uSW5kZXggPSB0YWJsZUhlYWRlci5jZWxsSW5kZXhcblxuICAgIGlmICghZXF1YWxpdHlDb21wYXJlcikge1xuICAgICAgbGV0IGRhdGFUeXBlID0gdGFibGVIZWFkZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpXG4gICAgICBlcXVhbGl0eUNvbXBhcmVyID0gdGhpcy5fZ2V0Q29tcGFyZXIoZGF0YVR5cGUpXG4gICAgfVxuXG4gICAgaWYgKGNvbHVtbkluZGV4ID49IHRoaXMuX3Jvd3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gb3V0IG9mIHJhbmdlXCIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0hFQURFUikpIHtcbiAgICAgIGlmIChoZWFkZXIgIT09IHRhYmxlSGVhZGVyKSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhoZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhoZWFkZXIsIENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChEb20uaGFzQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpKSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9BU0NFTkRJTkcpXG4gICAgICBEb20uYWRkQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HKVxuXG4gICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24gfHwgLTFcbiAgICB9IGVsc2Uge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfREVTQ0VORElORylcbiAgICAgIERvbS5hZGRDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0FTQ0VORElORylcbiAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAxXG4gICAgfVxuXG4gICAgdGhpcy5fcXVpY2tzb3J0KGNvbHVtbkluZGV4LCAwLCB0aGlzLl9yb3dzLmxlbmd0aCAtIDEsIGRpcmVjdGlvbiwgZXF1YWxpdHlDb21wYXJlcilcbiAgfVxuXG4gIF9nZXRDZWxsKGNvbHVtbiwgcm93KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3Nbcm93XS5jZWxsc1tjb2x1bW5dXG4gIH1cblxuICBfZ2V0Um93KHJvdykge1xuICAgIHJldHVybiB0aGlzLl9yb3dzW3Jvd11cbiAgfVxuXG4gIF9nZXRDb21wYXJlcihkYXRhVHlwZSkge1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjoge1xuICAgICAgICAvLyBwYXJzZSB0aGUgc3RyaW5nIGFzIGEgbnVtYmVyXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYilcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gY29tcGFyZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhID4gYikge1xuICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3F1aWNrc29ydChjb2x1bW4sIGxlZnQsIHJpZ2h0LCBkaXJlY3Rpb24gPSAxLCBlcXVhbGl0eUNvbXBhcmVyKSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDEpIHtcblxuICAgICAgbGV0IHBhcnRpdGlvbiA9IHRoaXMuX3BhcnRpdGlvbihjb2x1bW4sIGxlZnQsIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG5cbiAgICAgIGlmIChsZWZ0IDwgcGFydGl0aW9uIC0gMSkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBsZWZ0LCBwYXJ0aXRpb24gLSAxLCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0aXRpb24gPCByaWdodCkge1xuICAgICAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uLCBwYXJ0aXRpb24sIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3BhcnRpdGlvbihjb2x1bW4sIGxlZnQsIHJpZ2h0LCBkaXJlY3Rpb24sIGVxdWFsaXR5Q29tcGFyZXIpIHtcbiAgICBsZXQgcGl2b3QgPSB0aGlzLl9nZXRDZWxsKGNvbHVtbiwgTWF0aC5mbG9vcigocmlnaHQgKyBsZWZ0KSAvIDIpKVxuICAgIGxldCBpID0gbGVmdFxuICAgIGxldCBqID0gcmlnaHRcblxuICAgIHdoaWxlIChpIDw9IGopIHtcbiAgICAgIHdoaWxlICh0aGlzLl9lcXVhbHModGhpcy5fZ2V0Q2VsbChjb2x1bW4sIGkpLCBwaXZvdCwgZXF1YWxpdHlDb21wYXJlcikgKiBkaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgIGkrK1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpcy5fZXF1YWxzKHRoaXMuX2dldENlbGwoY29sdW1uLCBqKSwgcGl2b3QsIGVxdWFsaXR5Q29tcGFyZXIpICogZGlyZWN0aW9uID4gMCkge1xuICAgICAgICBqLS1cbiAgICAgIH1cblxuICAgICAgaWYgKGkgPD0gaikge1xuICAgICAgICB0aGlzLl9zd2FwKGksIGopXG4gICAgICAgIGkrK1xuICAgICAgICBqLS1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgX2VxdWFscyhhLCBiLCBlcXVhbGl0eUNvbXBhcmVyKSB7XG4gICAgbGV0IGRhdGFBID0gYS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG4gICAgbGV0IGRhdGFCID0gYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpXG5cbiAgICBkYXRhQSA9IGRhdGFBIHx8IGEudGV4dENvbnRlbnQgfHwgYS5pbm5lclRleHRcbiAgICBkYXRhQiA9IGRhdGFCIHx8IGIudGV4dENvbnRlbnQgfHwgYi5pbm5lclRleHRcblxuICAgIHJldHVybiBlcXVhbGl0eUNvbXBhcmVyKGRhdGFBLCBkYXRhQilcbiAgfVxuXG4gIF9zd2FwKGksIGopIHtcbiAgICBsZXQgdG1wTm9kZSA9IHRoaXMuX2JvZHkucmVwbGFjZUNoaWxkKHRoaXMuX2dldFJvdyhpKSwgdGhpcy5fZ2V0Um93KGopKVxuICAgIGNvbnN0IHJlZmVyZW5jZVJvdyA9IHRoaXMuX2dldFJvdyhpKVxuXG4gICAgaWYgKCFyZWZlcmVuY2VSb3cpIHtcbiAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQodG1wTm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keS5pbnNlcnRCZWZvcmUodG1wTm9kZSwgcmVmZXJlbmNlUm93KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGhlYWRlciBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9IRUFERVIpKSB7XG4gICAgICBoZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hlYWRlckNsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIgPSBudWxsXG4gICAgdGhpcy5fYm9keSA9IG51bGxcbiAgICB0aGlzLl9yb3dzID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwidGFibGVcIiwgKGUpID0+IHtcbiAgICBuZXcgVGFibGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFibGVcbiIsImltcG9ydCB7IFRpbWVsaW5lTGl0ZSB9IGZyb20gXCJnc2FwXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfSVRFTVMgPSBcIi50b29sYmFyX19pdGVtXCJcbmNvbnN0IENMQVNTX1NIT1cgPSBcIml0ZW0tLXNob3dcIlxuXG5jb25zdCBBTklNQVRJT05fU1RBUlRfREVMQVkgPSAwLjFcbmNvbnN0IEFOSU1BVElPTl9PRkZTRVQgPSAwLjA1XG5cbi8qKlxuICogVG9vbGJhciBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBzaG93IGFuZCBoaWRlIHRoZVxuICogaW5kaXZpZHVhbCB0b29sYmFyIGl0ZW1zLlxuICovXG5jbGFzcyBUb29sYmFyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIE1ha2VzIHRoZSB0b29sYmFyIGl0ZW1zIHZpc2libGUuXG4gICAqL1xuICBzaG93KCkge1xuICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuICAgIGxldCBpdGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0lURU1TKVxuXG4gICAgbGV0IHRpbWVsaW5lID0gbmV3IFRpbWVsaW5lTGl0ZSgpXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdGltZWxpbmUudG8oaXRlbXNbaW5kZXhdLCAwLCB7IGNsYXNzTmFtZTogYCs9JHtDTEFTU19TSE9XfWAgfSwgZGVsYXkpXG4gICAgICBkZWxheSArPSBBTklNQVRJT05fT0ZGU0VUXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSB0b29sYmFyIGl0ZW1zLlxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBsZXQgZGVsYXkgPSBBTklNQVRJT05fU1RBUlRfREVMQVlcbiAgICBsZXQgaXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19JVEVNUylcblxuICAgIGxldCB0aW1lbGluZSA9IG5ldyBUaW1lbGluZUxpdGUoKVxuICAgIGZvciAobGV0IGluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgdGltZWxpbmUudG8oaXRlbXNbaW5kZXhdLCAwLCB7IGNsYXNzTmFtZTogYC09JHtDTEFTU19TSE9XfWAgfSwgZGVsYXkpXG4gICAgICBkZWxheSArPSBBTklNQVRJT05fT0ZGU0VUXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHRvb2xiYXIgaXRlbXMgdmlzaWJpbGl0eS5cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1NIT1d9YCkubGVuZ3RoICA9PT0gMCkge1xuICAgICAgdGhpcy5zaG93KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhclxuIiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9tYXRoL3RydW5jXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW5cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21heC1zYWZlLWludGVnZXJcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9mcm9tID0gcmVxdWlyZShcIi4uL2NvcmUtanMvYXJyYXkvZnJvbVwiKTtcblxudmFyIF9mcm9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Zyb20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tOyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk1hdGguc2lnbjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5NYXRoLnRydW5jOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk51bWJlci5pc05hTjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlcicpO1xubW9kdWxlLmV4cG9ydHMgPSAweDFmZmZmZmZmZmZmZmZmOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7IiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTsiLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07IiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge307IiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGluZGV4KWlmKE9ba2V5ID0ga2V5c1tpbmRleCsrXV0gPT09IGVsKXJldHVybiBrZXk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59OyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07IiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsiLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59OyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTsiLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTsiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsiLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07IiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7IiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07IiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXQgICAgICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKVxuICAsIGdldEl0ZXJGbiAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7IiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjQgTnVtYmVyLmlzTmFOKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZ9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7IiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpe1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pOyIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7IiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufSIsIi8qIVxuICogVkVSU0lPTjogMS4xOS4xXG4gKiBEQVRFOiAyMDE3LTAxLTE3XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICogXG4gKiBJbmNsdWRlcyBhbGwgb2YgdGhlIGZvbGxvd2luZzogVHdlZW5MaXRlLCBUd2Vlbk1heCwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCwgRWFzZVBhY2ssIENTU1BsdWdpbiwgUm91bmRQcm9wc1BsdWdpbiwgQmV6aWVyUGx1Z2luLCBBdHRyUGx1Z2luLCBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTcsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlID0gKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93OyAvL2hlbHBzIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggQU1EL1JlcXVpcmVKUyBhbmQgQ29tbW9uSlMvTm9kZVxuKF9nc1Njb3BlLl9nc1F1ZXVlIHx8IChfZ3NTY29wZS5fZ3NRdWV1ZSA9IFtdKSkucHVzaCggZnVuY3Rpb24oKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiVHdlZW5NYXhcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgX3NsaWNlID0gZnVuY3Rpb24oYSkgeyAvL2Rvbid0IHVzZSBbXS5zbGljZSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSk7XG5cdFx0XHRcdHJldHVybiBiO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseUN5Y2xlID0gZnVuY3Rpb24odmFycywgdGFyZ2V0cywgaSkge1xuXHRcdFx0XHR2YXIgYWx0ID0gdmFycy5jeWNsZSxcblx0XHRcdFx0XHRwLCB2YWw7XG5cdFx0XHRcdGZvciAocCBpbiBhbHQpIHtcblx0XHRcdFx0XHR2YWwgPSBhbHRbcF07XG5cdFx0XHRcdFx0dmFyc1twXSA9ICh0eXBlb2YodmFsKSA9PT0gXCJmdW5jdGlvblwiKSA/IHZhbChpLCB0YXJnZXRzW2ldKSA6IHZhbFtpICUgdmFsLmxlbmd0aF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHZhcnMuY3ljbGU7XG5cdFx0XHR9LFxuXHRcdFx0VHdlZW5NYXggPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5jYWxsKHRoaXMsIHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTsgLy9lbnN1cmVzIHRoYXQgaWYgdGhlcmUgaXMgYW55IHJlcGVhdCwgdGhlIHRvdGFsRHVyYXRpb24gd2lsbCBnZXQgcmVjYWxjdWxhdGVkIHRvIGFjY3VyYXRlbHkgcmVwb3J0IGl0LlxuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTWF4LnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0cCA9IFR3ZWVuTWF4LnByb3RvdHlwZSA9IFR3ZWVuTGl0ZS50byh7fSwgMC4xLCB7fSksXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdO1xuXG5cdFx0VHdlZW5NYXgudmVyc2lvbiA9IFwiMS4xOS4xXCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFR3ZWVuTWF4LmtpbGxUd2VlbnNPZiA9IFR3ZWVuTWF4LmtpbGxEZWxheWVkQ2FsbHNUbyA9IFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXguZ2V0VHdlZW5zT2YgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXgubGFnU21vb3RoaW5nID0gVHdlZW5MaXRlLmxhZ1Ntb290aGluZztcblx0XHRUd2Vlbk1heC50aWNrZXIgPSBUd2VlbkxpdGUudGlja2VyO1xuXHRcdFR3ZWVuTWF4LnJlbmRlciA9IFR3ZWVuTGl0ZS5yZW5kZXI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5MaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnVwZGF0ZVRvID0gZnVuY3Rpb24odmFycywgcmVzZXREdXJhdGlvbikge1xuXHRcdFx0dmFyIGN1clJhdGlvID0gdGhpcy5yYXRpbyxcblx0XHRcdFx0aW1tZWRpYXRlID0gdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCB2YXJzLmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0cDtcblx0XHRcdGlmIChyZXNldER1cmF0aW9uICYmIHRoaXMuX3N0YXJ0VGltZSA8IHRoaXMuX3RpbWVsaW5lLl90aW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX3RpbWVsaW5lLl90aW1lO1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdGlmIChyZXNldER1cmF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCAmJiB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpOyAvL2luIGNhc2UgYSBwbHVnaW4gbGlrZSBNb3Rpb25CbHVyIG11c3QgcGVyZm9ybSBzb21lIGNsZWFudXAgdGFza3Ncblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgLyB0aGlzLl9kdXJhdGlvbiA+IDAuOTk4KSB7IC8vaWYgdGhlIHR3ZWVuIGhhcyBmaW5pc2hlZCAob3IgY29tZSBleHRyZW1lbHkgY2xvc2UgdG8gZmluaXNoaW5nKSwgd2UganVzdCBuZWVkIHRvIHJld2luZCBpdCB0byAwIGFuZCB0aGVuIHJlbmRlciBpdCBhZ2FpbiBhdCB0aGUgZW5kIHdoaWNoIGZvcmNlcyBpdCB0byByZS1pbml0aWFsaXplIChwYXJzaW5nIHRoZSBuZXcgdmFycykuIFdlIGFsbG93IHR3ZWVucyB0aGF0IGFyZSBjbG9zZSB0byBmaW5pc2hpbmcgKGJ1dCBoYXZlbid0IHF1aXRlIGZpbmlzaGVkKSB0byB3b3JrIHRoaXMgd2F5IHRvbyBiZWNhdXNlIG90aGVyd2lzZSwgdGhlIHZhbHVlcyBhcmUgc28gc21hbGwgd2hlbiBkZXRlcm1pbmluZyB3aGVyZSB0byBwcm9qZWN0IHRoZSBzdGFydGluZyB2YWx1ZXMgdGhhdCBiaW5hcnkgbWF0aCBpc3N1ZXMgY3JlZXAgaW4gYW5kIGNhbiBtYWtlIHRoZSB0d2VlbiBhcHBlYXIgdG8gcmVuZGVyIGluY29ycmVjdGx5IHdoZW4gcnVuIGJhY2t3YXJkcy4gXG5cdFx0XHRcdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IDAgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbnYgPSAxIC8gKDEgLSBjdXJSYXRpbyksXG5cdFx0XHRcdFx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULCBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdFx0XHRwdC5jICo9IGludjtcblx0XHRcdFx0XHRcdFx0XHRwdC5zID0gZW5kVmFsdWUgLSBwdC5jO1xuXHRcdFx0XHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLnZhcnMucmVwZWF0KSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgaGF2ZSByZW5kZXIoKSBjYWxsZWQgZnJvbSBUd2VlbkxpdGUncyBjb25zdHJ1Y3RvciwgYmVmb3JlIFR3ZWVuTWF4J3MgY29uc3RydWN0b3IgaGFzIGZpbmlzaGVkIHNldHRpbmcgX3JlcGVhdCwgX3JlcGVhdERlbGF5LCBhbmQgX3lveW8gd2hpY2ggYXJlIGNyaXRpY2FsIGluIGRldGVybWluaW5nIHRvdGFsRHVyYXRpb24oKSBzbyB3ZSBuZWVkIHRvIGNhbGwgaW52YWxpZGF0ZSgpIHdoaWNoIGlzIGEgbG93LWtiIHdheSB0byBnZXQgdGhvc2Ugc2V0IHByb3Blcmx5LlxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsIFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgY3ljbGVEdXJhdGlvbiwgciwgdHlwZSwgcG93LCByYXdQcmV2VGltZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxICYmIHRpbWUgPj0gMCkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHRoaXMuX3JlcGVhdDtcblx0XHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25Db21wbGV0ZVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKGZvcmNlIHx8IHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbik7IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0VGltZSA9PT0gdGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uKSB7IC8vaWYgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGlzIGF0IHRoZSBWRVJZIGVuZCBvZiBhIHRpbWVsaW5lIGFuZCB0aGF0IHRpbWVsaW5lIHJlbmRlcnMgYXQgaXRzIGVuZCwgaXQgd2lsbCB0eXBpY2FsbHkgYWRkIGEgdGlueSBiaXQgb2YgY3VzaGlvbiB0byB0aGUgcmVuZGVyIHRpbWUgdG8gcHJldmVudCByb3VuZGluZyBlcnJvcnMgZnJvbSBnZXR0aW5nIGluIHRoZSB3YXkgb2YgdHdlZW5zIHJlbmRlcmluZyB0aGVpciBWRVJZIGVuZC4gSWYgd2UgdGhlbiByZXZlcnNlKCkgdGhhdCB0aW1lbGluZSwgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gd2lsbCB0cmlnZ2VyIGl0cyBvblJldmVyc2VDb21wbGV0ZSBldmVuIHRob3VnaCB0ZWNobmljYWxseSB0aGUgcGxheWhlYWQgZGlkbid0IHBhc3Mgb3ZlciBpdCBhZ2Fpbi4gSXQncyBhIHZlcnkgc3BlY2lmaWMgZWRnZSBjYXNlIHdlIG11c3QgYWNjb21tb2RhdGUuXG5cdFx0XHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA8IDAgfHwgKHRpbWUgPD0gMCAmJiB0aW1lID49IC0wLjAwMDAwMDEpIHx8IChwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSAhPT0gXCJpc1BhdXNlXCIpKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lKSB7IC8vbm90ZTogd2hlbiB0aGlzLmRhdGEgaXMgXCJpc1BhdXNlXCIsIGl0J3MgYSBjYWxsYmFjayBhZGRlZCBieSBhZGRQYXVzZSgpIG9uIGEgdGltZWxpbmUgdGhhdCB3ZSBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCB3aGVuIExFQVZJTkcgaXRzIGV4YWN0IHN0YXJ0IHRpbWUuIEluIG90aGVyIHdvcmRzLCB0bC5hZGRQYXVzZSgxKS5wbGF5KDEpIHNob3VsZG4ndCBwYXVzZS5cblx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByYXdQcmV2VGltZSA9ICghc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCBwcmV2UmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLl9jYWxjRW5kID8gdGhpcy5fZWFzZS5nZXRSYXRpbygwKSA6IDA7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSAwIHx8IChkdXJhdGlvbiA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPiAwKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gMCkgaWYgKHRoaXMuX2N5Y2xlID09PSB0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uICYmIHByZXZUb3RhbFRpbWUgPD0gdGltZSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSAtICh0aGlzLl9jeWNsZSAqIGN5Y2xlRHVyYXRpb24pO1xuXHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXJhdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fZWFzZVR5cGUpIHtcblx0XHRcdFx0XHRyID0gdGhpcy5fdGltZSAvIGR1cmF0aW9uO1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLl9lYXNlVHlwZTtcblx0XHRcdFx0XHRwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHByZXZUaW1lID09PSB0aGlzLl90aW1lICYmICFmb3JjZSAmJiBwcmV2Q3ljbGUgPT09IHRoaXMuX2N5Y2xlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7IC8vd2Ugc3RpY2sgaXQgaW4gdGhlIHF1ZXVlIGZvciByZW5kZXJpbmcgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSB0aWNrIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBiZWNhdXNlIGJyb3dzZXJzIGludmFsaWRhdGUgc3R5bGVzIGFuZCBmb3JjZSBhIHJlY2FsY3VsYXRpb24gaWYgeW91IHJlYWQsIHdyaXRlLCBhbmQgdGhlbiByZWFkIHN0eWxlIGRhdGEgKHNvIGl0J3MgYmV0dGVyIHRvIHJlYWQvcmVhZC9yZWFkL3dyaXRlL3dyaXRlL3dyaXRlIHRoYW4gcmVhZC93cml0ZS9yZWFkL3dyaXRlL3JlYWQvd3JpdGUpLiBUaGUgZG93biBzaWRlLCBvZiBjb3Vyc2UsIGlzIHRoYXQgdXN1YWxseSB5b3UgV0FOVCB0aGluZ3MgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGJlY2F1c2UgeW91IG1heSBoYXZlIGNvZGUgcnVubmluZyByaWdodCBhZnRlciB0aGF0IHdoaWNoIGRlcGVuZHMgb24gdGhlIGNoYW5nZS4gTGlrZSBpbWFnaW5lIHJ1bm5pbmcgVHdlZW5MaXRlLnNldCguLi4pIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoYXQsIGNyZWF0aW5nIGEgbm90aGVyIHR3ZWVuIHRoYXQgYW5pbWF0ZXMgdGhlIHNhbWUgcHJvcGVydHkgdG8gYW5vdGhlciB2YWx1ZTsgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGF0IDJuZCB0d2VlbiB3b3VsZG4ndCBiZSBhY2N1cmF0ZSBpZiBsYXp5IGlzIHRydWUuXG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZUb3RhbFRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzQ29tcGxldGUgJiYgdGhpcy5fZWFzZS5fY2FsY0VuZCkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKCh0aGlzLl90aW1lID09PSAwKSA/IDAgOiAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2xhenkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPj0gMCkge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSB0cnVlOyAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRvdGFsVGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5faW5pdHRlZCA9PT0gMiAmJiB0aW1lID4gMCkge1xuXHRcdFx0XHRcdC8vdGhpcy5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdFx0dGhpcy5faW5pdCgpOyAvL3dpbGwganVzdCBhcHBseSBvdmVyd3JpdGluZyBzaW5jZSBfaW5pdHRlZCBvZiAoMikgbWVhbnMgaXQgd2FzIGEgZnJvbSgpIHR3ZWVuIHRoYXQgaGFkIGltbWVkaWF0ZVJlbmRlcjp0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwiX2R1bW15R1NcIjsgLy9pZiBubyBjYWxsYmFjayBpcyBkZWZpbmVkLCB1c2UgYSBkdW1teSB2YWx1ZSBqdXN0IHNvIHRoYXQgdGhlIGNvbmRpdGlvbiBhdCB0aGUgZW5kIGV2YWx1YXRlcyBhcyB0cnVlIGJlY2F1c2UgX3N0YXJ0QXQgc2hvdWxkIHJlbmRlciBBRlRFUiB0aGUgbm9ybWFsIHJlbmRlciBsb29wIHdoZW4gdGhlIHRpbWUgaXMgbmVnYXRpdmUuIFdlIGNvdWxkIGhhbmRsZSB0aGlzIGluIGEgbW9yZSBpbnR1aXRpdmUgd2F5LCBvZiBjb3Vyc2UsIGJ1dCB0aGUgcmVuZGVyIGxvb3AgaXMgdGhlIE1PU1QgaW1wb3J0YW50IHRoaW5nIHRvIG9wdGltaXplLCBzbyB0aGlzIHRlY2huaXF1ZSBhbGxvd3MgdXMgdG8gYXZvaWQgYWRkaW5nIGV4dHJhIGNvbmRpdGlvbmFsIGxvZ2ljIGluIGEgaGlnaC1mcmVxdWVuY3kgYXJlYS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdG90YWxUaW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdHB0LnRbcHQucF0ocHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYyAqIHRoaXMucmF0aW8gKyBwdC5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDApIGlmICh0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0VGltZSkgeyAvL2lmIHRoZSB0d2VlbiBpcyBwb3NpdGlvbmVkIGF0IHRoZSBWRVJZIGJlZ2lubmluZyAoX3N0YXJ0VGltZSAwKSBvZiBpdHMgcGFyZW50IHRpbWVsaW5lLCBpdCdzIGlsbGVnYWwgZm9yIHRoZSBwbGF5aGVhZCB0byBnbyBiYWNrIGZ1cnRoZXIsIHNvIHdlIHNob3VsZCBub3QgcmVuZGVyIHRoZSByZWNvcmRlZCBzdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgfHwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykgaWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG4vLy0tLS0gU1RBVElDIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdFR3ZWVuTWF4LnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmZyb20gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heCh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlclRvID0gVHdlZW5NYXguYWxsVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0dmFyIGRlbGF5ID0gMCxcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRmaW5hbENvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKHZhcnMub25Db21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dmFycy5vbkNvbXBsZXRlLmFwcGx5KHZhcnMub25Db21wbGV0ZVNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9uQ29tcGxldGVBbGwuYXBwbHkob25Db21wbGV0ZUFsbFNjb3BlIHx8IHZhcnMuY2FsbGJhY2tTY29wZSB8fCB0aGlzLCBvbkNvbXBsZXRlQWxsUGFyYW1zIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y3ljbGUgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRmcm9tQ3ljbGUgPSAodmFycy5zdGFydEF0ICYmIHZhcnMuc3RhcnRBdC5jeWNsZSksXG5cdFx0XHRcdGwsIGNvcHksIGksIHA7XG5cdFx0XHRpZiAoIV9pc0FycmF5KHRhcmdldHMpKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YodGFyZ2V0cykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7XG5cdFx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGggLSAxO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdGNvcHlbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjeWNsZSkge1xuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHksIHRhcmdldHMsIGkpO1xuXHRcdFx0XHRcdGlmIChjb3B5LmR1cmF0aW9uICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uID0gY29weS5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdGRlbGV0ZSBjb3B5LmR1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZnJvbUN5Y2xlKSB7XG5cdFx0XHRcdFx0ZnJvbUN5Y2xlID0gY29weS5zdGFydEF0ID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMuc3RhcnRBdCkge1xuXHRcdFx0XHRcdFx0ZnJvbUN5Y2xlW3BdID0gdmFycy5zdGFydEF0W3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfYXBwbHlDeWNsZShjb3B5LnN0YXJ0QXQsIHRhcmdldHMsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkuZGVsYXkgPSBkZWxheSArIChjb3B5LmRlbGF5IHx8IDApO1xuXHRcdFx0XHRpZiAoaSA9PT0gbCAmJiBvbkNvbXBsZXRlQWxsKSB7XG5cdFx0XHRcdFx0Y29weS5vbkNvbXBsZXRlID0gZmluYWxDb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFR3ZWVuTWF4KHRhcmdldHNbaV0sIGR1cmF0aW9uLCBjb3B5KTtcblx0XHRcdFx0ZGVsYXkgKz0gc3RhZ2dlcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb20gPSBUd2Vlbk1heC5hbGxGcm9tID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIFR3ZWVuTWF4LnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnN0YWdnZXJGcm9tVG8gPSBUd2Vlbk1heC5hbGxGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSk7XG5cdFx0fTtcblx0XHRcdFx0XG5cdFx0VHdlZW5NYXguZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2Vlbk1heChjYWxsYmFjaywgMCwge2RlbGF5OmRlbGF5LCBvbkNvbXBsZXRlOmNhbGxiYWNrLCBvbkNvbXBsZXRlUGFyYW1zOnBhcmFtcywgY2FsbGJhY2tTY29wZTpzY29wZSwgb25SZXZlcnNlQ29tcGxldGU6Y2FsbGJhY2ssIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOnBhcmFtcywgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCB1c2VGcmFtZXM6dXNlRnJhbWVzLCBvdmVyd3JpdGU6MH0pO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5pc1R3ZWVuaW5nID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gKFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQsIHRydWUpLmxlbmd0aCA+IDApO1xuXHRcdH07XG5cdFx0XG5cdFx0dmFyIF9nZXRDaGlsZHJlbk9mID0gZnVuY3Rpb24odGltZWxpbmUsIGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRcdHR3ZWVuID0gdGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQoX2dldENoaWxkcmVuT2YodHdlZW4sIGluY2x1ZGVUaW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSwgXG5cdFx0XHRnZXRBbGxUd2VlbnMgPSBUd2Vlbk1heC5nZXRBbGxUd2VlbnMgPSBmdW5jdGlvbihpbmNsdWRlVGltZWxpbmVzKSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykuY29uY2F0KCBfZ2V0Q2hpbGRyZW5PZihBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykgKTtcblx0XHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbEFsbCA9IGZ1bmN0aW9uKGNvbXBsZXRlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAodHdlZW5zID09IG51bGwpIHtcblx0XHRcdFx0dHdlZW5zID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChkZWxheWVkQ2FsbHMgPT0gbnVsbCkge1xuXHRcdFx0XHRkZWxheWVkQ2FsbHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBnZXRBbGxUd2VlbnMoKHRpbWVsaW5lcyAhPSBmYWxzZSkpLFxuXHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpc0RDLCB0d2VlbiwgaTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dHdlZW4gPSBhW2ldO1xuXHRcdFx0XHRpZiAoYWxsVHJ1ZSB8fCAodHdlZW4gaW5zdGFuY2VvZiBTaW1wbGVUaW1lbGluZSkgfHwgKChpc0RDID0gKHR3ZWVuLnRhcmdldCA9PT0gdHdlZW4udmFycy5vbkNvbXBsZXRlKSkgJiYgZGVsYXllZENhbGxzKSB8fCAodHdlZW5zICYmICFpc0RDKSkge1xuXHRcdFx0XHRcdGlmIChjb21wbGV0ZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4udG90YWxUaW1lKHR3ZWVuLl9yZXZlcnNlZCA/IDAgOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YgPSBmdW5jdGlvbihwYXJlbnQsIGNvbXBsZXRlKSB7XG5cdFx0XHRpZiAocGFyZW50ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gVHdlZW5MaXRlSW50ZXJuYWxzLnR3ZWVuTG9va3VwLFxuXHRcdFx0XHRhLCBjdXJQYXJlbnQsIHAsIGksIGw7XG5cdFx0XHRpZiAodHlwZW9mKHBhcmVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cGFyZW50ID0gVHdlZW5MaXRlLnNlbGVjdG9yKHBhcmVudCkgfHwgcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHBhcmVudCkpIHtcblx0XHRcdFx0cGFyZW50ID0gX3NsaWNlKHBhcmVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzQXJyYXkocGFyZW50KSkge1xuXHRcdFx0XHRpID0gcGFyZW50Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0VHdlZW5NYXgua2lsbENoaWxkVHdlZW5zT2YocGFyZW50W2ldLCBjb21wbGV0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0YSA9IFtdO1xuXHRcdFx0Zm9yIChwIGluIHRsKSB7XG5cdFx0XHRcdGN1clBhcmVudCA9IHRsW3BdLnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdFx0XHR3aGlsZSAoY3VyUGFyZW50KSB7XG5cdFx0XHRcdFx0aWYgKGN1clBhcmVudCA9PT0gcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodGxbcF0udHdlZW5zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3VyUGFyZW50ID0gY3VyUGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0YVtpXS50b3RhbFRpbWUoYVtpXS50b3RhbER1cmF0aW9uKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIF9jaGFuZ2VQYXVzZSA9IGZ1bmN0aW9uKHBhdXNlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHR0d2VlbnMgPSAodHdlZW5zICE9PSBmYWxzZSk7XG5cdFx0XHRkZWxheWVkQ2FsbHMgPSAoZGVsYXllZENhbGxzICE9PSBmYWxzZSk7XG5cdFx0XHR0aW1lbGluZXMgPSAodGltZWxpbmVzICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucyh0aW1lbGluZXMpLFxuXHRcdFx0XHRhbGxUcnVlID0gKHR3ZWVucyAmJiBkZWxheWVkQ2FsbHMgJiYgdGltZWxpbmVzKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoLFxuXHRcdFx0XHRpc0RDLCB0d2Vlbjtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0dHdlZW4ucGF1c2VkKHBhdXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXgucGF1c2VBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UodHJ1ZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5yZXN1bWVBbGwgPSBmdW5jdGlvbih0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKSB7XG5cdFx0XHRfY2hhbmdlUGF1c2UoZmFsc2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpO1xuXHRcdH07XG5cblx0XHRUd2Vlbk1heC5nbG9iYWxUaW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIHRsID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUsXG5cdFx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLnRpbWU7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRsLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHZhbHVlIHx8IF90aW55TnVtOyAvL2Nhbid0IGFsbG93IHplcm8gYmVjYXVzZSBpdCdsbCB0aHJvdyB0aGUgbWF0aCBvZmZcblx0XHRcdHRsLl9zdGFydFRpbWUgPSB0IC0gKCh0IC0gdGwuX3N0YXJ0VGltZSkgKiB0bC5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0dGwgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZTtcblx0XHRcdHQgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bC5fdGltZVNjYWxlID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUuX3RpbWVTY2FsZSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdFx0XG5cdFxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHRwLnByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkgOiB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKCh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSA9ICh0aGlzLl9kdXJhdGlvbiAtIHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHR2YWx1ZSArPSB0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247IC8vZG9uJ3Qgc2V0IF9kaXJ0eSA9IGZhbHNlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgcmVwZWF0cyB0aGF0IGhhdmVuJ3QgYmVlbiBmYWN0b3JlZCBpbnRvIHRoZSBfdG90YWxEdXJhdGlvbiB5ZXQuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBhIHJlcGVhdGVkIFR3ZWVuTWF4IGFuZCB0aGVuIGltbWVkaWF0ZWx5IGNoZWNrIGl0cyBkdXJhdGlvbigpLCBpdCB3b3VsZCBjYWNoZSB0aGUgdmFsdWUgYW5kIHRoZSB0b3RhbER1cmF0aW9uIHdvdWxkIG5vdCBiZSBjb3JyZWN0LCB0aHVzIHJlcGVhdHMgd291bGRuJ3QgdGFrZSBlZmZlY3QuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5kdXJhdGlvbi5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHQvL2luc3RlYWQgb2YgSW5maW5pdHksIHdlIHVzZSA5OTk5OTk5OTk5OTkgc28gdGhhdCB3ZSBjYW4gYWNjb21tb2RhdGUgcmV2ZXJzZXNcblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gdGhpcyA6IHRoaXMuZHVyYXRpb24oICh2YWx1ZSAtICh0aGlzLl9yZXBlYXQgKiB0aGlzLl9yZXBlYXREZWxheSkpIC8gKHRoaXMuX3JlcGVhdCArIDEpICk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcGVhdDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdCA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnlveW8gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl95b3lvO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5feW95byA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0XHRcblx0XHRcblx0XHRyZXR1cm4gVHdlZW5NYXg7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZUxpdGVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIiwgW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSwgZnVuY3Rpb24oQW5pbWF0aW9uLCBTaW1wbGVUaW1lbGluZSwgVHdlZW5MaXRlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVMaXRlID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0XHRTaW1wbGVUaW1lbGluZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAodGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbiA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAodGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fc29ydENoaWxkcmVuID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSB0aGlzLnZhcnMub25VcGRhdGU7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRcdHZhbCwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHYpIHtcblx0XHRcdFx0XHR2YWwgPSB2W3BdO1xuXHRcdFx0XHRcdGlmIChfaXNBcnJheSh2YWwpKSBpZiAodmFsLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHZbcF0gPSB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNBcnJheSh2LnR3ZWVucykpIHtcblx0XHRcdFx0XHR0aGlzLmFkZCh2LnR3ZWVucywgMCwgdi5hbGlnbiwgdi5zdGFnZ2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfaW50ZXJuYWxzID0gVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMgPSB7fSxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2NvcHkgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdHZhciBjb3B5ID0ge30sIHA7XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5Q3ljbGUgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXRzLCBpKSB7XG5cdFx0XHRcdHZhciBhbHQgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRcdHAsIHZhbDtcblx0XHRcdFx0Zm9yIChwIGluIGFsdCkge1xuXHRcdFx0XHRcdHZhbCA9IGFsdFtwXTtcblx0XHRcdFx0XHR2YXJzW3BdID0gKHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpID8gdmFsKGksIHRhcmdldHNbaV0pIDogdmFsW2kgJSB2YWwubGVuZ3RoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdmFycy5jeWNsZTtcblx0XHRcdH0sXG5cdFx0XHRfcGF1c2VDYWxsYmFjayA9IF9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0cCA9IFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKTtcblxuXHRcdFRpbWVsaW5lTGl0ZS52ZXJzaW9uID0gXCIxLjE5LjFcIjtcblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVMaXRlO1xuXHRcdHAua2lsbCgpLl9nYyA9IHAuX2ZvcmNpbmdQbGF5aGVhZCA9IHAuX2hhc1BhdXNlID0gZmFsc2U7XG5cblx0XHQvKiBtaWdodCB1c2UgbGF0ZXIuLi5cblx0XHQvL3RyYW5zbGF0ZXMgYSBsb2NhbCB0aW1lIGluc2lkZSBhbiBhbmltYXRpb24gdG8gdGhlIGNvcnJlc3BvbmRpbmcgdGltZSBvbiB0aGUgcm9vdC9nbG9iYWwgdGltZWxpbmUsIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlcy5cblx0XHRmdW5jdGlvbiBsb2NhbFRvR2xvYmFsKHRpbWUsIGFuaW1hdGlvbikge1xuXHRcdFx0d2hpbGUgKGFuaW1hdGlvbikge1xuXHRcdFx0XHR0aW1lID0gKHRpbWUgLyBhbmltYXRpb24uX3RpbWVTY2FsZSkgKyBhbmltYXRpb24uX3N0YXJ0VGltZTtcblx0XHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cdFx0fVxuXG5cdFx0Ly90cmFuc2xhdGVzIHRoZSBzdXBwbGllZCB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHRpbWUgaW5zaWRlIGEgcGFydGljdWxhciBhbmltYXRpb24sIGZhY3RvcmluZyBpbiBhbGwgbmVzdGluZyBhbmQgdGltZVNjYWxlc1xuXHRcdGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc2NhbGUgPSAxO1xuXHRcdFx0dGltZSAtPSBsb2NhbFRvR2xvYmFsKDAsIGFuaW1hdGlvbik7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHNjYWxlICo9IGFuaW1hdGlvbi5fdGltZVNjYWxlO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZSAqIHNjYWxlO1xuXHRcdH1cblx0XHQqL1xuXG5cdFx0cC50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGU7XG5cdFx0XHRyZXR1cm4gZHVyYXRpb24gPyB0aGlzLmFkZCggbmV3IEVuZ2luZSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pIDogdGhpcy5zZXQodGFyZ2V0LCB2YXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoICgodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZSkuZnJvbSh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLmZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgRW5naW5lID0gKHRvVmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBFbmdpbmUuZnJvbVRvKHRhcmdldCwgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHRvVmFycywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHtvbkNvbXBsZXRlOm9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVQYXJhbXM6b25Db21wbGV0ZUFsbFBhcmFtcywgY2FsbGJhY2tTY29wZTpvbkNvbXBsZXRlQWxsU2NvcGUsIHNtb290aENoaWxkVGltaW5nOnRoaXMuc21vb3RoQ2hpbGRUaW1pbmd9KSxcblx0XHRcdFx0Y3ljbGUgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRjb3B5LCBpO1xuXHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHR0YXJnZXRzID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldHMpIHx8IHRhcmdldHM7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChfaXNTZWxlY3Rvcih0YXJnZXRzKSkgeyAvL3NlbnNlcyBpZiB0aGUgdGFyZ2V0cyBvYmplY3QgaXMgYSBzZWxlY3Rvci4gSWYgaXQgaXMsIHdlIHNob3VsZCB0cmFuc2xhdGUgaXQgaW50byBhbiBhcnJheS5cblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdH1cblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRpZiAoc3RhZ2dlciA8IDApIHtcblx0XHRcdFx0dGFyZ2V0cyA9IF9zbGljZSh0YXJnZXRzKTtcblx0XHRcdFx0dGFyZ2V0cy5yZXZlcnNlKCk7XG5cdFx0XHRcdHN0YWdnZXIgKj0gLTE7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0gX2NvcHkodmFycyk7XG5cdFx0XHRcdGlmIChjb3B5LnN0YXJ0QXQpIHtcblx0XHRcdFx0XHRjb3B5LnN0YXJ0QXQgPSBfY29weShjb3B5LnN0YXJ0QXQpO1xuXHRcdFx0XHRcdGlmIChjb3B5LnN0YXJ0QXQuY3ljbGUpIHtcblx0XHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHkuc3RhcnRBdCwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjeWNsZSkge1xuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHksIHRhcmdldHMsIGkpO1xuXHRcdFx0XHRcdGlmIChjb3B5LmR1cmF0aW9uICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uID0gY29weS5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdGRlbGV0ZSBjb3B5LmR1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0bC50byh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgY29weSwgaSAqIHN0YWdnZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHRsLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlckZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXG5cdFx0cC5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKSB7XG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24sIDAsIHRydWUpO1xuXHRcdFx0aWYgKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAocG9zaXRpb24gPT09IHRoaXMuX3RpbWUgJiYgIXRoaXMuX3BhdXNlZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCA9IGZ1bmN0aW9uKHZhcnMsIGlnbm9yZURlbGF5ZWRDYWxscykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRpZiAodmFycy5zbW9vdGhDaGlsZFRpbWluZyA9PSBudWxsKSB7XG5cdFx0XHRcdHZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gbmV3IFRpbWVsaW5lTGl0ZSh2YXJzKSxcblx0XHRcdFx0cm9vdCA9IHRsLl90aW1lbGluZSxcblx0XHRcdFx0dHdlZW4sIG5leHQ7XG5cdFx0XHRpZiAoaWdub3JlRGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0aWdub3JlRGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJvb3QuX3JlbW92ZSh0bCwgdHJ1ZSk7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gMDtcblx0XHRcdHRsLl9yYXdQcmV2VGltZSA9IHRsLl90aW1lID0gdGwuX3RvdGFsVGltZSA9IHJvb3QuX3RpbWU7XG5cdFx0XHR0d2VlbiA9IHJvb3QuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0aWYgKCFpZ25vcmVEZWxheWVkQ2FsbHMgfHwgISh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSAmJiB0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpIHtcblx0XHRcdFx0XHR0bC5hZGQodHdlZW4sIHR3ZWVuLl9zdGFydFRpbWUgLSB0d2Vlbi5fZGVsYXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJvb3QuYWRkKHRsLCAwKTtcblx0XHRcdHJldHVybiB0bDtcblx0XHR9O1xuXG5cdFx0cC5hZGQgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHR2YXIgY3VyVGltZSwgbCwgaSwgY2hpbGQsIHRsLCBiZWZvcmVSYXdUaW1lO1xuXHRcdFx0aWYgKHR5cGVvZihwb3NpdGlvbikgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uLCAwLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcblx0XHRcdFx0aWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAodmFsdWUgJiYgdmFsdWUucHVzaCAmJiBfaXNBcnJheSh2YWx1ZSkpKSB7XG5cdFx0XHRcdFx0YWxpZ24gPSBhbGlnbiB8fCBcIm5vcm1hbFwiO1xuXHRcdFx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHRcdFx0Y3VyVGltZSA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF9pc0FycmF5KGNoaWxkID0gdmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkID0gbmV3IFRpbWVsaW5lTGl0ZSh7dHdlZW5zOmNoaWxkfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmFkZChjaGlsZCwgY3VyVGltZSk7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGNoaWxkKSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YoY2hpbGQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsaWduID09PSBcInNlcXVlbmNlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRjdXJUaW1lID0gY2hpbGQuX3N0YXJ0VGltZSArIChjaGlsZC50b3RhbER1cmF0aW9uKCkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhbGlnbiA9PT0gXCJzdGFydFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSAtPSBjaGlsZC5kZWxheSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjdXJUaW1lICs9IHN0YWdnZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hZGRMYWJlbCh2YWx1ZSwgcG9zaXRpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHZhbHVlID0gVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyhcIkNhbm5vdCBhZGQgXCIgKyB2YWx1ZSArIFwiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCB2YWx1ZSwgcG9zaXRpb24pO1xuXG5cdFx0XHQvL2lmIHRoZSB0aW1lbGluZSBoYXMgYWxyZWFkeSBlbmRlZCBidXQgdGhlIGluc2VydGVkIHR3ZWVuL3RpbWVsaW5lIGV4dGVuZHMgdGhlIGR1cmF0aW9uLCB3ZSBzaG91bGQgZW5hYmxlIHRoaXMgdGltZWxpbmUgYWdhaW4gc28gdGhhdCBpdCByZW5kZXJzIHByb3Blcmx5LiBXZSBzaG91bGQgYWxzbyBhbGlnbiB0aGUgcGxheWhlYWQgd2l0aCB0aGUgcGFyZW50IHRpbWVsaW5lJ3Mgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdGlmICh0aGlzLl9nYyB8fCB0aGlzLl90aW1lID09PSB0aGlzLl9kdXJhdGlvbikgaWYgKCF0aGlzLl9wYXVzZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA8IHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG5cdFx0XHRcdHRsID0gdGhpcztcblx0XHRcdFx0YmVmb3JlUmF3VGltZSA9ICh0bC5yYXdUaW1lKCkgPiB2YWx1ZS5fc3RhcnRUaW1lKTsgLy9pZiB0aGUgdHdlZW4gaXMgcGxhY2VkIG9uIHRoZSB0aW1lbGluZSBzbyB0aGF0IGl0IHN0YXJ0cyBCRUZPUkUgdGhlIGN1cnJlbnQgcmF3VGltZSwgd2Ugc2hvdWxkIGFsaWduIHRoZSBwbGF5aGVhZCAobW92ZSB0aGUgdGltZWxpbmUpLiBUaGlzIGlzIGJlY2F1c2Ugc29tZXRpbWVzIHVzZXJzIHdpbGwgY3JlYXRlIGEgdGltZWxpbmUsIGxldCBpdCBmaW5pc2gsIGFuZCBtdWNoIGxhdGVyIGFwcGVuZCBhIHR3ZWVuIGFuZCBleHBlY3QgaXQgdG8gcnVuIGluc3RlYWQgb2YganVtcGluZyB0byBpdHMgZW5kIHN0YXRlLiBXaGlsZSB0ZWNobmljYWxseSBvbmUgY291bGQgYXJndWUgdGhhdCBpdCBzaG91bGQganVtcCB0byBpdHMgZW5kIHN0YXRlLCB0aGF0J3Mgbm90IHdoYXQgdXNlcnMgaW50dWl0aXZlbHkgZXhwZWN0LlxuXHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0aWYgKGJlZm9yZVJhd1RpbWUgJiYgdGwuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHR0bC50b3RhbFRpbWUodGwuX3RvdGFsVGltZSwgdHJ1ZSk7IC8vbW92ZXMgdGhlIHRpbWVsaW5lIChzaGlmdHMgaXRzIHN0YXJ0VGltZSkgaWYgbmVjZXNzYXJ5LCBhbmQgYWxzbyBlbmFibGVzIGl0LlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGwuX2djKSB7XG5cdFx0XHRcdFx0XHR0bC5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fcmVtb3ZlKHZhbHVlLCBmYWxzZSk7XG5cdFx0XHRcdHZhciB0bCA9IHZhbHVlLl90aW1lbGluZSA9IHZhbHVlLnZhcnMudXNlRnJhbWVzID8gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUgOiBBbmltYXRpb24uX3Jvb3RUaW1lbGluZTsgLy9ub3cgdGhhdCBpdCdzIHJlbW92ZWQsIGRlZmF1bHQgaXQgdG8gdGhlIHJvb3QgdGltZWxpbmUgc28gdGhhdCBpZiBpdCBnZXRzIHBsYXllZCBhZ2FpbiwgaXQgZG9lc24ndCBqdW1wIGJhY2sgaW50byB0aGlzIHRpbWVsaW5lLlxuXHRcdFx0XHR2YWx1ZS5fc3RhcnRUaW1lID0gKHZhbHVlLl9wYXVzZWQgPyB2YWx1ZS5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdmFsdWUuX3JldmVyc2VkID8gdmFsdWUuX3RvdGFsVGltZSA6IHZhbHVlLnRvdGFsRHVyYXRpb24oKSAtIHZhbHVlLl90b3RhbFRpbWUpIC8gdmFsdWUuX3RpbWVTY2FsZSk7IC8vZW5zdXJlIHRoYXQgaWYgaXQgZ2V0cyBwbGF5ZWQgYWdhaW4sIHRoZSB0aW1pbmcgaXMgY29ycmVjdC5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHR2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmUodmFsdWVbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUxhYmVsKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmtpbGwobnVsbCwgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlLmNhbGwodGhpcywgdHdlZW4sIHNraXBEaXNhYmxlKTtcblx0XHRcdHZhciBsYXN0ID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICghbGFzdCkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gMDtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA+IHRoaXMuZHVyYXRpb24oKSkge1xuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fZHVyYXRpb247XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0T3JMYWJlbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHZhbHVlLCB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsIG9mZnNldE9yTGFiZWwsIHRydWUsIHZhbHVlKSk7XG5cdFx0fTtcblxuXHRcdHAuaW5zZXJ0ID0gcC5pbnNlcnRNdWx0aXBsZSA9IGZ1bmN0aW9uKHZhbHVlLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgcG9zaXRpb24gfHwgMCwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFwcGVuZE11bHRpcGxlID0gZnVuY3Rpb24odHdlZW5zLCBvZmZzZXRPckxhYmVsLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKHR3ZWVucywgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB0d2VlbnMpLCBhbGlnbiwgc3RhZ2dlcik7XG5cdFx0fTtcblxuXHRcdHAuYWRkTGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmFkZFBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHR2YXIgdCA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBfcGF1c2VDYWxsYmFjaywgcGFyYW1zLCBzY29wZSB8fCB0aGlzKTtcblx0XHRcdHQudmFycy5vbkNvbXBsZXRlID0gdC52YXJzLm9uUmV2ZXJzZUNvbXBsZXRlID0gY2FsbGJhY2s7XG5cdFx0XHR0LmRhdGEgPSBcImlzUGF1c2VcIjtcblx0XHRcdHRoaXMuX2hhc1BhdXNlID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0LCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2xhYmVsc1tsYWJlbF07XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbFRpbWUgPSBmdW5jdGlvbihsYWJlbCkge1xuXHRcdFx0cmV0dXJuICh0aGlzLl9sYWJlbHNbbGFiZWxdICE9IG51bGwpID8gdGhpcy5fbGFiZWxzW2xhYmVsXSA6IC0xO1xuXHRcdH07XG5cblx0XHRwLl9wYXJzZVRpbWVPckxhYmVsID0gZnVuY3Rpb24odGltZU9yTGFiZWwsIG9mZnNldE9yTGFiZWwsIGFwcGVuZElmQWJzZW50LCBpZ25vcmUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2Yob2Zmc2V0T3JMYWJlbCkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwob2Zmc2V0T3JMYWJlbCwgKGFwcGVuZElmQWJzZW50ICYmIHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwibnVtYmVyXCIgJiYgdGhpcy5fbGFiZWxzW29mZnNldE9yTGFiZWxdID09IG51bGwpID8gdGltZU9yTGFiZWwgLSB0aGlzLmR1cmF0aW9uKCkgOiAwLCBhcHBlbmRJZkFic2VudCk7XG5cdFx0XHR9XG5cdFx0XHRvZmZzZXRPckxhYmVsID0gb2Zmc2V0T3JMYWJlbCB8fCAwO1xuXHRcdFx0aWYgKHR5cGVvZih0aW1lT3JMYWJlbCkgPT09IFwic3RyaW5nXCIgJiYgKGlzTmFOKHRpbWVPckxhYmVsKSB8fCB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICE9IG51bGwpKSB7IC8vaWYgdGhlIHN0cmluZyBpcyBhIG51bWJlciBsaWtlIFwiMVwiLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIGxhYmVsIHdpdGggdGhhdCBuYW1lLCBvdGhlcndpc2UgaW50ZXJwcmV0IGl0IGFzIGEgbnVtYmVyIChhYnNvbHV0ZSB2YWx1ZSkuXG5cdFx0XHRcdGkgPSB0aW1lT3JMYWJlbC5pbmRleE9mKFwiPVwiKTtcblx0XHRcdFx0aWYgKGkgPT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGFwcGVuZElmQWJzZW50ID8gKHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gPSB0aGlzLmR1cmF0aW9uKCkgKyBvZmZzZXRPckxhYmVsKSA6IG9mZnNldE9yTGFiZWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9sYWJlbHNbdGltZU9yTGFiZWxdICsgb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRvZmZzZXRPckxhYmVsID0gcGFyc2VJbnQodGltZU9yTGFiZWwuY2hhckF0KGktMSkgKyBcIjFcIiwgMTApICogTnVtYmVyKHRpbWVPckxhYmVsLnN1YnN0cihpKzEpKTtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSAoaSA+IDEpID8gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0aW1lT3JMYWJlbC5zdWJzdHIoMCwgaS0xKSwgMCwgYXBwZW5kSWZBYnNlbnQpIDogdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lT3JMYWJlbCA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVPckxhYmVsID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWJlcih0aW1lT3JMYWJlbCkgKyBvZmZzZXRPckxhYmVsO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodHlwZW9mKHBvc2l0aW9uKSA9PT0gXCJudW1iZXJcIikgPyBwb3NpdGlvbiA6IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pLCAoc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKSk7XG5cdFx0fTtcblxuXHRcdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5KHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhdXNlKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0cHJldlRpbWUgPSB0aGlzLl90aW1lLFxuXHRcdFx0XHRwcmV2U3RhcnQgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRcdHByZXZUaW1lU2NhbGUgPSB0aGlzLl90aW1lU2NhbGUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHR3ZWVuLCBpc0NvbXBsZXRlLCBuZXh0LCBjYWxsYmFjaywgaW50ZXJuYWxGb3JjZSwgcGF1c2VUd2VlbiwgY3VyVGltZTtcblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxICYmIHRpbWUgPj0gMCkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW47IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCkgaWYgKCh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCB0aGlzLl9yYXdQcmV2VGltZSA8IDAgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAodGhpcy5fcmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0dGltZSA9IHRvdGFsRHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIC0gc29tZXRpbWVzIGNoaWxkIHR3ZWVucy90aW1lbGluZXMgd2VyZSBub3QgYmVpbmcgZnVsbHkgY29tcGxldGVkICh0aGVpciBwcm9ncmVzcyBtaWdodCBiZSAwLjk5OTk5OTk5OTk5OTk5OCBpbnN0ZWFkIG9mIDEgYmVjYXVzZSB3aGVuIF90aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSBpcyBwZXJmb3JtZWQsIGZsb2F0aW5nIHBvaW50IGVycm9ycyB3b3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IHdhcyBTTElHSFRMWSBvZmYpLiBUcnkgKDk5OTk5OTk5OTk5OS43IC0gOTk5OTk5OTk5OTk5KSAqIDEgPSAwLjY5OTk1MTE3MTg3NSBpbnN0ZWFkIG9mIDAuNy5cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKHRoaXMuX2R1cmF0aW9uID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAodGhpcy5fcmF3UHJldlRpbWUgPiAwIHx8ICh0aW1lIDwgMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA+PSAwKSkpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHsgLy9lbnN1cmVzIHByb3BlciBHQyBpZiBhIHRpbWVsaW5lIGlzIHJlc3VtZWQgYWZ0ZXIgaXQncyBmaW5pc2hlZCByZXZlcnNpbmcuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRcdGlmICh0aW1lID09PSAwICYmIGlzQ29tcGxldGUpIHsgLy9pZiB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgYSB0aW1lbGluZSBhbmQgdGhlIHBsYXloZWFkIGxhbmRzIEVYQUNUTFkgYXQgdGltZSAwLCB0aGF0IHR3ZWVuIHdpbGwgY29ycmVjdGx5IHJlbmRlciBpdHMgZW5kIHZhbHVlcywgYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgdGltZWxpbmUgYWxpdmUgZm9yIG9uZSBtb3JlIHJlbmRlciBzbyB0aGF0IHRoZSBiZWdpbm5pbmcgdmFsdWVzIHJlbmRlciBwcm9wZXJseSBhcyB0aGUgcGFyZW50J3MgcGxheWhlYWQga2VlcHMgbW92aW5nIGJleW9uZCB0aGUgYmVnaW5pbmcuIEltYWdpbmUgb2JqLnggc3RhcnRzIGF0IDAgYW5kIHRoZW4gd2UgZG8gdGwuc2V0KG9iaiwge3g6MTAwfSkudG8ob2JqLCAxLCB7eDoyMDB9KSBhbmQgdGhlbiBsYXRlciB3ZSB0bC5yZXZlcnNlKCkuLi50aGUgZ29hbCBpcyB0byBoYXZlIG9iai54IHJldmVydCB0byAwLiBJZiB0aGUgcGxheWhlYWQgaGFwcGVucyB0byBsYW5kIG9uIGV4YWN0bHkgMCwgd2l0aG91dCB0aGlzIGNodW5rIG9mIGNvZGUsIGl0J2QgY29tcGxldGUgdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcmVuZGVyaW5nIHF1ZXVlIChub3QgZ29vZCkuXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRpc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGltZSA9IDA7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgKGNvdWxkIGNhdXNlIHByb2JsZW1zIGVzcGVjaWFsbHkgd2l0aCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lKVxuXHRcdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nUGxheWhlYWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA8PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgIXR3ZWVuLnJhdGlvICYmICEodHdlZW4uX3N0YXJ0VGltZSA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gMCkpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPj0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIHR3ZWVuLl9yYXdQcmV2VGltZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl90b3RhbER1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUaW1lID09PSAwKSBpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8ICF0aGlzLl9kdXJhdGlvbikgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHR9XG5cblx0XHRcdGN1clRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0aWYgKGN1clRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gY3VyVGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuLl9wcmV2OyAvL3RoZSBsaW5rZWQgbGlzdCBpcyBvcmdhbml6ZWQgYnkgX3N0YXJ0VGltZSwgdGh1cyBpdCdzIHBvc3NpYmxlIHRoYXQgYSB0d2VlbiBjb3VsZCBzdGFydCBCRUZPUkUgdGhlIHBhdXNlIGFuZCBlbmQgYWZ0ZXIgaXQsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgYmUgcG9zaXRpb25lZCBiZWZvcmUgdGhlIHBhdXNlIHR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCwgYnV0IHdlIHNob3VsZCByZW5kZXIgaXQgYmVmb3JlIHdlIHBhdXNlKCkgdGhlIHRpbWVsaW5lIGFuZCBjZWFzZSByZW5kZXJpbmcuIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gd2hlbiBnb2luZyBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdFx0XHR3aGlsZSAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLmVuZFRpbWUoKSA+IHRoaXMuX3RpbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuLnJlbmRlciggKHBhdXNlVHdlZW4uX3JldmVyc2VkID8gcGF1c2VUd2Vlbi50b3RhbER1cmF0aW9uKCkgLSAoKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSA6ICh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHBhdXNlVHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydFRpbWUgfHwgcHJldlRpbWVTY2FsZSAhPT0gdGhpcy5fdGltZVNjYWxlKSBpZiAodGhpcy5fdGltZSA9PT0gMCB8fCB0b3RhbER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSkgeyAvL2lmIG9uZSBvZiB0aGUgdHdlZW5zIHRoYXQgd2FzIHJlbmRlcmVkIGFsdGVyZWQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSAobGlrZSBpZiBhbiBvbkNvbXBsZXRlIHJldmVyc2VkIHRoZSB0aW1lbGluZSksIGl0IHByb2JhYmx5IGlzbid0IGNvbXBsZXRlLiBJZiBpdCBpcywgZG9uJ3Qgd29ycnksIGJlY2F1c2Ugd2hhdGV2ZXIgY2FsbCBhbHRlcmVkIHRoZSBzdGFydFRpbWUgd291bGQgY29tcGxldGUgaWYgaXQgd2FzIG5lY2Vzc2FyeSBhdCB0aGUgbmV3IHRpbWUuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyB0aGUgdGltZVNjYWxlIHByb3BlcnR5LiBBbHNvIGNoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uQ29tcGxldGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5faGFzUGF1c2VkQ2hpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fcGF1c2VkIHx8ICgodHdlZW4gaW5zdGFuY2VvZiBUaW1lbGluZUxpdGUpICYmIHR3ZWVuLl9oYXNQYXVzZWRDaGlsZCgpKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAtOTk5OTk5OTk5OTtcblx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGNudCA9IDA7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0Ly9kbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4gaW5zdGFuY2VvZiBUd2VlbkxpdGUpIHtcblx0XHRcdFx0XHRpZiAodHdlZW5zICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRpbWVsaW5lcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChuZXN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhID0gYS5jb25jYXQodHdlZW4uZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcblx0XHRcdFx0XHRcdGNudCA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbih0YXJnZXQsIG5lc3RlZCkge1xuXHRcdFx0dmFyIGRpc2FibGVkID0gdGhpcy5fZ2MsXG5cdFx0XHRcdGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0dHdlZW5zLCBpO1xuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgdHJ1ZSk7IC8vZ2V0VHdlZW5zT2YoKSBmaWx0ZXJzIG91dCBkaXNhYmxlZCB0d2VlbnMsIGFuZCB3ZSBoYXZlIHRvIG1hcmsgdGhlbSBhcyBfZ2MgPSB0cnVlIHdoZW4gdGhlIHRpbWVsaW5lIGNvbXBsZXRlcyBpbiBvcmRlciB0byBhbGxvdyBjbGVhbiBnYXJiYWdlIGNvbGxlY3Rpb24sIHNvIHRlbXBvcmFyaWx5IHJlLWVuYWJsZSB0aGUgdGltZWxpbmUgaGVyZS5cblx0XHRcdH1cblx0XHRcdHR3ZWVucyA9IFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXQpO1xuXHRcdFx0aSA9IHR3ZWVucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS50aW1lbGluZSA9PT0gdGhpcyB8fCAobmVzdGVkICYmIHRoaXMuX2NvbnRhaW5zKHR3ZWVuc1tpXSkpKSB7XG5cdFx0XHRcdFx0YVtjbnQrK10gPSB0d2VlbnNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLnJlY2VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlY2VudDtcblx0XHR9O1xuXG5cdFx0cC5fY29udGFpbnMgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdFx0dmFyIHRsID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwpIHtcblx0XHRcdFx0aWYgKHRsID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGwgPSB0bC50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdGlnbm9yZUJlZm9yZVRpbWUgPSBpZ25vcmVCZWZvcmVUaW1lIHx8IDA7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bGFiZWxzID0gdGhpcy5fbGFiZWxzLFxuXHRcdFx0XHRwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fc3RhcnRUaW1lICs9IGFtb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFkanVzdExhYmVscykge1xuXHRcdFx0XHRmb3IgKHAgaW4gbGFiZWxzKSB7XG5cdFx0XHRcdFx0aWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0XHRsYWJlbHNbcF0gKz0gYW1vdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdGlmICghdmFycyAmJiAhdGFyZ2V0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHdlZW5zID0gKCF0YXJnZXQpID8gdGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkgOiB0aGlzLmdldFR3ZWVuc09mKHRhcmdldCksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRjaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXS5fa2lsbCh2YXJzLCB0YXJnZXQpKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24obGFiZWxzKSB7XG5cdFx0XHR2YXIgdHdlZW5zID0gdGhpcy5nZXRDaGlsZHJlbihmYWxzZSwgdHJ1ZSwgdHJ1ZSksXG5cdFx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0dHdlZW5zW2ldLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGFiZWxzICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9sYWJlbHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLmludmFsaWRhdGUoKTtcblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTs7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKGVuYWJsZWQgPT09IHRoaXMuX2djKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChlbmFibGVkLCB0cnVlKTtcblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsVGltZSA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCB1bmNhcHBlZCkge1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gdHJ1ZTtcblx0XHRcdHZhciB2YWwgPSBBbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5fZm9yY2luZ1BsYXloZWFkID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTsgLy9qdXN0IHRyaWdnZXJzIHJlY2FsY3VsYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5kdXJhdGlvbigpICE9PSAwICYmIHZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dmFyIG1heCA9IDAsXG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3QsXG5cdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSA5OTk5OTk5OTk5OTksXG5cdFx0XHRcdFx0XHRwcmV2LCBlbmQ7XG5cdFx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRwcmV2ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgaW4gY2FzZSB0aGUgdHdlZW4gY2hhbmdlcyBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2UuLi5cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fZGlydHkpIHtcblx0XHRcdFx0XHRcdFx0dHdlZW4udG90YWxEdXJhdGlvbigpOyAvL2NvdWxkIGNoYW5nZSB0aGUgdHdlZW4uX3N0YXJ0VGltZSwgc28gbWFrZSBzdXJlIHRoZSB0d2VlbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+IHByZXZTdGFydCAmJiB0aGlzLl9zb3J0Q2hpbGRyZW4gJiYgIXR3ZWVuLl9wYXVzZWQpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPCAwICYmICF0d2Vlbi5fcGF1c2VkKSB7IC8vY2hpbGRyZW4gYXJlbid0IGFsbG93ZWQgdG8gaGF2ZSBuZWdhdGl2ZSBzdGFydFRpbWVzIHVubGVzcyBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCBzbyBhZGp1c3QgaGVyZSBpZiBvbmUgaXMgZm91bmQuXG5cdFx0XHRcdFx0XHRcdG1heCAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgKz0gdHdlZW4uX3N0YXJ0VGltZSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnNoaWZ0Q2hpbGRyZW4oLXR3ZWVuLl9zdGFydFRpbWUsIGZhbHNlLCAtOTk5OTk5OTk5OSk7XG5cdFx0XHRcdFx0XHRcdHByZXZTdGFydCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbmQgPSB0d2Vlbi5fc3RhcnRUaW1lICsgKHR3ZWVuLl90b3RhbER1cmF0aW9uIC8gdHdlZW4uX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRpZiAoZW5kID4gbWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1heCA9IGVuZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR3ZWVuID0gcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gbWF4O1xuXHRcdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHZhbHVlICYmIHRoaXMudG90YWxEdXJhdGlvbigpKSA/IHRoaXMudGltZVNjYWxlKHRoaXMuX3RvdGFsRHVyYXRpb24gLyB2YWx1ZSkgOiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIXZhbHVlKSB7IC8vaWYgdGhlcmUncyBhIHBhdXNlIGRpcmVjdGx5IGF0IHRoZSBzcG90IGZyb20gd2hlcmUgd2UncmUgdW5wYXVzaW5nLCBza2lwIGl0LlxuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPT09IHRpbWUgJiYgdHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9yYXdQcmV2VGltZSA9IDA7IC8vcmVtZW1iZXIsIF9yYXdQcmV2VGltZSBpcyBob3cgemVyby1kdXJhdGlvbiB0d2VlbnMvY2FsbGJhY2tzIHNlbnNlIGRpcmVjdGlvbmFsaXR5IGFuZCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZmlyZS4gSWYgX3Jhd1ByZXZUaW1lIGlzIHRoZSBzYW1lIGFzIF9zdGFydFRpbWUgb24gdGhlIG5leHQgcmVuZGVyLCBpdCB3b24ndCBmaXJlLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXG5cdFx0cC51c2VzRnJhbWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZTtcblx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHRsID09PSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSk7XG5cdFx0fTtcblxuXHRcdHAucmF3VGltZSA9IGZ1bmN0aW9uKHdyYXBSZXBlYXRzKSB7XG5cdFx0XHRyZXR1cm4gKHdyYXBSZXBlYXRzICYmICh0aGlzLl9wYXVzZWQgfHwgKHRoaXMuX3JlcGVhdCAmJiB0aGlzLnRpbWUoKSA+IDAgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSkpID8gdGhpcy5fdG90YWxUaW1lICUgKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpIDogdGhpcy5fcGF1c2VkID8gdGhpcy5fdG90YWxUaW1lIDogKHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUod3JhcFJlcGVhdHMpIC0gdGhpcy5fc3RhcnRUaW1lKSAqIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZTtcblxuXHR9LCB0cnVlKTtcblxuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUaW1lbGluZU1heFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsIFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSwgZnVuY3Rpb24oVGltZWxpbmVMaXRlLCBUd2VlbkxpdGUsIEVhc2UpIHtcblxuXHRcdHZhciBUaW1lbGluZU1heCA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0VGltZWxpbmVMaXRlLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdF90aW55TnVtID0gMC4wMDAwMDAwMDAxLFxuXHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMsXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfZWFzZU5vbmUgPSBuZXcgRWFzZShudWxsLCBudWxsLCAxLCAwKSxcblx0XHRcdHAgPSBUaW1lbGluZU1heC5wcm90b3R5cGUgPSBuZXcgVGltZWxpbmVMaXRlKCk7XG5cblx0XHRwLmNvbnN0cnVjdG9yID0gVGltZWxpbmVNYXg7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cdFx0VGltZWxpbmVNYXgudmVyc2lvbiA9IFwiMS4xOS4xXCI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVGltZWxpbmVMaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXHRcdHAuYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaywgcG9zaXRpb24sIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0aWYgKHBvc2l0aW9uID09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9raWxsKG51bGwsIGNhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMuZ2V0VHdlZW5zT2YoY2FsbGJhY2ssIGZhbHNlKSxcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldLl9zdGFydFRpbWUgPT09IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlQ2FsbGJhY2soVGltZWxpbmVMaXRlLl9pbnRlcm5hbHMucGF1c2VDYWxsYmFjaywgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuVG8gPSBmdW5jdGlvbihwb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHR2YXIgY29weSA9IHtlYXNlOl9lYXNlTm9uZSwgdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2V9LFxuXHRcdFx0XHRFbmdpbmUgPSAodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZSxcblx0XHRcdFx0ZHVyYXRpb24sIHAsIHQ7XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdH1cblx0XHRcdGNvcHkudGltZSA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwocG9zaXRpb24pO1xuXHRcdFx0ZHVyYXRpb24gPSAoTWF0aC5hYnMoTnVtYmVyKGNvcHkudGltZSkgLSB0aGlzLl90aW1lKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDE7XG5cdFx0XHR0ID0gbmV3IEVuZ2luZSh0aGlzLCBkdXJhdGlvbiwgY29weSk7XG5cdFx0XHRjb3B5Lm9uU3RhcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dC50YXJnZXQucGF1c2VkKHRydWUpO1xuXHRcdFx0XHRpZiAodC52YXJzLnRpbWUgIT09IHQudGFyZ2V0LnRpbWUoKSAmJiBkdXJhdGlvbiA9PT0gdC5kdXJhdGlvbigpKSB7IC8vZG9uJ3QgbWFrZSB0aGUgZHVyYXRpb24gemVybyAtIGlmIGl0J3Mgc3VwcG9zZWQgdG8gYmUgemVybywgZG9uJ3Qgd29ycnkgYmVjYXVzZSBpdCdzIGFscmVhZHkgaW5pdHRpbmcgdGhlIHR3ZWVuIGFuZCB3aWxsIGNvbXBsZXRlIGltbWVkaWF0ZWx5LCBlZmZlY3RpdmVseSBtYWtpbmcgdGhlIGR1cmF0aW9uIHplcm8gYW55d2F5LiBJZiB3ZSBtYWtlIGR1cmF0aW9uIHplcm8sIHRoZSB0d2VlbiB3b24ndCBydW4gYXQgYWxsLlxuXHRcdFx0XHRcdHQuZHVyYXRpb24oIE1hdGguYWJzKCB0LnZhcnMudGltZSAtIHQudGFyZ2V0LnRpbWUoKSkgLyB0LnRhcmdldC5fdGltZVNjYWxlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMub25TdGFydCkgeyAvL2luIGNhc2UgdGhlIHVzZXIgaGFkIGFuIG9uU3RhcnQgaW4gdGhlIHZhcnMgLSB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBpdC5cblx0XHRcdFx0XHR2YXJzLm9uU3RhcnQuYXBwbHkodmFycy5vblN0YXJ0U2NvcGUgfHwgdmFycy5jYWxsYmFja1Njb3BlIHx8IHQsIHZhcnMub25TdGFydFBhcmFtcyB8fCBbXSk7IC8vZG9uJ3QgdXNlIHQuX2NhbGxiYWNrKFwib25TdGFydFwiKSBvciBpdCdsbCBwb2ludCB0byB0aGUgY29weS5vblN0YXJ0IGFuZCB3ZSdsbCBnZXQgYSByZWN1cnNpb24gZXJyb3IuXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9O1xuXG5cdFx0cC50d2VlbkZyb21UbyA9IGZ1bmN0aW9uKGZyb21Qb3NpdGlvbiwgdG9Qb3NpdGlvbiwgdmFycykge1xuXHRcdFx0dmFycyA9IHZhcnMgfHwge307XG5cdFx0XHRmcm9tUG9zaXRpb24gPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGZyb21Qb3NpdGlvbik7XG5cdFx0XHR2YXJzLnN0YXJ0QXQgPSB7b25Db21wbGV0ZTp0aGlzLnNlZWssIG9uQ29tcGxldGVQYXJhbXM6W2Zyb21Qb3NpdGlvbl0sIGNhbGxiYWNrU2NvcGU6dGhpc307XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UpO1xuXHRcdFx0dmFyIHQgPSB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgdmFycyk7XG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIGN5Y2xlRHVyYXRpb24sIHBhdXNlVHdlZW4sIGN1clRpbWU7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSAmJiB0aW1lID49IDApIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRvdGFsRHVyO1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gdGhpcy5fcmVwZWF0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICgodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgcHJldlJhd1ByZXZUaW1lIDwgMCB8fCBwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtKSBpZiAocHJldlJhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPiBfdGlueU51bSkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAodGhpcy5fZHVyYXRpb24gfHwgIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgdGhpcy5fcmF3UHJldlRpbWUgPT09IHRpbWUpID8gdGltZSA6IF90aW55TnVtOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lIG9yIHR3ZWVuLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LiBXZSBzZXQgdGhlIF9yYXdQcmV2VGltZSB0byBiZSBhIHByZWNpc2UgdGlueSBudW1iZXIgdG8gaW5kaWNhdGUgdGhpcyBzY2VuYXJpbyByYXRoZXIgdGhhbiB1c2luZyBhbm90aGVyIHByb3BlcnR5L3ZhcmlhYmxlIHdoaWNoIHdvdWxkIGluY3JlYXNlIG1lbW9yeSB1c2FnZS4gVGhpcyB0ZWNobmlxdWUgaXMgbGVzcyByZWFkYWJsZSwgYnV0IG1vcmUgZWZmaWNpZW50LlxuXHRcdFx0XHRpZiAodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyO1xuXHRcdFx0XHRcdHRpbWUgPSBkdXIgKyAwLjAwMDE7IC8vdG8gYXZvaWQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgLSBzb21ldGltZXMgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcyB3ZXJlIG5vdCBiZWluZyBmdWxseSBjb21wbGV0ZWQgKHRoZWlyIHByb2dyZXNzIG1pZ2h0IGJlIDAuOTk5OTk5OTk5OTk5OTk4IGluc3RlYWQgb2YgMSBiZWNhdXNlIHdoZW4gX3RpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lIGlzIHBlcmZvcm1lZCwgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHdvdWxkIHJldHVybiBhIHZhbHVlIHRoYXQgd2FzIFNMSUdIVExZIG9mZikuIFRyeSAoOTk5OTk5OTk5OTk5LjcgLSA5OTk5OTk5OTk5OTkpICogMSA9IDAuNjk5OTUxMTcxODc1IGluc3RlYWQgb2YgMC43LiBXZSBjYW5ub3QgZG8gbGVzcyB0aGVuIDAuMDAwMSBiZWNhdXNlIHRoZSBzYW1lIGlzc3VlIGNhbiBvY2N1ciB3aGVuIHRoZSBkdXJhdGlvbiBpcyBleHRyZW1lbHkgbGFyZ2UgbGlrZSA5OTk5OTk5OTk5OTkgaW4gd2hpY2ggY2FzZSBhZGRpbmcgMC4wMDAwMDAwMSwgZm9yIGV4YW1wbGUsIGNhdXNlcyBpdCB0byBhY3QgbGlrZSBub3RoaW5nIHdhcyBhZGRlZC5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPCAwLjAwMDAwMDEpIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLCByb3VuZCBzdXBlciBzbWFsbCB2YWx1ZXMgdG8gMC5cblx0XHRcdFx0aWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl9jeWNsZSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gMCB8fCAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHByZXZSYXdQcmV2VGltZSA+IDAgfHwgKHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwKSkgJiYgIXRoaXMuX2xvY2tlZCkpIHsgLy9lZGdlIGNhc2UgZm9yIGNoZWNraW5nIHRpbWUgPCAwICYmIHByZXZSYXdQcmV2VGltZSA+PSAwOiBhIHplcm8tZHVyYXRpb24gZnJvbVRvKCkgdHdlZW4gaW5zaWRlIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSAoeWVhaCwgdmVyeSByYXJlKVxuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gaXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHByZXZSYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKGR1ciB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0aWYgKHRpbWUgPT09IDAgJiYgaXNDb21wbGV0ZSkgeyAvL2lmIHRoZXJlJ3MgYSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHRpbWVsaW5lIGFuZCB0aGUgcGxheWhlYWQgbGFuZHMgRVhBQ1RMWSBhdCB0aW1lIDAsIHRoYXQgdHdlZW4gd2lsbCBjb3JyZWN0bHkgcmVuZGVyIGl0cyBlbmQgdmFsdWVzLCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSB0aW1lbGluZSBhbGl2ZSBmb3Igb25lIG1vcmUgcmVuZGVyIHNvIHRoYXQgdGhlIGJlZ2lubmluZyB2YWx1ZXMgcmVuZGVyIHByb3Blcmx5IGFzIHRoZSBwYXJlbnQncyBwbGF5aGVhZCBrZWVwcyBtb3ZpbmcgYmV5b25kIHRoZSBiZWdpbmluZy4gSW1hZ2luZSBvYmoueCBzdGFydHMgYXQgMCBhbmQgdGhlbiB3ZSBkbyB0bC5zZXQob2JqLCB7eDoxMDB9KS50byhvYmosIDEsIHt4OjIwMH0pIGFuZCB0aGVuIGxhdGVyIHdlIHRsLnJldmVyc2UoKS4uLnRoZSBnb2FsIGlzIHRvIGhhdmUgb2JqLnggcmV2ZXJ0IHRvIDAuIElmIHRoZSBwbGF5aGVhZCBoYXBwZW5zIHRvIGxhbmQgb24gZXhhY3RseSAwLCB3aXRob3V0IHRoaXMgY2h1bmsgb2YgY29kZSwgaXQnZCBjb21wbGV0ZSB0aGUgdGltZWxpbmUgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZW5kZXJpbmcgcXVldWUgKG5vdCBnb29kKS5cblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdGlzQ29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aW1lID0gMDsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAoY291bGQgY2F1c2UgcHJvYmxlbXMgZXNwZWNpYWxseSB3aXRoIHplcm8tZHVyYXRpb24gdHdlZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgdGltZWxpbmUpXG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGR1ciA9PT0gMCAmJiBwcmV2UmF3UHJldlRpbWUgPCAwKSB7IC8vd2l0aG91dCB0aGlzLCB6ZXJvLWR1cmF0aW9uIHJlcGVhdGluZyB0aW1lbGluZXMgKGxpa2Ugd2l0aCBhIHNpbXBsZSBjYWxsYmFjayBuZXN0ZWQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIGFuZCBhIHJlcGVhdERlbGF5KSB3b3VsZG4ndCByZW5kZXIgdGhlIGZpcnN0IHRpbWUgdGhyb3VnaC5cblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JlcGVhdERlbGF5O1xuXHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBpdCBnZXRzIHJlcG9ydGVkIGFzIDAuNzk5OTk5OTkhKVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlICE9PSAwKSBpZiAodGhpcy5fY3ljbGUgPT09IHRoaXMuX3RvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24gJiYgcHJldlRvdGFsVGltZSA8PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lIC0gKHRoaXMuX2N5Y2xlICogY3ljbGVEdXJhdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXIgLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgPiBkdXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1cjtcblx0XHRcdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZ1BsYXloZWFkICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aW1lIDwgZHVyKSB7XG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUgfHwgKHRoaXMuX3JlcGVhdCAmJiBwcmV2Q3ljbGUgIT09IHRoaXMuX2N5Y2xlKSkge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lIDw9IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiAhdHdlZW4ucmF0aW8gJiYgISh0d2Vlbi5fc3RhcnRUaW1lID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA+PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgdHdlZW4uX3Jhd1ByZXZUaW1lID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aW1lICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX3RvdGFsRHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9jeWNsZSAhPT0gcHJldkN5Y2xlKSBpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHQvKlxuXHRcdFx0XHRtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuXHRcdFx0XHRhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuXHRcdFx0XHR3b3VsZCBnZXQgdHJhbnNhdGVkIHRvIDIuOCBzZWNvbmRzIGlmIHRoZSB0aW1lbGluZSB5b3lvcyBvciAwLjIgc2Vjb25kcyBpZiBpdCBqdXN0IHJlcGVhdHMpLCB0aGVyZVxuXHRcdFx0XHRjb3VsZCBiZSBhIGNhbGxiYWNrIG9yIGEgc2hvcnQgdHdlZW4gdGhhdCdzIGF0IDIuOTUgb3IgMyBzZWNvbmRzIGluIHdoaWNoIHdvdWxkbid0IHJlbmRlci4gU29cblx0XHRcdFx0d2UgbmVlZCB0byBwdXNoIHRoZSB0aW1lbGluZSB0byB0aGUgZW5kIChhbmQvb3IgYmVnaW5uaW5nIGRlcGVuZGluZyBvbiBpdHMgeW95byB2YWx1ZSkuIEFsc28gd2UgbXVzdFxuXHRcdFx0XHRlbnN1cmUgdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBUaW1lbGluZU1heCB3b3JrLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHR2YXIgYmFja3dhcmRzID0gKHRoaXMuX3lveW8gJiYgKHByZXZDeWNsZSAmIDEpICE9PSAwKSxcblx0XHRcdFx0XHR3cmFwID0gKGJhY2t3YXJkcyA9PT0gKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApKSxcblx0XHRcdFx0XHRyZWNUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdFx0cmVjQ3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0XHRyZWNSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRcdHJlY1RpbWUgPSB0aGlzLl90aW1lO1xuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZDeWNsZSAqIGR1cjtcblx0XHRcdFx0aWYgKHRoaXMuX2N5Y2xlIDwgcHJldkN5Y2xlKSB7XG5cdFx0XHRcdFx0YmFja3dhcmRzID0gIWJhY2t3YXJkcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgKz0gZHVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSBwcmV2VGltZTsgLy90ZW1wb3JhcmlseSByZXZlcnQgX3RpbWUgc28gdGhhdCByZW5kZXIoKSByZW5kZXJzIHRoZSBjaGlsZHJlbiBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2l0aG91dCB0aGlzLCB0d2VlbnMgd29uJ3QgcmV3aW5kIGNvcnJlY3RseS4gV2UgY291bGQgYXJoaWN0ZWN0IHRoaW5ncyBpbiBhIFwiY2xlYW5lclwiIHdheSBieSBzcGxpdHRpbmcgb3V0IHRoZSByZW5kZXJpbmcgcXVldWUgaW50byBhIHNlcGFyYXRlIG1ldGhvZCBidXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGtlcHQgaXQgYWxsIGluc2lkZSB0aGlzIG1ldGhvZC5cblxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IChkdXIgPT09IDApID8gcHJldlJhd1ByZXZUaW1lIC0gMC4wMDAxIDogcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHR0aGlzLl9jeWNsZSA9IHByZXZDeWNsZTtcblx0XHRcdFx0dGhpcy5fbG9ja2VkID0gdHJ1ZTsgLy9wcmV2ZW50cyBjaGFuZ2VzIHRvIHRvdGFsVGltZSBhbmQgc2tpcHMgcmVwZWF0L3lveW8gYmVoYXZpb3Igd2hlbiB3ZSByZWN1cnNpdmVseSBjYWxsIHJlbmRlcigpXG5cdFx0XHRcdHByZXZUaW1lID0gKGJhY2t3YXJkcykgPyAwIDogZHVyO1xuXHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgc3VwcHJlc3NFdmVudHMsIChkdXIgPT09IDApKTtcblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnZhcnMub25SZXBlYXQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gcmVjQ3ljbGU7IC8vaW4gY2FzZSB0aGUgb25SZXBlYXQgYWx0ZXJzIHRoZSBwbGF5aGVhZCBvciBpbnZhbGlkYXRlcygpLCB3ZSBzaG91bGRuJ3Qgc3RheSBsb2NrZWQgb3IgdXNlIHRoZSBwcmV2aW91cyBjeWNsZS5cblx0XHRcdFx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblJlcGVhdFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lKSB7IC8vaW4gY2FzZSB0aGVyZSdzIGEgY2FsbGJhY2sgbGlrZSBvbkNvbXBsZXRlIGluIGEgbmVzdGVkIHR3ZWVuL3RpbWVsaW5lIHRoYXQgY2hhbmdlcyB0aGUgcGxheWhlYWQgcG9zaXRpb24sIGxpa2UgdmlhIHNlZWsoKSwgd2Ugc2hvdWxkIGp1c3QgYWJvcnQuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh3cmFwKSB7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7IC8vaWYgdGhlcmUncyBhbiBvblJlcGVhdCwgd2UgcmV2ZXJ0ZWQgdGhpcyBhYm92ZSwgc28gbWFrZSBzdXJlIGl0J3Mgc2V0IHByb3Blcmx5IGFnYWluLiBXZSBhbHNvIHVubG9ja2VkIGluIHRoYXQgc2NlbmFyaW8sIHNvIHJlc2V0IHRoYXQgdG9vLlxuXHRcdFx0XHRcdHRoaXMuX2xvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cHJldlRpbWUgPSAoYmFja3dhcmRzKSA/IGR1ciArIDAuMDAwMSA6IC0wLjAwMDE7XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkgeyAvL2lmIHRoZSByZW5kZXIoKSB0cmlnZ2VyZWQgY2FsbGJhY2sgdGhhdCBwYXVzZWQgdGhpcyB0aW1lbGluZSwgd2Ugc2hvdWxkIGFib3J0ICh2ZXJ5IHJhcmUsIGJ1dCBwb3NzaWJsZSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fdGltZSA9IHJlY1RpbWU7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHJlY1RvdGFsVGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSByZWNDeWNsZTtcblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSByZWNSYXdQcmV2VGltZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCh0aGlzLl90aW1lID09PSBwcmV2VGltZSB8fCAhdGhpcy5fZmlyc3QpICYmICFmb3JjZSAmJiAhaW50ZXJuYWxGb3JjZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gdGhpcy5fdG90YWxUaW1lKSBpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHsgLy9zbyB0aGF0IG9uVXBkYXRlIGZpcmVzIGV2ZW4gZHVyaW5nIHRoZSByZXBlYXREZWxheSAtIGFzIGxvbmcgYXMgdGhlIHRvdGFsVGltZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdHJpZ2dlciBvblVwZGF0ZS5cblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgJiYgdGltZSA+IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIHRoZSB0aW1lbGluZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50IHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIGl0IGlzIGZvcmNlZCB0byByZS1yZW5kZXIgYW5kIGFsaWduIGl0IHdpdGggdGhlIHByb3BlciB0aW1lL2ZyYW1lIG9uIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZS4gTWF5YmUgdGhlIHRpbWVsaW5lIGFscmVhZHkgZmluaXNoZWQgYnV0IHRoZSB1c2VyIG1hbnVhbGx5IHJlLXJlbmRlcnMgaXQgYXMgaGFsZndheSBkb25lLCBmb3IgZXhhbXBsZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgPT09IDApIGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCB8fCAhdGhpcy5fdG90YWxEdXJhdGlvbikgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIik7XG5cdFx0XHR9XG5cblx0XHRcdGN1clRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0aWYgKGN1clRpbWUgPj0gcHJldlRpbWUpIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0XHRpZiAoY3VyVGltZSAhPT0gdGhpcy5fdGltZSB8fCAodGhpcy5fcGF1c2VkICYmICFwcmV2UGF1c2VkKSkgeyAvL2luIGNhc2UgYSB0d2VlbiBwYXVzZXMgb3Igc2Vla3MgdGhlIHRpbWVsaW5lIHdoZW4gcmVuZGVyaW5nLCBsaWtlIGluc2lkZSBvZiBhbiBvblVwZGF0ZS9vbkNvbXBsZXRlXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHR3ZWVuLl9zdGFydFRpbWUgPD0gdGhpcy5fdGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHByZXZUaW1lICYmICF0d2Vlbi5fcGF1c2VkICYmICF0d2Vlbi5fZ2MpKSB7XG5cdFx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuLl9wcmV2OyAvL3RoZSBsaW5rZWQgbGlzdCBpcyBvcmdhbml6ZWQgYnkgX3N0YXJ0VGltZSwgdGh1cyBpdCdzIHBvc3NpYmxlIHRoYXQgYSB0d2VlbiBjb3VsZCBzdGFydCBCRUZPUkUgdGhlIHBhdXNlIGFuZCBlbmQgYWZ0ZXIgaXQsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgYmUgcG9zaXRpb25lZCBiZWZvcmUgdGhlIHBhdXNlIHR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCwgYnV0IHdlIHNob3VsZCByZW5kZXIgaXQgYmVmb3JlIHdlIHBhdXNlKCkgdGhlIHRpbWVsaW5lIGFuZCBjZWFzZSByZW5kZXJpbmcuIFRoaXMgaXMgb25seSBhIGNvbmNlcm4gd2hlbiBnb2luZyBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdFx0XHR3aGlsZSAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLmVuZFRpbWUoKSA+IHRoaXMuX3RpbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXVzZVR3ZWVuLnJlbmRlciggKHBhdXNlVHdlZW4uX3JldmVyc2VkID8gcGF1c2VUd2Vlbi50b3RhbER1cmF0aW9uKCkgLSAoKHRpbWUgLSBwYXVzZVR3ZWVuLl9zdGFydFRpbWUpICogcGF1c2VUd2Vlbi5fdGltZVNjYWxlKSA6ICh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHBhdXNlVHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9sb2NrZWQpIGlmICghdGhpcy5fZ2MpIGlmIChwcmV2U3RhcnQgPT09IHRoaXMuX3N0YXJ0VGltZSB8fCBwcmV2VGltZVNjYWxlICE9PSB0aGlzLl90aW1lU2NhbGUpIGlmICh0aGlzLl90aW1lID09PSAwIHx8IHRvdGFsRHVyID49IHRoaXMudG90YWxEdXJhdGlvbigpKSB7IC8vaWYgb25lIG9mIHRoZSB0d2VlbnMgdGhhdCB3YXMgcmVuZGVyZWQgYWx0ZXJlZCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIChsaWtlIGlmIGFuIG9uQ29tcGxldGUgcmV2ZXJzZWQgdGhlIHRpbWVsaW5lKSwgaXQgcHJvYmFibHkgaXNuJ3QgY29tcGxldGUuIElmIGl0IGlzLCBkb24ndCB3b3JyeSwgYmVjYXVzZSB3aGF0ZXZlciBjYWxsIGFsdGVyZWQgdGhlIHN0YXJ0VGltZSB3b3VsZCBjb21wbGV0ZSBpZiBpdCB3YXMgbmVjZXNzYXJ5IGF0IHRoZSBuZXcgdGltZS4gVGhlIG9ubHkgZXhjZXB0aW9uIGlzIHRoZSB0aW1lU2NhbGUgcHJvcGVydHkuIEFsc28gY2hlY2sgX2djIGJlY2F1c2UgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGtpbGwoKSBjb3VsZCBiZSBjYWxsZWQgaW4gYW4gb25VcGRhdGVcblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25Db21wbGV0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmIChuZXN0ZWQgPT0gbnVsbCkge1xuXHRcdFx0XHRuZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHR3ZWVucyA9PSBudWxsKSB7XG5cdFx0XHRcdHR3ZWVucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZWxpbmVzID09IG51bGwpIHtcblx0XHRcdFx0dGltZWxpbmVzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRhbGwgPSB0aGlzLmdldENoaWxkcmVuKG5lc3RlZCwgdHdlZW5zLCB0aW1lbGluZXMpLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRsID0gYWxsLmxlbmd0aCxcblx0XHRcdFx0aSwgdHdlZW47XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHR3ZWVuID0gYWxsW2ldO1xuXHRcdFx0XHRpZiAodHdlZW4uaXNBY3RpdmUoKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblxuXHRcdHAuZ2V0TGFiZWxBZnRlciA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICghdGltZSkgaWYgKHRpbWUgIT09IDApIHsgLy9mYXN0ZXIgdGhhbiBpc05hbigpXG5cdFx0XHRcdHRpbWUgPSB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxcblx0XHRcdFx0bCA9IGxhYmVscy5sZW5ndGgsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA+IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsQmVmb3JlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0aWYgKHRpbWUgPT0gbnVsbCkge1xuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGkgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0udGltZSA8IHRpbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFiZWxzW2ldLm5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cblx0XHRwLmdldExhYmVsc0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwO1xuXHRcdFx0Zm9yIChwIGluIHRoaXMuX2xhYmVscykge1xuXHRcdFx0XHRhW2NudCsrXSA9IHt0aW1lOnRoaXMuX2xhYmVsc1twXSwgbmFtZTpwfTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLGIpIHtcblx0XHRcdFx0cmV0dXJuIGEudGltZSAtIGIudGltZTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fbG9ja2VkID0gZmFsc2U7IC8vdW5sb2NrIGFuZCBzZXQgY3ljbGUgaW4gY2FzZSBpbnZhbGlkYXRlKCkgaXMgY2FsbGVkIGZyb20gaW5zaWRlIGFuIG9uUmVwZWF0XG5cdFx0XHRyZXR1cm4gVGltZWxpbmVMaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblxuXG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5wcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90aW1lIC8gdGhpcy5kdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMuZHVyYXRpb24oKSAqICgodGhpcy5feW95byAmJiAodGhpcy5fY3ljbGUgJiAxKSAhPT0gMCkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xIHx8ICF2YWx1ZSkgPyB0aGlzIDogdGhpcy50aW1lU2NhbGUoIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdmFsdWUgKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExhYmVsQmVmb3JlKHRoaXMuX3RpbWUgKyAwLjAwMDAwMDAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnNlZWsodmFsdWUsIHRydWUpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVNYXg7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJlemllclBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfcjEgPSBbXSxcblx0XHRcdF9yMiA9IFtdLFxuXHRcdFx0X3IzID0gW10sXG5cdFx0XHRfY29yUHJvcHMgPSB7fSxcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRTZWdtZW50ID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHRpZiAoYyA9PT0gZCkgeyAvL2lmIGMgYW5kIGQgbWF0Y2gsIHRoZSBmaW5hbCBhdXRvUm90YXRlIHZhbHVlIGNvdWxkIGxvY2sgYXQgLTkwIGRlZ3JlZXMsIHNvIGRpZmZlcmVudGlhdGUgdGhlbSBzbGlnaHRseS5cblx0XHRcdFx0XHRjID0gZCAtIChkIC0gYikgLyAxMDAwMDAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhID09PSBiKSB7IC8vaWYgYSBhbmQgYiBtYXRjaCwgdGhlIHN0YXJ0aW5nIGF1dG9Sb3RhdGUgdmFsdWUgY291bGQgbG9jayBhdCAtOTAgZGVncmVlcywgc28gZGlmZmVyZW50aWF0ZSB0aGVtIHNsaWdodGx5LlxuXHRcdFx0XHRcdGIgPSBhICsgKGMgLSBhKSAvIDEwMDAwMDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hID0gYTtcblx0XHRcdFx0dGhpcy5iID0gYjtcblx0XHRcdFx0dGhpcy5jID0gYztcblx0XHRcdFx0dGhpcy5kID0gZDtcblx0XHRcdFx0dGhpcy5kYSA9IGQgLSBhO1xuXHRcdFx0XHR0aGlzLmNhID0gYyAtIGE7XG5cdFx0XHRcdHRoaXMuYmEgPSBiIC0gYTtcblx0XHRcdH0sXG5cdFx0XHRfY29ycmVsYXRlID0gXCIseCx5LHosbGVmdCx0b3AscmlnaHQsYm90dG9tLG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxwYWRkaW5nTGVmdCxwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLGJhY2tncm91bmRQb3NpdGlvbixiYWNrZ3JvdW5kUG9zaXRpb25feSxcIixcblx0XHRcdGN1YmljVG9RdWFkcmF0aWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG5cdFx0XHRcdHZhciBxMSA9IHthOmF9LFxuXHRcdFx0XHRcdHEyID0ge30sXG5cdFx0XHRcdFx0cTMgPSB7fSxcblx0XHRcdFx0XHRxNCA9IHtjOmR9LFxuXHRcdFx0XHRcdG1hYiA9IChhICsgYikgLyAyLFxuXHRcdFx0XHRcdG1iYyA9IChiICsgYykgLyAyLFxuXHRcdFx0XHRcdG1jZCA9IChjICsgZCkgLyAyLFxuXHRcdFx0XHRcdG1hYmMgPSAobWFiICsgbWJjKSAvIDIsXG5cdFx0XHRcdFx0bWJjZCA9IChtYmMgKyBtY2QpIC8gMixcblx0XHRcdFx0XHRtOCA9IChtYmNkIC0gbWFiYykgLyA4O1xuXHRcdFx0XHRxMS5iID0gbWFiICsgKGEgLSBtYWIpIC8gNDtcblx0XHRcdFx0cTIuYiA9IG1hYmMgKyBtODtcblx0XHRcdFx0cTEuYyA9IHEyLmEgPSAocTEuYiArIHEyLmIpIC8gMjtcblx0XHRcdFx0cTIuYyA9IHEzLmEgPSAobWFiYyArIG1iY2QpIC8gMjtcblx0XHRcdFx0cTMuYiA9IG1iY2QgLSBtODtcblx0XHRcdFx0cTQuYiA9IG1jZCArIChkIC0gbWNkKSAvIDQ7XG5cdFx0XHRcdHEzLmMgPSBxNC5hID0gKHEzLmIgKyBxNC5iKSAvIDI7XG5cdFx0XHRcdHJldHVybiBbcTEsIHEyLCBxMywgcTRdO1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oYSwgY3VydmluZXNzLCBxdWFkLCBiYXNpYywgY29ycmVsYXRlKSB7XG5cdFx0XHRcdHZhciBsID0gYS5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdGlpID0gMCxcblx0XHRcdFx0XHRjcDEgPSBhWzBdLmEsXG5cdFx0XHRcdFx0aSwgcDEsIHAyLCBwMywgc2VnLCBtMSwgbTIsIG1tLCBjcDIsIHFiLCByMSwgcjIsIHRsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0c2VnID0gYVtpaV07XG5cdFx0XHRcdFx0cDEgPSBzZWcuYTtcblx0XHRcdFx0XHRwMiA9IHNlZy5kO1xuXHRcdFx0XHRcdHAzID0gYVtpaSsxXS5kO1xuXG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cjEgPSBfcjFbaV07XG5cdFx0XHRcdFx0XHRyMiA9IF9yMltpXTtcblx0XHRcdFx0XHRcdHRsID0gKChyMiArIHIxKSAqIGN1cnZpbmVzcyAqIDAuMjUpIC8gKGJhc2ljID8gMC41IDogX3IzW2ldIHx8IDAuNSk7XG5cdFx0XHRcdFx0XHRtMSA9IHAyIC0gKHAyIC0gcDEpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIxICE9PSAwID8gdGwgLyByMSA6IDApKTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiAoYmFzaWMgPyBjdXJ2aW5lc3MgKiAwLjUgOiAocjIgIT09IDAgPyB0bCAvIHIyIDogMCkpO1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArICgoKG0yIC0gbTEpICogKChyMSAqIDMgLyAocjEgKyByMikpICsgMC41KSAvIDQpIHx8IDApKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIGN1cnZpbmVzcyAqIDAuNTtcblx0XHRcdFx0XHRcdG0yID0gcDIgKyAocDMgLSBwMikgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtbSA9IHAyIC0gKG0xICsgbTIpIC8gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bTEgKz0gbW07XG5cdFx0XHRcdFx0bTIgKz0gbW07XG5cblx0XHRcdFx0XHRzZWcuYyA9IGNwMiA9IG0xO1xuXHRcdFx0XHRcdGlmIChpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDEgPSBzZWcuYSArIChzZWcuYyAtIHNlZy5hKSAqIDAuNjsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYiBvbiBhIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYyBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlSW4gb3IgRWxhc3RpYy5lYXNlSW4gd2hpY2ggZ29lcyBCRVlPTkQgdGhlIGJlZ2lubmluZywgaXQgd2lsbCBkbyBzbyBzbW9vdGhseS5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWcuZGEgPSBwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5jYSA9IGNwMiAtIHAxO1xuXHRcdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHAxO1xuXG5cdFx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhwMSwgY3AxLCBjcDIsIHAyKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdFx0XHRpaSArPSA0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpaSsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNwMSA9IG0yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRzZWcuYiA9IGNwMTtcblx0XHRcdFx0c2VnLmMgPSBjcDEgKyAoc2VnLmQgLSBjcDEpICogMC40OyAvL2luc3RlYWQgb2YgcGxhY2luZyBjIG9uIGQgZXhhY3RseSwgd2UgbW92ZSBpdCBpbmxpbmUgd2l0aCBiIHNvIHRoYXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVzIGFuIGVhc2UgbGlrZSBCYWNrLmVhc2VPdXQgb3IgRWxhc3RpYy5lYXNlT3V0IHdoaWNoIGdvZXMgQkVZT05EIHRoZSBlbmQsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdHNlZy5kYSA9IHNlZy5kIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5jYSA9IHNlZy5jIC0gc2VnLmE7XG5cdFx0XHRcdHNlZy5iYSA9IGNwMSAtIHNlZy5hO1xuXHRcdFx0XHRpZiAocXVhZCkge1xuXHRcdFx0XHRcdHFiID0gY3ViaWNUb1F1YWRyYXRpYyhzZWcuYSwgY3AxLCBzZWcuYywgc2VnLmQpO1xuXHRcdFx0XHRcdGEuc3BsaWNlKGlpLCAxLCBxYlswXSwgcWJbMV0sIHFiWzJdLCBxYlszXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VBbmNob3JzID0gZnVuY3Rpb24odmFsdWVzLCBwLCBjb3JyZWxhdGUsIHByZXBlbmQpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsLCBpLCBwMSwgcDIsIHAzLCB0bXA7XG5cdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHRcdGkgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiggKHRtcCA9IHZhbHVlc1tpXVtwXSkgKSA9PT0gXCJzdHJpbmdcIikgaWYgKHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tpXVtwXSA9IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpOyAvL2FjY29tbW9kYXRlIHJlbGF0aXZlIHZhbHVlcy4gRG8gaXQgaW5saW5lIGluc3RlYWQgb2YgYnJlYWtpbmcgaXQgb3V0IGludG8gYSBmdW5jdGlvbiBmb3Igc3BlZWQgcmVhc29uc1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aCAtIDI7XG5cdFx0XHRcdGlmIChsIDwgMCkge1xuXHRcdFx0XHRcdGFbMF0gPSBuZXcgU2VnbWVudCh2YWx1ZXNbMF1bcF0sIDAsIDAsIHZhbHVlc1sobCA8IC0xKSA/IDAgOiAxXVtwXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHAxID0gdmFsdWVzW2ldW3BdO1xuXHRcdFx0XHRcdHAyID0gdmFsdWVzW2krMV1bcF07XG5cdFx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHAxLCAwLCAwLCBwMik7XG5cdFx0XHRcdFx0aWYgKGNvcnJlbGF0ZSkge1xuXHRcdFx0XHRcdFx0cDMgPSB2YWx1ZXNbaSsyXVtwXTtcblx0XHRcdFx0XHRcdF9yMVtpXSA9IChfcjFbaV0gfHwgMCkgKyAocDIgLSBwMSkgKiAocDIgLSBwMSk7XG5cdFx0XHRcdFx0XHRfcjJbaV0gPSAoX3IyW2ldIHx8IDApICsgKHAzIC0gcDIpICogKHAzIC0gcDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhW2ldID0gbmV3IFNlZ21lbnQodmFsdWVzW2ldW3BdLCAwLCAwLCB2YWx1ZXNbaSsxXVtwXSk7XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdGJlemllclRocm91Z2ggPSBmdW5jdGlvbih2YWx1ZXMsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBvYmogPSB7fSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGZpcnN0ID0gcHJlcGVuZCB8fCB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0aSwgcCwgYSwgaiwgciwgbCwgc2VhbWxlc3MsIGxhc3Q7XG5cdFx0XHRcdGNvcnJlbGF0ZSA9ICh0eXBlb2YoY29ycmVsYXRlKSA9PT0gXCJzdHJpbmdcIikgPyBcIixcIitjb3JyZWxhdGUrXCIsXCIgOiBfY29ycmVsYXRlO1xuXHRcdFx0XHRpZiAoY3VydmluZXNzID09IG51bGwpIHtcblx0XHRcdFx0XHRjdXJ2aW5lc3MgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vY2hlY2sgdG8gc2VlIGlmIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMgYXJlIGlkZW50aWNhbCAod2VsbCwgd2l0aGluIDAuMDUpLiBJZiBzbywgbWFrZSBzZWFtbGVzcyBieSBhcHBlbmRpbmcgdGhlIHNlY29uZCBlbGVtZW50IHRvIHRoZSB2ZXJ5IGVuZCBvZiB0aGUgdmFsdWVzIGFycmF5IGFuZCB0aGUgMm5kLXRvLWxhc3QgZWxlbWVudCB0byB0aGUgdmVyeSBiZWdpbm5pbmcgKHdlJ2xsIHJlbW92ZSB0aG9zZSBzZWdtZW50cyBsYXRlcilcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0c2VhbWxlc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoZmlyc3RbcF0gLSBsYXN0W3BdKSA+IDAuMDUpIHsgLy9idWlsZCBpbiBhIHRvbGVyYW5jZSBvZiArLy0wLjA1IHRvIGFjY29tbW9kYXRlIHJvdW5kaW5nIGVycm9ycy5cblx0XHRcdFx0XHRcdFx0c2VhbWxlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChzZWFtbGVzcykge1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gdmFsdWVzLmNvbmNhdCgpOyAvL2R1cGxpY2F0ZSB0aGUgYXJyYXkgdG8gYXZvaWQgY29udGFtaW5hdGluZyB0aGUgb3JpZ2luYWwgd2hpY2ggdGhlIHVzZXIgbWF5IGJlIHJldXNpbmcgZm9yIG90aGVyIHR3ZWVuc1xuXHRcdFx0XHRcdFx0aWYgKHByZXBlbmQpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnVuc2hpZnQocHJlcGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCh2YWx1ZXNbMV0pO1xuXHRcdFx0XHRcdFx0cHJlcGVuZCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gM107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdF9yMS5sZW5ndGggPSBfcjIubGVuZ3RoID0gX3IzLmxlbmd0aCA9IDA7XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRfY29yUHJvcHNbcF0gPSAoY29ycmVsYXRlLmluZGV4T2YoXCIsXCIrcCtcIixcIikgIT09IC0xKTtcblx0XHRcdFx0XHRvYmpbcF0gPSBfcGFyc2VBbmNob3JzKHZhbHVlcywgcCwgX2NvclByb3BzW3BdLCBwcmVwZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gX3IxLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0X3IxW2ldID0gTWF0aC5zcXJ0KF9yMVtpXSk7XG5cdFx0XHRcdFx0X3IyW2ldID0gTWF0aC5zcXJ0KF9yMltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFiYXNpYykge1xuXHRcdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2NvclByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGEgPSBvYmpbcHJvcHNbaV1dO1xuXHRcdFx0XHRcdFx0XHRsID0gYS5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0ciA9IChhW2orMV0uZGEgLyBfcjJbal0gKyBhW2pdLmRhIC8gX3IxW2pdKSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdF9yM1tqXSA9IChfcjNbal0gfHwgMCkgKyByICogcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpID0gX3IzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9yM1tpXSA9IE1hdGguc3FydChfcjNbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRqID0gcXVhZHJhdGljID8gNCA6IDE7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRhID0gb2JqW3BdO1xuXHRcdFx0XHRcdF9jYWxjdWxhdGVDb250cm9sUG9pbnRzKGEsIGN1cnZpbmVzcywgcXVhZHJhdGljLCBiYXNpYywgX2NvclByb3BzW3BdKTsgLy90aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IF9wYXJzZUFuY2hvcnMoKSBhbmQgX3NldFNlZ21lbnRSYXRpb3MoKSByYW4gZmlyc3Qgc28gdGhhdCBfcjEsIF9yMiwgYW5kIF9yMyB2YWx1ZXMgYXJlIHBvcHVsYXRlZCBmb3IgYWxsIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKDAsIGopO1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoYS5sZW5ndGggLSBqLCBqKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VCZXppZXJEYXRhID0gZnVuY3Rpb24odmFsdWVzLCB0eXBlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwic29mdFwiO1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0aW5jID0gKHR5cGUgPT09IFwiY3ViaWNcIikgPyAzIDogMixcblx0XHRcdFx0XHRzb2Z0ID0gKHR5cGUgPT09IFwic29mdFwiKSxcblx0XHRcdFx0XHRwcm9wcyA9IFtdLFxuXHRcdFx0XHRcdGEsIGIsIGMsIGQsIGN1ciwgaSwgaiwgbCwgcCwgY250LCB0bXA7XG5cdFx0XHRcdGlmIChzb2Z0ICYmIHByZXBlbmQpIHtcblx0XHRcdFx0XHR2YWx1ZXMgPSBbcHJlcGVuZF0uY29uY2F0KHZhbHVlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhbHVlcyA9PSBudWxsIHx8IHZhbHVlcy5sZW5ndGggPCBpbmMgKyAxKSB7IHRocm93IFwiaW52YWxpZCBCZXppZXIgZGF0YVwiOyB9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZXNbMF0pIHtcblx0XHRcdFx0XHRwcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkgPSBwcm9wcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHAgPSBwcm9wc1tpXTtcblx0XHRcdFx0XHRvYmpbcF0gPSBjdXIgPSBbXTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcblx0XHRcdFx0XHRcdGEgPSAocHJlcGVuZCA9PSBudWxsKSA/IHZhbHVlc1tqXVtwXSA6ICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbal1bcF0pICkgPT09IFwic3RyaW5nXCIgJiYgdG1wLmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcHJlcGVuZFtwXSArIE51bWJlcih0bXAuY2hhckF0KDApICsgdG1wLnN1YnN0cigyKSkgOiBOdW1iZXIodG1wKTtcblx0XHRcdFx0XHRcdGlmIChzb2Z0KSBpZiAoaiA+IDEpIGlmIChqIDwgbCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IChhICsgY3VyW2NudC0yXSkgLyAyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGwgPSBjbnQgLSBpbmMgKyAxO1xuXHRcdFx0XHRcdGNudCA9IDA7XG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGogKz0gaW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gY3VyW2pdO1xuXHRcdFx0XHRcdFx0YiA9IGN1cltqKzFdO1xuXHRcdFx0XHRcdFx0YyA9IGN1cltqKzJdO1xuXHRcdFx0XHRcdFx0ZCA9IChpbmMgPT09IDIpID8gMCA6IGN1cltqKzNdO1xuXHRcdFx0XHRcdFx0Y3VyW2NudCsrXSA9IHRtcCA9IChpbmMgPT09IDMpID8gbmV3IFNlZ21lbnQoYSwgYiwgYywgZCkgOiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1ci5sZW5ndGggPSBjbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH0sXG5cdFx0XHRfYWRkQ3ViaWNMZW5ndGhzID0gZnVuY3Rpb24oYSwgc3RlcHMsIHJlc29sdXRpb24pIHtcblx0XHRcdFx0dmFyIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuXHRcdFx0XHRcdGogPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRkLCBkMSwgcywgZGEsIGNhLCBiYSwgcCwgaSwgaW52LCBiZXosIGluZGV4O1xuXHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRiZXogPSBhW2pdO1xuXHRcdFx0XHRcdHMgPSBiZXouYTtcblx0XHRcdFx0XHRkYSA9IGJlei5kIC0gcztcblx0XHRcdFx0XHRjYSA9IGJlei5jIC0gcztcblx0XHRcdFx0XHRiYSA9IGJlei5iIC0gcztcblx0XHRcdFx0XHRkID0gZDEgPSAwO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG5cdFx0XHRcdFx0XHRwID0gaW5jICogaTtcblx0XHRcdFx0XHRcdGludiA9IDEgLSBwO1xuXHRcdFx0XHRcdFx0ZCA9IGQxIC0gKGQxID0gKHAgKiBwICogZGEgKyAzICogaW52ICogKHAgKiBjYSArIGludiAqIGJhKSkgKiBwKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gaiAqIHJlc29sdXRpb24gKyBpIC0gMTtcblx0XHRcdFx0XHRcdHN0ZXBzW2luZGV4XSA9IChzdGVwc1tpbmRleF0gfHwgMCkgKyBkICogZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfcGFyc2VMZW5ndGhEYXRhID0gZnVuY3Rpb24ob2JqLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHJlc29sdXRpb24gPSByZXNvbHV0aW9uID4+IDAgfHwgNjtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRsZW5ndGhzID0gW10sXG5cdFx0XHRcdFx0ZCA9IDAsXG5cdFx0XHRcdFx0dG90YWwgPSAwLFxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IHJlc29sdXRpb24gLSAxLFxuXHRcdFx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRcdFx0Y3VyTFMgPSBbXSwgLy9jdXJyZW50IGxlbmd0aCBzZWdtZW50cyBhcnJheVxuXHRcdFx0XHRcdHAsIGksIGwsIGluZGV4O1xuXHRcdFx0XHRmb3IgKHAgaW4gb2JqKSB7XG5cdFx0XHRcdFx0X2FkZEN1YmljTGVuZ3RocyhvYmpbcF0sIGEsIHJlc29sdXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGQgKz0gTWF0aC5zcXJ0KGFbaV0pO1xuXHRcdFx0XHRcdGluZGV4ID0gaSAlIHJlc29sdXRpb247XG5cdFx0XHRcdFx0Y3VyTFNbaW5kZXhdID0gZDtcblx0XHRcdFx0XHRpZiAoaW5kZXggPT09IHRocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0dG90YWwgKz0gZDtcblx0XHRcdFx0XHRcdGluZGV4ID0gKGkgLyByZXNvbHV0aW9uKSA+PiAwO1xuXHRcdFx0XHRcdFx0c2VnbWVudHNbaW5kZXhdID0gY3VyTFM7XG5cdFx0XHRcdFx0XHRsZW5ndGhzW2luZGV4XSA9IHRvdGFsO1xuXHRcdFx0XHRcdFx0ZCA9IDA7XG5cdFx0XHRcdFx0XHRjdXJMUyA9IFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2xlbmd0aDp0b3RhbCwgbGVuZ3RoczpsZW5ndGhzLCBzZWdtZW50czpzZWdtZW50c307XG5cdFx0XHR9LFxuXG5cblxuXHRcdFx0QmV6aWVyUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdFx0cHJvcE5hbWU6IFwiYmV6aWVyXCIsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRcdHZlcnNpb246IFwiMS4zLjdcIixcblx0XHRcdFx0XHRBUEk6IDIsXG5cdFx0XHRcdFx0Z2xvYmFsOnRydWUsXG5cblx0XHRcdFx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2Vlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKHZhcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdFx0XHR2YXJzID0ge3ZhbHVlczp2YXJzfTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2Z1bmMgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX21vZCA9IHt9O1xuXHRcdFx0XHRcdFx0dGhpcy5fcHJvcHMgPSBbXTtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWVSZXMgPSAodmFycy50aW1lUmVzb2x1dGlvbiA9PSBudWxsKSA/IDYgOiBwYXJzZUludCh2YXJzLnRpbWVSZXNvbHV0aW9uLCAxMCk7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVzID0gdmFycy52YWx1ZXMgfHwgW10sXG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0ge30sXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IHZhbHVlc1swXSxcblx0XHRcdFx0XHRcdFx0YXV0b1JvdGF0ZSA9IHZhcnMuYXV0b1JvdGF0ZSB8fCB0d2Vlbi52YXJzLm9yaWVudFRvQmV6aWVyLFxuXHRcdFx0XHRcdFx0XHRwLCBpc0Z1bmMsIGksIGosIHByZXBlbmQ7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2F1dG9Sb3RhdGUgPSBhdXRvUm90YXRlID8gKGF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkgPyBhdXRvUm90YXRlIDogW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsKChhdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIoYXV0b1JvdGF0ZSkgfHwgMCldXSA6IG51bGw7XG5cdFx0XHRcdFx0XHRmb3IgKHAgaW4gc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdGlzRnVuYyA9IHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIik7XG5cdFx0XHRcdFx0XHRcdGZpcnN0W3BdID0gKCFpc0Z1bmMpID8gcGFyc2VGbG9hdCh0YXJnZXRbcF0pIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXByZXBlbmQpIGlmIChmaXJzdFtwXSAhPT0gdmFsdWVzWzBdW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlcGVuZCA9IGZpcnN0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9iZXppZXJzID0gKHZhcnMudHlwZSAhPT0gXCJjdWJpY1wiICYmIHZhcnMudHlwZSAhPT0gXCJxdWFkcmF0aWNcIiAmJiB2YXJzLnR5cGUgIT09IFwic29mdFwiKSA/IGJlemllclRocm91Z2godmFsdWVzLCBpc05hTih2YXJzLmN1cnZpbmVzcykgPyAxIDogdmFycy5jdXJ2aW5lc3MsIGZhbHNlLCAodmFycy50eXBlID09PSBcInRocnVCYXNpY1wiKSwgdmFycy5jb3JyZWxhdGUsIHByZXBlbmQpIDogX3BhcnNlQmV6aWVyRGF0YSh2YWx1ZXMsIHZhcnMudHlwZSwgZmlyc3QpO1xuXHRcdFx0XHRcdFx0dGhpcy5fc2VnQ291bnQgPSB0aGlzLl9iZXppZXJzW3BdLmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxkID0gX3BhcnNlTGVuZ3RoRGF0YSh0aGlzLl9iZXppZXJzLCB0aGlzLl90aW1lUmVzKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RoID0gbGQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sZW5ndGhzID0gbGQubGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHMgPSBsZC5zZWdtZW50cztcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSB0aGlzLl9saSA9IHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9sMiA9IHRoaXMuX2xlbmd0aHNbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IHRoaXMuX3NlZ21lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IHRoaXMuX2N1clNlZ1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fcHJlYyA9IDEgLyB0aGlzLl9jdXJTZWcubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGF1dG9Sb3RhdGUgPSB0aGlzLl9hdXRvUm90YXRlKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9pbml0aWFsUm90YXRpb25zID0gW107XG5cdFx0XHRcdFx0XHRcdGlmICghKGF1dG9Sb3RhdGVbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA9IFthdXRvUm90YXRlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpID0gYXV0b1JvdGF0ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldW2pdO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZnVuY1twXSA9ICh0eXBlb2YodGFyZ2V0W3BdKSA9PT0gXCJmdW5jdGlvblwiKSA/IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0gOiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGF1dG9Sb3RhdGVbaV1bMl07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tpXSA9ICh0aGlzLl9mdW5jW3BdID8gdGhpcy5fZnVuY1twXS5jYWxsKHRoaXMuX3RhcmdldCkgOiB0aGlzLl90YXJnZXRbcF0pIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRSYXRpbyA9IHR3ZWVuLnZhcnMucnVuQmFja3dhcmRzID8gMSA6IDA7IC8vd2UgZGV0ZXJtaW5lIHRoZSBzdGFydGluZyByYXRpbyB3aGVuIHRoZSB0d2VlbiBpbml0cyB3aGljaCBpcyBhbHdheXMgMCB1bmxlc3MgdGhlIHR3ZWVuIGhhcyBydW5CYWNrd2FyZHM6dHJ1ZSAoaW5kaWNhdGluZyBpdCdzIGEgZnJvbSgpIHR3ZWVuKSBpbiB3aGljaCBjYXNlIGl0J3MgMS5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnQ291bnQsXG5cdFx0XHRcdFx0XHRcdGZ1bmMgPSB0aGlzLl9mdW5jLFxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG5cdFx0XHRcdFx0XHRcdG5vdFN0YXJ0ID0gKHYgIT09IHRoaXMuX3N0YXJ0UmF0aW8pLFxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCwgaW52LCBpLCBwLCBiLCB0LCB2YWwsIGwsIGxlbmd0aHMsIGN1clNlZztcblx0XHRcdFx0XHRcdGlmICghdGhpcy5fdGltZVJlcykge1xuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9ICh2IDwgMCkgPyAwIDogKHYgPj0gMSkgPyBzZWdtZW50cyAtIDEgOiAoc2VnbWVudHMgKiB2KSA+PiAwO1xuXHRcdFx0XHRcdFx0XHR0ID0gKHYgLSAoY3VySW5kZXggKiAoMSAvIHNlZ21lbnRzKSkpICogc2VnbWVudHM7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsZW5ndGhzID0gdGhpcy5fbGVuZ3Rocztcblx0XHRcdFx0XHRcdFx0Y3VyU2VnID0gdGhpcy5fY3VyU2VnO1xuXHRcdFx0XHRcdFx0XHR2ICo9IHRoaXMuX2xlbmd0aDtcblx0XHRcdFx0XHRcdFx0aSA9IHRoaXMuX2xpO1xuXHRcdFx0XHRcdFx0XHQvL2ZpbmQgdGhlIGFwcHJvcHJpYXRlIHNlZ21lbnQgKGlmIHRoZSBjdXJyZW50bHkgY2FjaGVkIG9uZSBpc24ndCBjb3JyZWN0KVxuXHRcdFx0XHRcdFx0XHRpZiAodiA+IHRoaXMuX2wyICYmIGkgPCBzZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gc2VnbWVudHMgLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fbDIgPSBsZW5ndGhzWysraV0pIDw9IHYpIHtcdH1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IGxlbmd0aHNbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbKHRoaXMuX3MxID0gdGhpcy5fc2kgPSAwKV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX2wxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9sMSA9IGxlbmd0aHNbLS1pXSkgPj0gdikgeyB9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX2wxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9sMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSBsZW5ndGhzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2xpID0gaTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSBjdXJTZWcgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IGN1clNlZ1sodGhpcy5fc2kgPSBjdXJTZWcubGVuZ3RoIC0gMSkgLSAxXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW3RoaXMuX3NpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjdXJJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdC8vbm93IGZpbmQgdGhlIGFwcHJvcHJpYXRlIHN1Yi1zZWdtZW50ICh3ZSBzcGxpdCBpdCBpbnRvIHRoZSBudW1iZXIgb2YgcGllY2VzIHRoYXQgd2FzIGRlZmluZWQgYnkgXCJwcmVjaXNpb25cIiBhbmQgbWVhc3VyZWQgZWFjaCBvbmUpXG5cdFx0XHRcdFx0XHRcdHYgLT0gdGhpcy5fbDE7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9zaTtcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9zMiAmJiBpIDwgY3VyU2VnLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdFx0XHRsID0gY3VyU2VnLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBsICYmICh0aGlzLl9zMiA9IGN1clNlZ1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbaS0xXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zaSA9IGk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodiA8IHRoaXMuX3MxICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGkgPiAwICYmICh0aGlzLl9zMSA9IGN1clNlZ1stLWldKSA+PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDAgJiYgdiA8IHRoaXMuX3MxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSBjdXJTZWdbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHQgPSAoKGkgKyAodiAtIHRoaXMuX3MxKSAvICh0aGlzLl9zMiAtIHRoaXMuX3MxKSkgKiB0aGlzLl9wcmVjKSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW52ID0gMSAtIHQ7XG5cblx0XHRcdFx0XHRcdGkgPSB0aGlzLl9wcm9wcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuX3Byb3BzW2ldO1xuXHRcdFx0XHRcdFx0XHRiID0gdGhpcy5fYmV6aWVyc1twXVtjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdHZhbCA9ICh0ICogdCAqIGIuZGEgKyAzICogaW52ICogKHQgKiBiLmNhICsgaW52ICogYi5iYSkpICogdCArIGIuYTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX21vZFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9IHRoaXMuX21vZFtwXSh2YWwsIHRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0odmFsKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2F1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyID0gdGhpcy5fYXV0b1JvdGF0ZSxcblx0XHRcdFx0XHRcdFx0XHRiMiwgeDEsIHkxLCB4MiwgeTIsIGFkZCwgY29udjtcblx0XHRcdFx0XHRcdFx0aSA9IGFyLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IGFyW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdGFkZCA9IGFyW2ldWzNdIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0Y29udiA9IChhcltpXVs0XSA9PT0gdHJ1ZSkgPyAxIDogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMF1dO1xuXHRcdFx0XHRcdFx0XHRcdGIyID0gdGhpcy5fYmV6aWVyc1thcltpXVsxXV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoYiAmJiBiMikgeyAvL2luIGNhc2Ugb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGdvdCBvdmVyd3JpdHRlbi5cblx0XHRcdFx0XHRcdFx0XHRcdGIgPSBiW2N1ckluZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdGIyID0gYjJbY3VySW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR4MSA9IGIuYSArIChiLmIgLSBiLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyID0gYi5iICsgKGIuYyAtIGIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eDEgKz0gKHgyIC0geDEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgyICs9ICgoYi5jICsgKGIuZCAtIGIuYykgKiB0KSAtIHgyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHkxID0gYjIuYSArIChiMi5iIC0gYjIuYSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgPSBiMi5iICsgKGIyLmMgLSBiMi5iKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR5MSArPSAoeTIgLSB5MSkgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTIgKz0gKChiMi5jICsgKGIyLmQgLSBiMi5jKSAqIHQpIC0geTIpICogdDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gbm90U3RhcnQgPyBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpICogY29udiArIGFkZCA6IHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9tb2RbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsID0gdGhpcy5fbW9kW3BdKHZhbCwgdGFyZ2V0KTsgLy9mb3IgbW9kUHJvcHNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZ1bmNbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcF0gPSB2YWw7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRwID0gQmV6aWVyUGx1Z2luLnByb3RvdHlwZTtcblxuXG5cdFx0QmV6aWVyUGx1Z2luLmJlemllclRocm91Z2ggPSBiZXppZXJUaHJvdWdoO1xuXHRcdEJlemllclBsdWdpbi5jdWJpY1RvUXVhZHJhdGljID0gY3ViaWNUb1F1YWRyYXRpYztcblx0XHRCZXppZXJQbHVnaW4uX2F1dG9DU1MgPSB0cnVlOyAvL2luZGljYXRlcyB0aGF0IHRoaXMgcGx1Z2luIGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBcImNzc1wiIG9iamVjdCB1c2luZyB0aGUgYXV0b0NTUyBmZWF0dXJlIG9mIFR3ZWVuTGl0ZVxuXHRcdEJlemllclBsdWdpbi5xdWFkcmF0aWNUb0N1YmljID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHRcdFx0cmV0dXJuIG5ldyBTZWdtZW50KGEsICgyICogYiArIGEpIC8gMywgKDIgKiBiICsgYykgLyAzLCBjKTtcblx0XHR9O1xuXG5cdFx0QmV6aWVyUGx1Z2luLl9jc3NSZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIENTU1BsdWdpbiA9IF9nbG9iYWxzLkNTU1BsdWdpbjtcblx0XHRcdGlmICghQ1NTUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMsXG5cdFx0XHRcdF9wYXJzZVRvUHJveHkgPSBfaW50ZXJuYWxzLl9wYXJzZVRvUHJveHksXG5cdFx0XHRcdF9zZXRQbHVnaW5SYXRpbyA9IF9pbnRlcm5hbHMuX3NldFBsdWdpblJhdGlvLFxuXHRcdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2Vlbjtcblx0XHRcdF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcHJvcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0ZSA9IHt2YWx1ZXM6ZX07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luID0gbmV3IEJlemllclBsdWdpbigpO1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gZS52YWx1ZXMsXG5cdFx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAxLFxuXHRcdFx0XHRcdHBsdWdpblZhbHVlcyA9IFtdLFxuXHRcdFx0XHRcdHYgPSB7fSxcblx0XHRcdFx0XHRpLCBwLCBkYXRhO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8PSBsOyBpKyspIHtcblx0XHRcdFx0XHRkYXRhID0gX3BhcnNlVG9Qcm94eSh0LCB2YWx1ZXNbaV0sIGNzc3AsIHB0LCBwbHVnaW4sIChsICE9PSBpKSk7XG5cdFx0XHRcdFx0cGx1Z2luVmFsdWVzW2ldID0gZGF0YS5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIGUpIHtcblx0XHRcdFx0XHR2W3BdID0gZVtwXTsgLy9kdXBsaWNhdGUgdGhlIHZhcnMgb2JqZWN0IGJlY2F1c2Ugd2UgbmVlZCB0byBhbHRlciBzb21lIHRoaW5ncyB3aGljaCB3b3VsZCBjYXVzZSBwcm9ibGVtcyBpZiB0aGUgdXNlciBwbGFucyB0byByZXVzZSB0aGUgc2FtZSB2YXJzIG9iamVjdCBmb3IgYW5vdGhlciB0d2Vlbi5cblx0XHRcdFx0fVxuXHRcdFx0XHR2LnZhbHVlcyA9IHBsdWdpblZhbHVlcztcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIFwiYmV6aWVyXCIsIDAsIDAsIGRhdGEucHQsIDIpO1xuXHRcdFx0XHRwdC5kYXRhID0gZGF0YTtcblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRQbHVnaW5SYXRpbztcblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSA9PT0gMCkge1xuXHRcdFx0XHRcdHYuYXV0b1JvdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSAmJiAhKHYuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdGkgPSAodi5hdXRvUm90YXRlID09PSB0cnVlKSA/IDAgOiBOdW1iZXIodi5hdXRvUm90YXRlKTtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSAoZGF0YS5lbmQubGVmdCAhPSBudWxsKSA/IFtbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogKGRhdGEuZW5kLnggIT0gbnVsbCkgPyBbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixpLGZhbHNlXV0gOiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodi5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0aWYgKCFjc3NwLl90cmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRcdGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhLmF1dG9Sb3RhdGUgPSBjc3NwLl90YXJnZXQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdGRhdGEucHJveHkucm90YXRpb24gPSBkYXRhLmF1dG9Sb3RhdGUucm90YXRpb24gfHwgMDtcblx0XHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKFwicm90YXRpb25cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGx1Z2luLl9vbkluaXRUd2VlbihkYXRhLnByb3h5LCB2LCBjc3NwLl90d2Vlbik7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH19KTtcblx0XHR9O1xuXG5cdFx0cC5fbW9kID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgb3AgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0aSA9IG9wLmxlbmd0aCxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHZhbCA9IGxvb2t1cFtvcFtpXV07XG5cdFx0XHRcdGlmICh2YWwgJiYgdHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRoaXMuX21vZFtvcFtpXV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9wcm9wcyxcblx0XHRcdFx0cCwgaTtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9iZXppZXJzKSB7XG5cdFx0XHRcdGlmIChwIGluIGxvb2t1cCkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9iZXppZXJzW3BdO1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9mdW5jW3BdO1xuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmIChhW2ldID09PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YSA9IHRoaXMuX2F1dG9Sb3RhdGU7XG5cdFx0XHRpZiAoYSkge1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsb29rdXBbYVtpXVsyXV0pIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcywgbG9va3VwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDU1NQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLCBbXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJUd2VlbkxpdGVcIl0sIGZ1bmN0aW9uKFR3ZWVuUGx1Z2luLCBUd2VlbkxpdGUpIHtcblxuXHRcdC8qKiBAY29uc3RydWN0b3IgKiovXG5cdFx0dmFyIENTU1BsdWdpbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRUd2VlblBsdWdpbi5jYWxsKHRoaXMsIFwiY3NzXCIpO1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGggPSAwO1xuXHRcdFx0XHR0aGlzLnNldFJhdGlvID0gQ1NTUGx1Z2luLnByb3RvdHlwZS5zZXRSYXRpbzsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblx0XHRcdH0sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2hhc1ByaW9yaXR5LCAvL3R1cm5zIHRydWUgd2hlbmV2ZXIgYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgaXMgY3JlYXRlZCB0aGF0IGhhcyBhIHByaW9yaXR5IG90aGVyIHRoYW4gMC4gVGhpcyBoZWxwcyB1cyBkaXNjZXJuIHdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBzcGVuZCB0aGUgdGltZSBvcmdhbml6aW5nIHRoZSBsaW5rZWQgbGlzdCBvciBub3QgYWZ0ZXIgYSBDU1NQbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdFx0X3N1ZmZpeE1hcCwgLy93ZSBzZXQgdGhpcyBpbiBfb25Jbml0VHdlZW4oKSBlYWNoIHRpbWUgYXMgYSB3YXkgdG8gaGF2ZSBhIHBlcnNpc3RlbnQgdmFyaWFibGUgd2UgY2FuIHVzZSBpbiBvdGhlciBtZXRob2RzIGxpa2UgX3BhcnNlKCkgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgYSBwYXJhbWV0ZXIgYW5kIHdlIGtlZXAgX3BhcnNlKCkgZGVjb3VwbGVkIGZyb20gYSBwYXJ0aWN1bGFyIENTU1BsdWdpbiBpbnN0YW5jZVxuXHRcdFx0X2NzLCAvL2NvbXB1dGVkIHN0eWxlICh3ZSBzdG9yZSB0aGlzIGluIGEgc2hhcmVkIHZhcmlhYmxlIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgbWFrZSBtaW5pZmljYXRpb24gdGlnaHRlclxuXHRcdFx0X292ZXJ3cml0ZVByb3BzLCAvL2FsaWFzIHRvIHRoZSBjdXJyZW50bHkgaW5zdGFudGlhdGluZyBDU1NQbHVnaW4ncyBfb3ZlcndyaXRlUHJvcHMgYXJyYXkuIFdlIHVzZSB0aGlzIGNsb3N1cmUgaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIHRvIHBhc3MgYSByZWZlcmVuY2UgYXJvdW5kIGZyb20gbWV0aG9kIHRvIG1ldGhvZCBhbmQgYWlkIGluIG1pbmlmaWNhdGlvbi5cblx0XHRcdF9zcGVjaWFsUHJvcHMgPSB7fSxcblx0XHRcdHAgPSBDU1NQbHVnaW4ucHJvdG90eXBlID0gbmV3IFR3ZWVuUGx1Z2luKFwiY3NzXCIpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IENTU1BsdWdpbjtcblx0XHRDU1NQbHVnaW4udmVyc2lvbiA9IFwiMS4xOS4xXCI7XG5cdFx0Q1NTUGx1Z2luLkFQSSA9IDI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IDA7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZSA9IFwiY29tcGVuc2F0ZWRcIjtcblx0XHRDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiA9IHRydWU7XG5cdFx0cCA9IFwicHhcIjsgLy93ZSdsbCByZXVzZSB0aGUgXCJwXCIgdmFyaWFibGUgdG8ga2VlcCBmaWxlIHNpemUgZG93blxuXHRcdENTU1BsdWdpbi5zdWZmaXhNYXAgPSB7dG9wOnAsIHJpZ2h0OnAsIGJvdHRvbTpwLCBsZWZ0OnAsIHdpZHRoOnAsIGhlaWdodDpwLCBmb250U2l6ZTpwLCBwYWRkaW5nOnAsIG1hcmdpbjpwLCBwZXJzcGVjdGl2ZTpwLCBsaW5lSGVpZ2h0OlwiXCJ9O1xuXG5cblx0XHR2YXIgX251bUV4cCA9IC8oPzpcXC18XFwufFxcYikoXFxkfFxcLnxlXFwtKSsvZyxcblx0XHRcdF9yZWxOdW1FeHAgPSAvKD86XFxkfFxcLVxcZHxcXC5cXGR8XFwtXFwuXFxkfFxcKz1cXGR8XFwtPVxcZHxcXCs9LlxcZHxcXC09XFwuXFxkKSsvZyxcblx0XHRcdF92YWx1ZXNFeHAgPSAvKD86XFwrPXxcXC09fFxcLXxcXGIpW1xcZFxcLVxcLl0rW2EtekEtWjAtOV0qKD86JXxcXGIpL2dpLCAvL2ZpbmRzIGFsbCB0aGUgdmFsdWVzIHRoYXQgYmVnaW4gd2l0aCBudW1iZXJzIG9yICs9IG9yIC09IGFuZCB0aGVuIGEgbnVtYmVyLiBJbmNsdWRlcyBzdWZmaXhlcy4gV2UgdXNlIHRoaXMgdG8gc3BsaXQgY29tcGxleCB2YWx1ZXMgYXBhcnQgbGlrZSBcIjFweCA1cHggMjBweCByZ2IoMjU1LDEwMiw1MSlcIlxuXHRcdFx0X05hTkV4cCA9IC8oPyFbKy1dP1xcZCpcXC4/XFxkK3xbKy1dfGVbKy1dXFxkKylbXjAtOV0vZywgLy9hbHNvIGFsbG93cyBzY2llbnRpZmljIG5vdGF0aW9uIGFuZCBkb2Vzbid0IGtpbGwgdGhlIGxlYWRpbmcgLS8rIGluIC09IGFuZCArPVxuXHRcdFx0X3N1ZmZpeEV4cCA9IC8oPzpcXGR8XFwtfFxcK3w9fCN8XFwuKSovZyxcblx0XHRcdF9vcGFjaXR5RXhwID0gL29wYWNpdHkgKj0gKihbXildKikvaSxcblx0XHRcdF9vcGFjaXR5VmFsRXhwID0gL29wYWNpdHk6KFteO10qKS9pLFxuXHRcdFx0X2FscGhhRmlsdGVyRXhwID0gL2FscGhhXFwob3BhY2l0eSAqPS4rP1xcKS9pLFxuXHRcdFx0X3JnYmhzbEV4cCA9IC9eKHJnYnxoc2wpLyxcblx0XHRcdF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcblx0XHRcdF9jYW1lbEV4cCA9IC8tKFthLXpdKS9naSxcblx0XHRcdF91cmxFeHAgPSAvKF4oPzp1cmxcXChcXFwifHVybFxcKCkpfCg/OihcXFwiXFwpKSR8XFwpJCkvZ2ksIC8vZm9yIHB1bGxpbmcgb3V0IHVybHMgZnJvbSB1cmwoLi4uKSBvciB1cmwoXCIuLi5cIikgc3RyaW5ncyAoc29tZSBicm93c2VycyB3cmFwIHVybHMgaW4gcXVvdGVzLCBzb21lIGRvbid0IHdoZW4gcmVwb3J0aW5nIHRoaW5ncyBsaWtlIGJhY2tncm91bmRJbWFnZSlcblx0XHRcdF9jYW1lbEZ1bmMgPSBmdW5jdGlvbihzLCBnKSB7IHJldHVybiBnLnRvVXBwZXJDYXNlKCk7IH0sXG5cdFx0XHRfaG9yaXpFeHAgPSAvKD86TGVmdHxSaWdodHxXaWR0aCkvaSxcblx0XHRcdF9pZUdldE1hdHJpeEV4cCA9IC8oTTExfE0xMnxNMjF8TTIyKT1bXFxkXFwtXFwuZV0rL2dpLFxuXHRcdFx0X2llU2V0TWF0cml4RXhwID0gL3Byb2dpZFxcOkRYSW1hZ2VUcmFuc2Zvcm1cXC5NaWNyb3NvZnRcXC5NYXRyaXhcXCguKz9cXCkvaSxcblx0XHRcdF9jb21tYXNPdXRzaWRlUGFyZW5FeHAgPSAvLCg/PVteXFwpXSooPzpcXCh8JCkpL2dpLCAvL2ZpbmRzIGFueSBjb21tYXMgdGhhdCBhcmUgbm90IHdpdGhpbiBwYXJlbnRoZXNpc1xuXHRcdFx0X2NvbXBsZXhFeHAgPSAvW1xccyxcXChdL2ksIC8vZm9yIHRlc3RpbmcgYSBzdHJpbmcgdG8gZmluZCBpZiBpdCBoYXMgYSBzcGFjZSwgY29tbWEsIG9yIG9wZW4gcGFyZW50aGVzaXMgKGNsdWVzIHRoYXQgaXQncyBhIGNvbXBsZXggdmFsdWUpXG5cdFx0XHRfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG5cdFx0XHRfZm9yY2VQVCA9IHt9LFxuXHRcdFx0X2R1bW15RWxlbWVudCA9IHtzdHlsZTp7fX0sXG5cdFx0XHRfZG9jID0gX2dzU2NvcGUuZG9jdW1lbnQgfHwge2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge3JldHVybiBfZHVtbXlFbGVtZW50O319LFxuXHRcdFx0X2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBucykge1xuXHRcdFx0XHRyZXR1cm4gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cdFx0XHR9LFxuXHRcdFx0X3RlbXBEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0XHRcdF90ZW1wSW1nID0gX2NyZWF0ZUVsZW1lbnQoXCJpbWdcIiksXG5cdFx0XHRfaW50ZXJuYWxzID0gQ1NTUGx1Z2luLl9pbnRlcm5hbHMgPSB7X3NwZWNpYWxQcm9wczpfc3BlY2lhbFByb3BzfSwgLy9wcm92aWRlcyBhIGhvb2sgdG8gYSBmZXcgaW50ZXJuYWwgbWV0aG9kcyB0aGF0IHdlIG5lZWQgdG8gYWNjZXNzIGZyb20gaW5zaWRlIG90aGVyIHBsdWdpbnNcblx0XHRcdF9hZ2VudCA9IChfZ3NTY29wZS5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudCB8fCBcIlwiLFxuXHRcdFx0X2F1dG9Sb3VuZCxcblx0XHRcdF9yZXFTYWZhcmlGaXgsIC8vd2Ugd29uJ3QgYXBwbHkgdGhlIFNhZmFyaSB0cmFuc2Zvcm0gZml4IHVudGlsIHdlIGFjdHVhbGx5IGNvbWUgYWNyb3NzIGEgdHdlZW4gdGhhdCBhZmZlY3RzIGEgdHJhbnNmb3JtIHByb3BlcnR5ICh0byBtYWludGFpbiBiZXN0IHBlcmZvcm1hbmNlKS5cblxuXHRcdFx0X2lzU2FmYXJpLFxuXHRcdFx0X2lzRmlyZWZveCwgLy9GaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyAzRCB0cmFuc2Zvcm1lZCBlbGVtZW50cyB0byByYW5kb21seSBkaXNhcHBlYXIgdW5sZXNzIGEgcmVwYWludCBpcyBmb3JjZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb24gZWFjaCBlbGVtZW50LlxuXHRcdFx0X2lzU2FmYXJpTFQ2LCAvL1NhZmFyaSAoYW5kIEFuZHJvaWQgNCB3aGljaCB1c2VzIGEgZmxhdm9yIG9mIFNhZmFyaSkgaGFzIGEgYnVnIHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiBwcm9wZXJ0aWVzIGZyb20gcmVuZGVyaW5nIHByb3Blcmx5IGlmIGNoYW5nZWQgb24gdGhlIHNhbWUgZnJhbWUgYXMgYSB0cmFuc2Zvcm0gVU5MRVNTIHdlIHNldCB0aGUgZWxlbWVudCdzIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB0byBoaWRkZW4gKHdlaXJkLCBJIGtub3cpLiBEb2luZyB0aGlzIGZvciBBbmRyb2lkIDMgYW5kIGVhcmxpZXIgc2VlbXMgdG8gYWN0dWFsbHkgY2F1c2Ugb3RoZXIgcHJvYmxlbXMsIHRob3VnaCAoZnVuISlcblx0XHRcdF9pZVZlcnMsXG5cdFx0XHRfc3VwcG9ydHNPcGFjaXR5ID0gKGZ1bmN0aW9uKCkgeyAvL3dlIHNldCBfaXNTYWZhcmksIF9pZVZlcnMsIF9pc0ZpcmVmb3gsIGFuZCBfc3VwcG9ydHNPcGFjaXR5IGFsbCBpbiBvbmUgZnVuY3Rpb24gaGVyZSB0byByZWR1Y2UgZmlsZSBzaXplIHNsaWdodGx5LCBlc3BlY2lhbGx5IGluIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuXHRcdFx0XHR2YXIgaSA9IF9hZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSxcblx0XHRcdFx0XHRhID0gX2NyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdFx0XHRfaXNTYWZhcmkgPSAoX2FnZW50LmluZGV4T2YoXCJTYWZhcmlcIikgIT09IC0xICYmIF9hZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID09PSAtMSAmJiAoaSA9PT0gLTEgfHwgcGFyc2VGbG9hdChfYWdlbnQuc3Vic3RyKGkrOCwgMikpID4gMykpO1xuXHRcdFx0XHRfaXNTYWZhcmlMVDYgPSAoX2lzU2FmYXJpICYmIChwYXJzZUZsb2F0KF9hZ2VudC5zdWJzdHIoX2FnZW50LmluZGV4T2YoXCJWZXJzaW9uL1wiKSs4LCAyKSkgPCA2KSk7XG5cdFx0XHRcdF9pc0ZpcmVmb3ggPSAoX2FnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpICE9PSAtMSk7XG5cdFx0XHRcdGlmICgoL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkgfHwgKC9UcmlkZW50XFwvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KS8pLmV4ZWMoX2FnZW50KSkge1xuXHRcdFx0XHRcdF9pZVZlcnMgPSBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWEpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6MXB4O29wYWNpdHk6LjU1O1wiO1xuXHRcdFx0XHRyZXR1cm4gL14wLjU1Ly50ZXN0KGEuc3R5bGUub3BhY2l0eSk7XG5cdFx0XHR9KCkpLFxuXHRcdFx0X2dldElFT3BhY2l0eSA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0cmV0dXJuIChfb3BhY2l0eUV4cC50ZXN0KCAoKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIikgPyB2IDogKHYuY3VycmVudFN0eWxlID8gdi5jdXJyZW50U3R5bGUuZmlsdGVyIDogdi5zdHlsZS5maWx0ZXIpIHx8IFwiXCIpICkgPyAoIHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApIC8gMTAwICkgOiAxKTtcblx0XHRcdH0sXG5cdFx0XHRfbG9nID0gZnVuY3Rpb24ocykgey8vZm9yIGxvZ2dpbmcgbWVzc2FnZXMsIGJ1dCBpbiBhIHdheSB0aGF0IHdvbid0IHRocm93IGVycm9ycyBpbiBvbGQgdmVyc2lvbnMgb2YgSUUuXG5cdFx0XHRcdGlmIChfZ3NTY29wZS5jb25zb2xlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cocyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfdGFyZ2V0LCAvL3doZW4gaW5pdHRpbmcgYSBDU1NQbHVnaW4sIHdlIHNldCB0aGlzIHZhcmlhYmxlIHNvIHRoYXQgd2UgY2FuIGFjY2VzcyBpdCBmcm9tIHdpdGhpbiBtYW55IG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IGhhdmluZyB0byBwYXNzIGl0IGFyb3VuZCBhcyBwYXJhbXNcblx0XHRcdF9pbmRleCwgLy93aGVuIGluaXR0aW5nIGEgQ1NTUGx1Z2luLCB3ZSBzZXQgdGhpcyB2YXJpYWJsZSBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgaXQgZnJvbSB3aXRoaW4gbWFueSBvdGhlciBmdW5jdGlvbnMgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgcGFyYW1zXG5cblx0XHRcdF9wcmVmaXhDU1MgPSBcIlwiLCAvL3RoZSBub24tY2FtZWxDYXNlIHZlbmRvciBwcmVmaXggbGlrZSBcIi1vLVwiLCBcIi1tb3otXCIsIFwiLW1zLVwiLCBvciBcIi13ZWJraXQtXCJcblx0XHRcdF9wcmVmaXggPSBcIlwiLCAvL2NhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCJPXCIsIFwibXNcIiwgXCJXZWJraXRcIiwgb3IgXCJNb3pcIi5cblxuXHRcdFx0Ly8gQHByaXZhdGUgZmVlZCBpbiBhIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIGxpa2UgXCJ0cmFuc2Zvcm1cIiBhbmQgaXQgd2lsbCBjaGVjayB0byBzZWUgaWYgaXQgaXMgdmFsaWQgYXMtaXMgb3IgaWYgaXQgbmVlZHMgYSB2ZW5kb3IgcHJlZml4LiBJdCByZXR1cm5zIHRoZSBjb3JyZWN0ZWQgY2FtZWxDYXNlIHByb3BlcnR5IG5hbWUgKGkuZS4gXCJXZWJraXRUcmFuc2Zvcm1cIiBvciBcIk1velRyYW5zZm9ybVwiIG9yIFwidHJhbnNmb3JtXCIgb3IgbnVsbCBpZiBubyBzdWNoIHByb3BlcnR5IGlzIGZvdW5kLCBsaWtlIGlmIHRoZSBicm93c2VyIGlzIElFOCBvciBiZWZvcmUsIFwidHJhbnNmb3JtXCIgd29uJ3QgYmUgZm91bmQgYXQgYWxsKVxuXHRcdFx0X2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uKHAsIGUpIHtcblx0XHRcdFx0ZSA9IGUgfHwgX3RlbXBEaXY7XG5cdFx0XHRcdHZhciBzID0gZS5zdHlsZSxcblx0XHRcdFx0XHRhLCBpO1xuXHRcdFx0XHRpZiAoc1twXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKTtcblx0XHRcdFx0YSA9IFtcIk9cIixcIk1velwiLFwibXNcIixcIk1zXCIsXCJXZWJraXRcIl07XG5cdFx0XHRcdGkgPSA1O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEgJiYgc1thW2ldK3BdID09PSB1bmRlZmluZWQpIHsgfVxuXHRcdFx0XHRpZiAoaSA+PSAwKSB7XG5cdFx0XHRcdFx0X3ByZWZpeCA9IChpID09PSAzKSA/IFwibXNcIiA6IGFbaV07XG5cdFx0XHRcdFx0X3ByZWZpeENTUyA9IFwiLVwiICsgX3ByZWZpeC50b0xvd2VyQ2FzZSgpICsgXCItXCI7XG5cdFx0XHRcdFx0cmV0dXJuIF9wcmVmaXggKyBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0X2dldENvbXB1dGVkU3R5bGUgPSBfZG9jLmRlZmF1bHRWaWV3ID8gX2RvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlIDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIHRoZSBjc3Mgc3R5bGUgZm9yIGEgcGFydGljdWxhciBwcm9wZXJ0eSBvZiBhbiBlbGVtZW50LiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHdoYXRldmVyIHRoZSBjdXJyZW50IFwibGVmdFwiIGNzcyB2YWx1ZSBmb3IgYW4gZWxlbWVudCB3aXRoIGFuIElEIG9mIFwibXlFbGVtZW50XCIsIHlvdSBjb3VsZCBkbzpcblx0XHRcdCAqIHZhciBjdXJyZW50TGVmdCA9IENTU1BsdWdpbi5nZXRTdHlsZSggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUVsZW1lbnRcIiksIFwibGVmdFwiKTtcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnQgd2hvc2Ugc3R5bGUgcHJvcGVydHkgeW91IHdhbnQgdG8gcXVlcnlcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiIG9yIFwidG9wXCIgb3IgXCJtYXJnaW5Ub3BcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0LiBUaGlzIGp1c3QgcHJvdmlkZXMgYSB3YXkgdG8gc3BlZWQgcHJvY2Vzc2luZyBpZiB5b3UncmUgZ29pbmcgdG8gZ2V0IHNldmVyYWwgcHJvcGVydGllcyBvbiB0aGUgc2FtZSBlbGVtZW50IGluIHF1aWNrIHN1Y2Nlc3Npb24gLSB5b3UgY2FuIHJldXNlIHRoZSByZXN1bHQgb2YgdGhlIGdldENvbXB1dGVkU3R5bGUoKSBjYWxsLlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2FsYyBJZiB0cnVlLCB0aGUgdmFsdWUgd2lsbCBub3QgYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBlbGVtZW50J3MgXCJzdHlsZVwiIHByb3BlcnR5IChpZiBpdCBleGlzdHMgdGhlcmUpLCBidXQgaW5zdGVhZCB0aGUgZ2V0Q29tcHV0ZWRTdHlsZSgpIHJlc3VsdCB3aWxsIGJlIHVzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IHRoZSBicm93c2VyIGl0c2VsZiBpcyBpbnRlcnByZXRpbmcgdGhlIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBkZmx0IERlZmF1bHQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQgaW4gdGhlIHBsYWNlIG9mIG51bGwsIFwibm9uZVwiLCBcImF1dG9cIiBvciBcImF1dG8gYXV0b1wiLlxuXHRcdFx0ICogQHJldHVybiB7P3N0cmluZ30gVGhlIGN1cnJlbnQgcHJvcGVydHkgdmFsdWVcblx0XHRcdCAqL1xuXHRcdFx0X2dldFN0eWxlID0gQ1NTUGx1Z2luLmdldFN0eWxlID0gZnVuY3Rpb24odCwgcCwgY3MsIGNhbGMsIGRmbHQpIHtcblx0XHRcdFx0dmFyIHJ2O1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIGlmIChwID09PSBcIm9wYWNpdHlcIikgeyAvL3NldmVyYWwgdmVyc2lvbnMgb2YgSUUgZG9uJ3QgdXNlIHRoZSBzdGFuZGFyZCBcIm9wYWNpdHlcIiBwcm9wZXJ0eSAtIHRoZXkgdXNlIHRoaW5ncyBsaWtlIGZpbHRlcjphbHBoYShvcGFjaXR5PTUwKSwgc28gd2UgcGFyc2UgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdHJldHVybiBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghY2FsYyAmJiB0LnN0eWxlW3BdKSB7XG5cdFx0XHRcdFx0cnYgPSB0LnN0eWxlW3BdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQpKSkge1xuXHRcdFx0XHRcdHJ2ID0gY3NbcF0gfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwKSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHRydiA9IHQuY3VycmVudFN0eWxlW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZGZsdCAhPSBudWxsICYmICghcnYgfHwgcnYgPT09IFwibm9uZVwiIHx8IHJ2ID09PSBcImF1dG9cIiB8fCBydiA9PT0gXCJhdXRvIGF1dG9cIikpID8gZGZsdCA6IHJ2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBQYXNzIHRoZSB0YXJnZXQgZWxlbWVudCwgdGhlIHByb3BlcnR5IG5hbWUsIHRoZSBudW1lcmljIHZhbHVlLCBhbmQgdGhlIHN1ZmZpeCAobGlrZSBcIiVcIiwgXCJlbVwiLCBcInB4XCIsIGV0Yy4pIGFuZCBpdCB3aWxsIHNwaXQgYmFjayB0aGUgZXF1aXZhbGVudCBwaXhlbCBudW1iZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwibGVmdFwiLCBcInRvcFwiLCBcIm1hcmdpbkxlZnRcIiwgZXRjLilcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gdiBWYWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChsaWtlIFwicHhcIiBvciBcIiVcIiBvciBcImVtXCIpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWN1cnNlIElmIHRydWUsIHRoZSBjYWxsIGlzIGEgcmVjdXJzaXZlIG9uZS4gSW4gc29tZSBicm93c2VycyAobGlrZSBJRTcvOCksIG9jY2FzaW9uYWxseSB0aGUgdmFsdWUgaXNuJ3QgYWNjdXJhdGVseSByZXBvcnRlZCBpbml0aWFsbHksIGJ1dCBpZiB3ZSBydW4gdGhlIGZ1bmN0aW9uIGFnYWluIGl0IHdpbGwgdGFrZSBlZmZlY3QuXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IHZhbHVlIGluIHBpeGVsc1xuXHRcdFx0ICovXG5cdFx0XHRfY29udmVydFRvUGl4ZWxzID0gX2ludGVybmFscy5jb252ZXJ0VG9QaXhlbHMgPSBmdW5jdGlvbih0LCBwLCB2LCBzZngsIHJlY3Vyc2UpIHtcblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJweFwiIHx8ICFzZngpIHsgcmV0dXJuIHY7IH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJhdXRvXCIgfHwgIXYpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGhvcml6ID0gX2hvcml6RXhwLnRlc3QocCksXG5cdFx0XHRcdFx0bm9kZSA9IHQsXG5cdFx0XHRcdFx0c3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcblx0XHRcdFx0XHRuZWcgPSAodiA8IDApLFxuXHRcdFx0XHRcdHByZWNpc2UgPSAodiA9PT0gMSksXG5cdFx0XHRcdFx0cGl4LCBjYWNoZSwgdGltZTtcblx0XHRcdFx0aWYgKG5lZykge1xuXHRcdFx0XHRcdHYgPSAtdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJlY2lzZSkge1xuXHRcdFx0XHRcdHYgKj0gMTAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzZnggPT09IFwiJVwiICYmIHAuaW5kZXhPZihcImJvcmRlclwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRwaXggPSAodiAvIDEwMCkgKiAoaG9yaXogPyB0LmNsaWVudFdpZHRoIDogdC5jbGllbnRIZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowIHNvbGlkIHJlZDtwb3NpdGlvbjpcIiArIF9nZXRTdHlsZSh0LCBcInBvc2l0aW9uXCIpICsgXCI7bGluZS1oZWlnaHQ6MDtcIjtcblx0XHRcdFx0XHRpZiAoc2Z4ID09PSBcIiVcIiB8fCAhbm9kZS5hcHBlbmRDaGlsZCB8fCBzZnguY2hhckF0KDApID09PSBcInZcIiB8fCBzZnggPT09IFwicmVtXCIpIHtcblx0XHRcdFx0XHRcdG5vZGUgPSB0LnBhcmVudE5vZGUgfHwgX2RvYy5ib2R5O1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlO1xuXHRcdFx0XHRcdFx0dGltZSA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHRcdFx0XHRpZiAoY2FjaGUgJiYgaG9yaXogJiYgY2FjaGUudGltZSA9PT0gdGltZSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogd2UgcmVjb3JkIHRoZSB3aWR0aCBvZiBlbGVtZW50cyBhbG9uZyB3aXRoIHRoZSB0aWNrZXIgZnJhbWUgc28gdGhhdCB3ZSBjYW4gcXVpY2tseSBnZXQgaXQgYWdhaW4gb24gdGhlIHNhbWUgdGljayAoc2VlbXMgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSBpdCB3b3VsZG4ndCBjaGFuZ2Ugb24gdGhlIHNhbWUgdGljaylcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhY2hlLndpZHRoICogdiAvIDEwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlWyhob3JpeiA/IFwiYm9yZGVyTGVmdFdpZHRoXCIgOiBcImJvcmRlclRvcFdpZHRoXCIpXSA9IHYgKyBzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRcdHBpeCA9IHBhcnNlRmxvYXQoX3RlbXBEaXZbKGhvcml6ID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIildKTtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRpZiAoaG9yaXogJiYgc2Z4ID09PSBcIiVcIiAmJiBDU1NQbHVnaW4uY2FjaGVXaWR0aHMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZSA9IG5vZGUuX2dzQ2FjaGUgPSBub2RlLl9nc0NhY2hlIHx8IHt9O1xuXHRcdFx0XHRcdFx0Y2FjaGUudGltZSA9IHRpbWU7XG5cdFx0XHRcdFx0XHRjYWNoZS53aWR0aCA9IHBpeCAvIHYgKiAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwaXggPT09IDAgJiYgIXJlY3Vyc2UpIHtcblx0XHRcdFx0XHRcdHBpeCA9IF9jb252ZXJ0VG9QaXhlbHModCwgcCwgdiwgc2Z4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByZWNpc2UpIHtcblx0XHRcdFx0XHRwaXggLz0gMTAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBuZWcgPyAtcGl4IDogcGl4O1xuXHRcdFx0fSxcblx0XHRcdF9jYWxjdWxhdGVPZmZzZXQgPSBfaW50ZXJuYWxzLmNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uKHQsIHAsIGNzKSB7IC8vZm9yIGZpZ3VyaW5nIG91dCBcInRvcFwiIG9yIFwibGVmdFwiIGluIHB4IHdoZW4gaXQncyBcImF1dG9cIi4gV2UgbmVlZCB0byBmYWN0b3IgaW4gbWFyZ2luIHdpdGggdGhlIG9mZnNldExlZnQvb2Zmc2V0VG9wXG5cdFx0XHRcdGlmIChfZ2V0U3R5bGUodCwgXCJwb3NpdGlvblwiLCBjcykgIT09IFwiYWJzb2x1dGVcIikgeyByZXR1cm4gMDsgfVxuXHRcdFx0XHR2YXIgZGltID0gKChwID09PSBcImxlZnRcIikgPyBcIkxlZnRcIiA6IFwiVG9wXCIpLFxuXHRcdFx0XHRcdHYgPSBfZ2V0U3R5bGUodCwgXCJtYXJnaW5cIiArIGRpbSwgY3MpO1xuXHRcdFx0XHRyZXR1cm4gdFtcIm9mZnNldFwiICsgZGltXSAtIChfY29udmVydFRvUGl4ZWxzKHQsIHAsIHBhcnNlRmxvYXQodiksIHYucmVwbGFjZShfc3VmZml4RXhwLCBcIlwiKSkgfHwgMCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSByZXR1cm5zIGF0IG9iamVjdCBjb250YWluaW5nIEFMTCBvZiB0aGUgc3R5bGUgcHJvcGVydGllcyBpbiBjYW1lbENhc2UgYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzLlxuXHRcdFx0X2dldEFsbFN0eWxlcyA9IGZ1bmN0aW9uKHQsIGNzKSB7XG5cdFx0XHRcdHZhciBzID0ge30sXG5cdFx0XHRcdFx0aSwgdHIsIHA7XG5cdFx0XHRcdGlmICgoY3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSkpIHtcblx0XHRcdFx0XHRpZiAoKGkgPSBjcy5sZW5ndGgpKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0cCA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAocC5pbmRleE9mKFwiLXRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3BDU1MgPT09IHApIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1twLnJlcGxhY2UoX2NhbWVsRXhwLCBfY2FtZWxGdW5jKV0gPSBjcy5nZXRQcm9wZXJ0eVZhbHVlKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9zb21lIGJyb3dzZXJzIGJlaGF2ZSBkaWZmZXJlbnRseSAtIGNzLmxlbmd0aCBpcyBhbHdheXMgMCwgc28gd2UgbXVzdCBkbyBhIGZvci4uLmluIGxvb3AuXG5cdFx0XHRcdFx0XHRmb3IgKGkgaW4gY3MpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGkuaW5kZXhPZihcIlRyYW5zZm9ybVwiKSA9PT0gLTEgfHwgX3RyYW5zZm9ybVByb3AgPT09IGkpIHsgLy9Tb21lIHdlYmtpdCBicm93c2VycyBkdXBsaWNhdGUgdHJhbnNmb3JtIHZhbHVlcywgb25lIG5vbi1wcmVmaXhlZCBhbmQgb25lIHByZWZpeGVkIChcInRyYW5zZm9ybVwiIGFuZCBcIldlYmtpdFRyYW5zZm9ybVwiKSwgc28gd2UgbXVzdCB3ZWVkIG91dCB0aGUgZXh0cmEgb25lIGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0c1tpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKChjcyA9IHQuY3VycmVudFN0eWxlIHx8IHQuc3R5bGUpKSB7XG5cdFx0XHRcdFx0Zm9yIChpIGluIGNzKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mKGkpID09PSBcInN0cmluZ1wiICYmIHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRzW2kucmVwbGFjZShfY2FtZWxFeHAsIF9jYW1lbEZ1bmMpXSA9IGNzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0XHRzLm9wYWNpdHkgPSBfZ2V0SUVPcGFjaXR5KHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyID0gX2dldFRyYW5zZm9ybSh0LCBjcywgZmFsc2UpO1xuXHRcdFx0XHRzLnJvdGF0aW9uID0gdHIucm90YXRpb247XG5cdFx0XHRcdHMuc2tld1ggPSB0ci5za2V3WDtcblx0XHRcdFx0cy5zY2FsZVggPSB0ci5zY2FsZVg7XG5cdFx0XHRcdHMuc2NhbGVZID0gdHIuc2NhbGVZO1xuXHRcdFx0XHRzLnggPSB0ci54O1xuXHRcdFx0XHRzLnkgPSB0ci55O1xuXHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRzLnogPSB0ci56O1xuXHRcdFx0XHRcdHMucm90YXRpb25YID0gdHIucm90YXRpb25YO1xuXHRcdFx0XHRcdHMucm90YXRpb25ZID0gdHIucm90YXRpb25ZO1xuXHRcdFx0XHRcdHMuc2NhbGVaID0gdHIuc2NhbGVaO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzLmZpbHRlcnMpIHtcblx0XHRcdFx0XHRkZWxldGUgcy5maWx0ZXJzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgYW5hbHl6ZXMgdHdvIHN0eWxlIG9iamVjdHMgKGFzIHJldHVybmVkIGJ5IF9nZXRBbGxTdHlsZXMoKSkgYW5kIG9ubHkgbG9va3MgZm9yIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlbSB0aGF0IGNvbnRhaW4gdHdlZW5hYmxlIHZhbHVlcyAobGlrZSBhIG51bWJlciBvciBjb2xvcikuIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBcImRpZnNcIiBwcm9wZXJ0eSB3aGljaCByZWZlcnMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aG9zZSBpc29sYXRlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgZm9yIHR3ZWVuaW5nLCBhbmQgYSBcImZpcnN0TVBUXCIgcHJvcGVydHkgd2hpY2ggcmVmZXJzIHRvIHRoZSBmaXJzdCBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGluIGEgbGlua2VkIGxpc3QgdGhhdCByZWNvcmRlZCBhbGwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGUgZGlmZmVyZW50IHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIHRoZW0gYXQgdGhlIGVuZCBvciBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIC0gd2UgZG9uJ3Qgd2FudCB0aGUgY2FzY2FkaW5nIHRvIGdldCBtZXNzZWQgdXAuIFRoZSBmb3JjZUxvb2t1cCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uYWwgZ2VuZXJpYyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGZvcmNlZCBpbnRvIHRoZSByZXN1bHRzIC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBhcmUgb3ZlcndyaXRpbmcgb3RoZXJzIGJlY2F1c2UgaW1hZ2luZSBhIHNjZW5hcmlvIHdoZXJlIGEgcm9sbG92ZXIvcm9sbG91dCBhZGRzL3JlbW92ZXMgYSBjbGFzcyBhbmQgdGhlIHVzZXIgc3dpcGVzIHRoZSBtb3VzZSBvdmVyIHRoZSB0YXJnZXQgU1VQRVIgZmFzdCwgdGh1cyBub3RoaW5nIGFjdHVhbGx5IGNoYW5nZWQgeWV0IGFuZCB0aGUgc3Vic2VxdWVudCBjb21wYXJpc29uIG9mIHRoZSBwcm9wZXJ0aWVzIHdvdWxkIGluZGljYXRlIHRoZXkgbWF0Y2ggKGVzcGVjaWFsbHkgd2hlbiBweCByb3VuZGluZyBpcyB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24pLCB0aHVzIG5vIHR3ZWVuaW5nIGlzIG5lY2Vzc2FyeSBldmVuIHRob3VnaCBpdCBTSE9VTEQgdHdlZW4gYW5kIHJlbW92ZSB0aG9zZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSB0d2VlbiAob3RoZXJ3aXNlIHRoZSBpbmxpbmUgc3R5bGVzIHdpbGwgY29udGFtaW5hdGUgdGhpbmdzKS4gU2VlIHRoZSBjbGFzc05hbWUgU3BlY2lhbFByb3AgY29kZSBmb3IgZGV0YWlscy5cblx0XHRcdF9jc3NEaWYgPSBmdW5jdGlvbih0LCBzMSwgczIsIHZhcnMsIGZvcmNlTG9va3VwKSB7XG5cdFx0XHRcdHZhciBkaWZzID0ge30sXG5cdFx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRcdHZhbCwgcCwgbXB0O1xuXHRcdFx0XHRmb3IgKHAgaW4gczIpIHtcblx0XHRcdFx0XHRpZiAocCAhPT0gXCJjc3NUZXh0XCIpIGlmIChwICE9PSBcImxlbmd0aFwiKSBpZiAoaXNOYU4ocCkpIGlmIChzMVtwXSAhPT0gKHZhbCA9IHMyW3BdKSB8fCAoZm9yY2VMb29rdXAgJiYgZm9yY2VMb29rdXBbcF0pKSBpZiAocC5pbmRleE9mKFwiT3JpZ2luXCIpID09PSAtMSkgaWYgKHR5cGVvZih2YWwpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0XHRkaWZzW3BdID0gKHZhbCA9PT0gXCJhdXRvXCIgJiYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpKSA/IF9jYWxjdWxhdGVPZmZzZXQodCwgcCkgOiAoKHZhbCA9PT0gXCJcIiB8fCB2YWwgPT09IFwiYXV0b1wiIHx8IHZhbCA9PT0gXCJub25lXCIpICYmIHR5cGVvZihzMVtwXSkgPT09IFwic3RyaW5nXCIgJiYgczFbcF0ucmVwbGFjZShfTmFORXhwLCBcIlwiKSAhPT0gXCJcIikgPyAwIDogdmFsOyAvL2lmIHRoZSBlbmRpbmcgdmFsdWUgaXMgZGVmYXVsdGluZyAoXCJcIiBvciBcImF1dG9cIiksIHdlIGNoZWNrIHRoZSBzdGFydGluZyB2YWx1ZSBhbmQgaWYgaXQgY2FuIGJlIHBhcnNlZCBpbnRvIGEgbnVtYmVyIChhIHN0cmluZyB3aGljaCBjb3VsZCBoYXZlIGEgc3VmZml4IHRvbywgbGlrZSA3MDBweCksIHRoZW4gd2Ugc3dhcCBpbiAwIGZvciBcIlwiIG9yIFwiYXV0b1wiIHNvIHRoYXQgdGhpbmdzIGFjdHVhbGx5IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHN0eWxlW3BdICE9PSB1bmRlZmluZWQpIHsgLy9mb3IgY2xhc3NOYW1lIHR3ZWVucywgd2UgbXVzdCByZW1lbWJlciB3aGljaCBwcm9wZXJ0aWVzIGFscmVhZHkgZXhpc3RlZCBpbmxpbmUgLSB0aGUgb25lcyB0aGF0IGRpZG4ndCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHRoZSB0d2VlbiBpc24ndCBpbiBwcm9ncmVzcyBiZWNhdXNlIHRoZXkgd2VyZSBvbmx5IGludHJvZHVjZWQgdG8gZmFjaWxpdGF0ZSB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIGNsYXNzZXMuXG5cdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHN0eWxlLCBwLCBzdHlsZVtwXSwgbXB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHZhcnMpIHtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykgeyAvL2NvcHkgcHJvcGVydGllcyAoZXhjZXB0IGNsYXNzTmFtZSlcblx0XHRcdFx0XHRcdGlmIChwICE9PSBcImNsYXNzTmFtZVwiKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge2RpZnM6ZGlmcywgZmlyc3RNUFQ6bXB0fTtcblx0XHRcdH0sXG5cdFx0XHRfZGltZW5zaW9ucyA9IHt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSwgaGVpZ2h0OltcIlRvcFwiLFwiQm90dG9tXCJdfSxcblx0XHRcdF9tYXJnaW5zID0gW1wibWFyZ2luTGVmdFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpblRvcFwiLFwibWFyZ2luQm90dG9tXCJdLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEdldHMgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiBhbiBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChcIndpZHRoXCIgb3IgXCJoZWlnaHRcIilcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gY3MgQ29tcHV0ZWQgc3R5bGUgb2JqZWN0IChpZiBvbmUgZXhpc3RzKS4gSnVzdCBhIHNwZWVkIG9wdGltaXphdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gRGltZW5zaW9uIChpbiBwaXhlbHMpXG5cdFx0XHQgKi9cblx0XHRcdF9nZXREaW1lbnNpb24gPSBmdW5jdGlvbih0LCBwLCBjcykge1xuXHRcdFx0XHRpZiAoKHQubm9kZU5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7IC8vQ2hyb21lIG5vIGxvbmdlciBzdXBwb3J0cyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgb24gU1ZHIGVsZW1lbnRzLlxuXHRcdFx0XHRcdHJldHVybiAoY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCkpW3BdIHx8IDA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodC5nZXRDVE0gJiYgX2lzU1ZHKHQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuZ2V0QkJveCgpW3BdIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHYgPSBwYXJzZUZsb2F0KChwID09PSBcIndpZHRoXCIpID8gdC5vZmZzZXRXaWR0aCA6IHQub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRhID0gX2RpbWVuc2lvbnNbcF0sXG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRjcyA9IGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQsIG51bGwpO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR2IC09IHBhcnNlRmxvYXQoIF9nZXRTdHlsZSh0LCBcInBhZGRpbmdcIiArIGFbaV0sIGNzLCB0cnVlKSApIHx8IDA7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJib3JkZXJcIiArIGFbaV0gKyBcIldpZHRoXCIsIGNzLCB0cnVlKSApIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSBQYXJzZXMgcG9zaXRpb24tcmVsYXRlZCBjb21wbGV4IHN0cmluZ3MgbGlrZSBcInRvcCBsZWZ0XCIgb3IgXCI1MHB4IDEwcHhcIiBvciBcIjcwJSAyMCVcIiwgZXRjLiB3aGljaCBhcmUgdXNlZCBmb3IgdGhpbmdzIGxpa2UgdHJhbnNmb3JtT3JpZ2luIG9yIGJhY2tncm91bmRQb3NpdGlvbi4gT3B0aW9uYWxseSBkZWNvcmF0ZXMgYSBzdXBwbGllZCBvYmplY3QgKHJlY09iaikgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IFwib3hcIiAob2Zmc2V0WCksIFwib3lcIiAob2Zmc2V0WSksIFwib3hwXCIgKGlmIHRydWUsIFwib3hcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpLCBhbmQgXCJveHlcIiAoaWYgdHJ1ZSwgXCJveVwiIGlzIGEgcGVyY2VudGFnZSBub3QgYSBwaXhlbCB2YWx1ZSlcblx0XHRcdF9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24odiwgcmVjT2JqKSB7XG5cdFx0XHRcdGlmICh2ID09PSBcImNvbnRhaW5cIiB8fCB2ID09PSBcImF1dG9cIiB8fCB2ID09PSBcImF1dG8gYXV0b1wiKSB7IC8vbm90ZTogRmlyZWZveCB1c2VzIFwiYXV0byBhdXRvXCIgYXMgZGVmYXVsdCB3aGVyZWFzIENocm9tZSB1c2VzIFwiYXV0b1wiLlxuXHRcdFx0XHRcdHJldHVybiB2ICsgXCIgXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYgPT0gbnVsbCB8fCB2ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0diA9IFwiMCAwXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHR4ID0gKHYuaW5kZXhPZihcImxlZnRcIikgIT09IC0xKSA/IFwiMCVcIiA6ICh2LmluZGV4T2YoXCJyaWdodFwiKSAhPT0gLTEpID8gXCIxMDAlXCIgOiBhWzBdLFxuXHRcdFx0XHRcdHkgPSAodi5pbmRleE9mKFwidG9wXCIpICE9PSAtMSkgPyBcIjAlXCIgOiAodi5pbmRleE9mKFwiYm90dG9tXCIpICE9PSAtMSkgPyBcIjEwMCVcIiA6IGFbMV0sXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMyAmJiAhcmVjT2JqKSB7IC8vbXVsdGlwbGUgcG9zaXRpb25zXG5cdFx0XHRcdFx0YSA9IHYuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0diA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2LnB1c2goX3BhcnNlUG9zaXRpb24oYVtpXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdi5qb2luKFwiLFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0eSA9ICh4ID09PSBcImNlbnRlclwiKSA/IFwiNTAlXCIgOiBcIjBcIjtcblx0XHRcdFx0fSBlbHNlIGlmICh5ID09PSBcImNlbnRlclwiKSB7XG5cdFx0XHRcdFx0eSA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHggPT09IFwiY2VudGVyXCIgfHwgKGlzTmFOKHBhcnNlRmxvYXQoeCkpICYmICh4ICsgXCJcIikuaW5kZXhPZihcIj1cIikgPT09IC0xKSkgeyAvL3JlbWVtYmVyLCB0aGUgdXNlciBjb3VsZCBmbGlwLWZsb3AgdGhlIHZhbHVlcyBhbmQgc2F5IFwiYm90dG9tIGNlbnRlclwiIG9yIFwiY2VudGVyIGJvdHRvbVwiLCBldGMuIFwiY2VudGVyXCIgaXMgYW1iaWd1b3VzIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZCB0byBkZXNjcmliZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsLCBoZW5jZSB0aGUgaXNOYU4oKS4gSWYgdGhlcmUncyBhbiBcIj1cIiBzaWduIGluIHRoZSB2YWx1ZSwgaXQncyByZWxhdGl2ZS5cblx0XHRcdFx0XHR4ID0gXCI1MCVcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ID0geCArIFwiIFwiICsgeSArICgoYS5sZW5ndGggPiAyKSA/IFwiIFwiICsgYVsyXSA6IFwiXCIpO1xuXHRcdFx0XHRpZiAocmVjT2JqKSB7XG5cdFx0XHRcdFx0cmVjT2JqLm94cCA9ICh4LmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0cmVjT2JqLm95cCA9ICh5LmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0cmVjT2JqLm94ciA9ICh4LmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdHJlY09iai5veXIgPSAoeS5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3ggPSBwYXJzZUZsb2F0KHgucmVwbGFjZShfTmFORXhwLCBcIlwiKSk7XG5cdFx0XHRcdFx0cmVjT2JqLm95ID0gcGFyc2VGbG9hdCh5LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai52ID0gdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVjT2JqIHx8IHY7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFRha2VzIGFuIGVuZGluZyB2YWx1ZSAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY2FuIGJlIGEgbnVtYmVyKSBhbmQgYSBzdGFydGluZyB2YWx1ZSBhbmQgcmV0dXJucyB0aGUgY2hhbmdlIGJldHdlZW4gdGhlIHR3bywgbG9va2luZyBmb3IgcmVsYXRpdmUgdmFsdWUgaW5kaWNhdG9ycyBsaWtlICs9IGFuZCAtPSBhbmQgaXQgYWxzbyBpZ25vcmVzIHN1ZmZpeGVzIChidXQgbWFrZSBzdXJlIHRoZSBlbmRpbmcgdmFsdWUgc3RhcnRzIHdpdGggYSBudW1iZXIgb3IgKz0vLT0gYW5kIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlIGlzIGEgTlVNQkVSISlcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBlIEVuZCB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBjb3VsZCBiZSBhIG51bWJlclxuXHRcdFx0ICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGIgQmVnaW5uaW5nIHZhbHVlIHdoaWNoIGlzIHR5cGljYWxseSBhIHN0cmluZyBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gQW1vdW50IG9mIGNoYW5nZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgKHJlbGF0aXZlIHZhbHVlcyB0aGF0IGhhdmUgYSBcIis9XCIgb3IgXCItPVwiIGFyZSByZWNvZ25pemVkKVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDaGFuZ2UgPSBmdW5jdGlvbihlLCBiKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoZSkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGUgPSBlKF9pbmRleCwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICh0eXBlb2YoZSkgPT09IFwic3RyaW5nXCIgJiYgZS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KGUuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoZSkgLSBwYXJzZUZsb2F0KGIpKSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhIHZhbHVlIGFuZCBhIGRlZmF1bHQgbnVtYmVyLCBjaGVja3MgaWYgdGhlIHZhbHVlIGlzIHJlbGF0aXZlLCBudWxsLCBvciBudW1lcmljIGFuZCBzcGl0cyBiYWNrIGEgbm9ybWFsaXplZCBudW1iZXIgYWNjb3JkaW5nbHkuIFByaW1hcmlseSB1c2VkIGluIHRoZSBfcGFyc2VUcmFuc2Zvcm0oKSBmdW5jdGlvbi5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gUGFyc2VkIHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdF9wYXJzZVZhbCA9IGZ1bmN0aW9uKHYsIGQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0diA9IHYoX2luZGV4LCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHYgPT0gbnVsbCkgPyBkIDogKHR5cGVvZih2KSA9PT0gXCJzdHJpbmdcIiAmJiB2LmNoYXJBdCgxKSA9PT0gXCI9XCIpID8gcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdCh2LnN1YnN0cigyKSkgKyBkIDogcGFyc2VGbG9hdCh2KSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUcmFuc2xhdGVzIHN0cmluZ3MgbGlrZSBcIjQwZGVnXCIgb3IgXCI0MFwiIG9yIDQwcmFkXCIgb3IgXCIrPTQwZGVnXCIgb3IgXCIyNzBfc2hvcnRcIiBvciBcIi05MF9jd1wiIG9yIFwiKz00NV9jY3dcIiB0byBhIG51bWVyaWMgcmFkaWFuIGFuZ2xlLiBPZiBjb3Vyc2UgYSBzdGFydGluZy9kZWZhdWx0IHZhbHVlIG11c3QgYmUgZmVkIGluIHRvbyBzbyB0aGF0IHJlbGF0aXZlIHZhbHVlcyBjYW4gYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshbnVtYmVyfSBkIERlZmF1bHQgdmFsdWUgKHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgcmVsYXRpdmUgY2FsY3VsYXRpb25zIGlmIFwiKz1cIiBvciBcIi09XCIgaXMgZm91bmQgaW4gdGhlIGZpcnN0IHBhcmFtZXRlcilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gcCBwcm9wZXJ0eSBuYW1lIGZvciBkaXJlY3Rpb25hbEVuZCAob3B0aW9uYWwgLSBvbmx5IHVzZWQgd2hlbiB0aGUgcGFyc2VkIHZhbHVlIGlzIGRpcmVjdGlvbmFsIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbikuIFByb3BlcnR5IG5hbWUgd291bGQgYmUgXCJyb3RhdGlvblwiLCBcInJvdGF0aW9uWFwiLCBvciBcInJvdGF0aW9uWVwiXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGRpcmVjdGlvbmFsRW5kIEFuIG9iamVjdCB0aGF0IHdpbGwgc3RvcmUgdGhlIHJhdyBlbmQgdmFsdWVzIGZvciBkaXJlY3Rpb25hbCBhbmdsZXMgKFwiX3Nob3J0XCIsIFwiX2N3XCIsIG9yIFwiX2Njd1wiIHN1ZmZpeCkuIFdlIG5lZWQgYSB3YXkgdG8gc3RvcmUgdGhlIHVuY29tcGVuc2F0ZWQgdmFsdWUgc28gdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IGl0IHRvIGV4YWN0bHkgd2hhdCB3YXMgcmVxdWVzdGVkIHdpdGggbm8gZGlyZWN0aW9uYWwgY29tcGVuc2F0aW9uLlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSBwYXJzZWQgYW5nbGUgaW4gcmFkaWFuc1xuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VBbmdsZSA9IGZ1bmN0aW9uKHYsIGQsIHAsIGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdHZhciBtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHRjYXAsIHNwbGl0LCBkaWYsIHJlc3VsdCwgaXNSZWxhdGl2ZTtcblx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0diA9IHYoX2luZGV4LCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZDtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSB2O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhcCA9IDM2MDtcblx0XHRcdFx0XHRzcGxpdCA9IHYuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdGlzUmVsYXRpdmUgPSAodi5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRkaWYgPSAoaXNSZWxhdGl2ZSA/IHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoc3BsaXRbMF0uc3Vic3RyKDIpKSA6IHBhcnNlRmxvYXQoc3BsaXRbMF0pKSAqICgodi5pbmRleE9mKFwicmFkXCIpID09PSAtMSkgPyAxIDogX1JBRDJERUcpIC0gKGlzUmVsYXRpdmUgPyAwIDogZCk7XG5cdFx0XHRcdFx0aWYgKHNwbGl0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKGRpcmVjdGlvbmFsRW5kKSB7XG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbmFsRW5kW3BdID0gZCArIGRpZjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IGQgKyBkaWY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3VsdCA8IG1pbiAmJiByZXN1bHQgPiAtbWluKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSxcblxuXHRcdFx0X2NvbG9yTG9va3VwID0ge2FxdWE6WzAsMjU1LDI1NV0sXG5cdFx0XHRcdGxpbWU6WzAsMjU1LDBdLFxuXHRcdFx0XHRzaWx2ZXI6WzE5MiwxOTIsMTkyXSxcblx0XHRcdFx0YmxhY2s6WzAsMCwwXSxcblx0XHRcdFx0bWFyb29uOlsxMjgsMCwwXSxcblx0XHRcdFx0dGVhbDpbMCwxMjgsMTI4XSxcblx0XHRcdFx0Ymx1ZTpbMCwwLDI1NV0sXG5cdFx0XHRcdG5hdnk6WzAsMCwxMjhdLFxuXHRcdFx0XHR3aGl0ZTpbMjU1LDI1NSwyNTVdLFxuXHRcdFx0XHRmdWNoc2lhOlsyNTUsMCwyNTVdLFxuXHRcdFx0XHRvbGl2ZTpbMTI4LDEyOCwwXSxcblx0XHRcdFx0eWVsbG93OlsyNTUsMjU1LDBdLFxuXHRcdFx0XHRvcmFuZ2U6WzI1NSwxNjUsMF0sXG5cdFx0XHRcdGdyYXk6WzEyOCwxMjgsMTI4XSxcblx0XHRcdFx0cHVycGxlOlsxMjgsMCwxMjhdLFxuXHRcdFx0XHRncmVlbjpbMCwxMjgsMF0sXG5cdFx0XHRcdHJlZDpbMjU1LDAsMF0sXG5cdFx0XHRcdHBpbms6WzI1NSwxOTIsMjAzXSxcblx0XHRcdFx0Y3lhbjpbMCwyNTUsMjU1XSxcblx0XHRcdFx0dHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1LDBdfSxcblxuXHRcdFx0X2h1ZSA9IGZ1bmN0aW9uKGgsIG0xLCBtMikge1xuXHRcdFx0XHRoID0gKGggPCAwKSA/IGggKyAxIDogKGggPiAxKSA/IGggLSAxIDogaDtcblx0XHRcdFx0cmV0dXJuICgoKChoICogNiA8IDEpID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IChoIDwgMC41KSA/IG0yIDogKGggKiAzIDwgMikgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIDI1NSkgKyAwLjUpIHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUGFyc2VzIGEgY29sb3IgKGxpa2UgIzlGMCwgI0ZGOTkwMCwgcmdiKDI1NSw1MSwxNTMpIG9yIGhzbCgxMDgsIDUwJSwgMTAlKSkgaW50byBhbiBhcnJheSB3aXRoIDMgZWxlbWVudHMgZm9yIHJlZCwgZ3JlZW4sIGFuZCBibHVlIG9yIGlmIHRvSFNMIHBhcmFtZXRlciBpcyB0cnVlLCBpdCB3aWxsIHBvcHVsYXRlIHRoZSBhcnJheSB3aXRoIGh1ZSwgc2F0dXJhdGlvbiwgYW5kIGxpZ2h0bmVzcyB2YWx1ZXMuIElmIGEgcmVsYXRpdmUgdmFsdWUgaXMgZm91bmQgaW4gYW4gaHNsKCkgb3IgaHNsYSgpIHN0cmluZywgaXQgd2lsbCBwcmVzZXJ2ZSB0aG9zZSByZWxhdGl2ZSBwcmVmaXhlcyBhbmQgYWxsIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IHdpbGwgYmUgc3RyaW5ncyBpbnN0ZWFkIG9mIG51bWJlcnMgKGluIGFsbCBvdGhlciBjYXNlcyBpdCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIG51bWJlcnMpLlxuXHRcdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IHYgVGhlIHZhbHVlIHRoZSBzaG91bGQgYmUgcGFyc2VkIHdoaWNoIGNvdWxkIGJlIGEgc3RyaW5nIGxpa2UgIzlGMCBvciByZ2IoMjU1LDEwMiw1MSkgb3IgcmdiYSgyNTUsMCwwLDAuNSkgb3IgaXQgY291bGQgYmUgYSBudW1iZXIgbGlrZSAweEZGMDBDQyBvciBldmVuIGEgbmFtZWQgY29sb3IgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXHRcdFx0ICogQHBhcmFtIHsoYm9vbGVhbil9IHRvSFNMIElmIHRydWUsIGFuIGhzbCgpIG9yIGhzbGEoKSB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgcmdiKCkgb3IgcmdiYSgpXG5cdFx0XHQgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgY29udGFpbmluZyByZWQsIGdyZWVuLCBhbmQgYmx1ZSAoYW5kIG9wdGlvbmFsbHkgYWxwaGEpIGluIHRoYXQgb3JkZXIsIG9yIGlmIHRoZSB0b0hTTCBwYXJhbWV0ZXIgd2FzIHRydWUsIHRoZSBhcnJheSB3aWxsIGNvbnRhaW4gaHVlLCBzYXR1cmF0aW9uIGFuZCBsaWdodG5lc3MgKGFuZCBvcHRpb25hbGx5IGFscGhhKSBpbiB0aGF0IG9yZGVyLiBBbHdheXMgbnVtYmVycyB1bmxlc3MgdGhlcmUncyBhIHJlbGF0aXZlIHByZWZpeCBmb3VuZCBpbiBhbiBoc2woKSBvciBoc2xhKCkgc3RyaW5nIGFuZCB0b0hTTCBpcyB0cnVlLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb2xvciA9IENTU1BsdWdpbi5wYXJzZUNvbG9yID0gZnVuY3Rpb24odiwgdG9IU0wpIHtcblx0XHRcdFx0dmFyIGEsIHIsIGcsIGIsIGgsIHMsIGwsIG1heCwgbWluLCBkLCB3YXNIU0w7XG5cdFx0XHRcdGlmICghdikge1xuXHRcdFx0XHRcdGEgPSBfY29sb3JMb29rdXAuYmxhY2s7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0YSA9IFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHYuY2hhckF0KHYubGVuZ3RoIC0gMSkgPT09IFwiLFwiKSB7IC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG5cdFx0XHRcdFx0XHR2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKF9jb2xvckxvb2t1cFt2XSkge1xuXHRcdFx0XHRcdFx0YSA9IF9jb2xvckxvb2t1cFt2XTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuXHRcdFx0XHRcdFx0aWYgKHYubGVuZ3RoID09PSA0KSB7IC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjBcblx0XHRcdFx0XHRcdFx0ciA9IHYuY2hhckF0KDEpO1xuXHRcdFx0XHRcdFx0XHRnID0gdi5jaGFyQXQoMik7XG5cdFx0XHRcdFx0XHRcdGIgPSB2LmNoYXJBdCgzKTtcblx0XHRcdFx0XHRcdFx0diA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0diA9IHBhcnNlSW50KHYuc3Vic3RyKDEpLCAxNik7XG5cdFx0XHRcdFx0XHRhID0gW3YgPj4gMTYsICh2ID4+IDgpICYgMjU1LCB2ICYgMjU1XTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG5cdFx0XHRcdFx0XHRhID0gd2FzSFNMID0gdi5tYXRjaChfbnVtRXhwKTtcblx0XHRcdFx0XHRcdGlmICghdG9IU0wpIHtcblx0XHRcdFx0XHRcdFx0aCA9IChOdW1iZXIoYVswXSkgJSAzNjApIC8gMzYwO1xuXHRcdFx0XHRcdFx0XHRzID0gTnVtYmVyKGFbMV0pIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRsID0gTnVtYmVyKGFbMl0pIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRnID0gKGwgPD0gMC41KSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcblx0XHRcdFx0XHRcdFx0ciA9IGwgKiAyIC0gZztcblx0XHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdFx0XHRcdGFbM10gPSBOdW1iZXIodlszXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YVswXSA9IF9odWUoaCArIDEgLyAzLCByLCBnKTtcblx0XHRcdFx0XHRcdFx0YVsxXSA9IF9odWUoaCwgciwgZyk7XG5cdFx0XHRcdFx0XHRcdGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcIj1cIikgIT09IC0xKSB7IC8vaWYgcmVsYXRpdmUgdmFsdWVzIGFyZSBmb3VuZCwganVzdCByZXR1cm4gdGhlIHJhdyBzdHJpbmdzIHdpdGggdGhlIHJlbGF0aXZlIHByZWZpeGVzIGluIHBsYWNlLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdi5tYXRjaChfcmVsTnVtRXhwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YSA9IHYubWF0Y2goX251bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhWzBdID0gTnVtYmVyKGFbMF0pO1xuXHRcdFx0XHRcdGFbMV0gPSBOdW1iZXIoYVsxXSk7XG5cdFx0XHRcdFx0YVsyXSA9IE51bWJlcihhWzJdKTtcblx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPiAzKSB7XG5cdFx0XHRcdFx0XHRhWzNdID0gTnVtYmVyKGFbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuXHRcdFx0XHRcdHIgPSBhWzBdIC8gMjU1O1xuXHRcdFx0XHRcdGcgPSBhWzFdIC8gMjU1O1xuXHRcdFx0XHRcdGIgPSBhWzJdIC8gMjU1O1xuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRcdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDI7XG5cdFx0XHRcdFx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0XHRcdFx0XHRoID0gcyA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGQgPSBtYXggLSBtaW47XG5cdFx0XHRcdFx0XHRzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cdFx0XHRcdFx0XHRoID0gKG1heCA9PT0gcikgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IChtYXggPT09IGcpID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuXHRcdFx0XHRcdFx0aCAqPSA2MDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YVswXSA9IChoICsgMC41KSB8IDA7XG5cdFx0XHRcdFx0YVsxXSA9IChzICogMTAwICsgMC41KSB8IDA7XG5cdFx0XHRcdFx0YVsyXSA9IChsICogMTAwICsgMC41KSB8IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2Zvcm1hdENvbG9ycyA9IGZ1bmN0aW9uKHMsIHRvSFNMKSB7XG5cdFx0XHRcdHZhciBjb2xvcnMgPSBzLm1hdGNoKF9jb2xvckV4cCkgfHwgW10sXG5cdFx0XHRcdFx0Y2hhckluZGV4ID0gMCxcblx0XHRcdFx0XHRwYXJzZWQgPSBjb2xvcnMubGVuZ3RoID8gXCJcIiA6IHMsXG5cdFx0XHRcdFx0aSwgY29sb3IsIHRlbXA7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb2xvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpXTtcblx0XHRcdFx0XHR0ZW1wID0gcy5zdWJzdHIoY2hhckluZGV4LCBzLmluZGV4T2YoY29sb3IsIGNoYXJJbmRleCktY2hhckluZGV4KTtcblx0XHRcdFx0XHRjaGFySW5kZXggKz0gdGVtcC5sZW5ndGggKyBjb2xvci5sZW5ndGg7XG5cdFx0XHRcdFx0Y29sb3IgPSBfcGFyc2VDb2xvcihjb2xvciwgdG9IU0wpO1xuXHRcdFx0XHRcdGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdGNvbG9yLnB1c2goMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZCArPSB0ZW1wICsgKHRvSFNMID8gXCJoc2xhKFwiICsgY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IFwicmdiYShcIiArIGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQgKyBzLnN1YnN0cihjaGFySW5kZXgpO1xuXHRcdFx0fSxcblx0XHRcdF9jb2xvckV4cCA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszfSl7MSwyfVxcXFxiXCI7IC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy5cblxuXHRcdGZvciAocCBpbiBfY29sb3JMb29rdXApIHtcblx0XHRcdF9jb2xvckV4cCArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG5cdFx0fVxuXHRcdF9jb2xvckV4cCA9IG5ldyBSZWdFeHAoX2NvbG9yRXhwK1wiKVwiLCBcImdpXCIpO1xuXG5cdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24oYSkge1xuXHRcdFx0dmFyIGNvbWJpbmVkID0gYVswXSArIGFbMV0sXG5cdFx0XHRcdHRvSFNMO1xuXHRcdFx0aWYgKF9jb2xvckV4cC50ZXN0KGNvbWJpbmVkKSkge1xuXHRcdFx0XHR0b0hTTCA9IChjb21iaW5lZC5pbmRleE9mKFwiaHNsKFwiKSAhPT0gLTEgfHwgY29tYmluZWQuaW5kZXhPZihcImhzbGEoXCIpICE9PSAtMSk7XG5cdFx0XHRcdGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMKTtcblx0XHRcdFx0YVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuXHRcdFx0fVxuXHRcdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7XG5cdFx0fTtcblxuXHRcdGlmICghVHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIpIHtcblx0XHRcdFR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyID0gQ1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlIFJldHVybnMgYSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRha2luZyBhIHN0cmluZyAob3IgbnVtYmVyIGluIHNvbWUgY2FzZXMpIGFuZCByZXR1cm5pbmcgYSBjb25zaXN0ZW50bHkgZm9ybWF0dGVkIG9uZSBpbiB0ZXJtcyBvZiBkZWxpbWl0ZXJzLCBxdWFudGl0eSBvZiB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGUsIHdlIG1heSBnZXQgYm94U2hhZG93IHZhbHVlcyBkZWZpbmVkIGFzIFwiMHB4IHJlZFwiIG9yIFwiMHB4IDBweCAxMHB4IHJnYigyNTUsMCwwKVwiIG9yIFwiMHB4IDBweCAyMHB4IDIwcHggI0YwMFwiIGFuZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdoYXQgd2UgZ2V0IGJhY2sgaXMgZGVzY3JpYmVkIHdpdGggNCBudW1iZXJzIGFuZCBhIGNvbG9yLiBUaGlzIGFsbG93cyB1cyB0byBmZWVkIGl0IGludG8gdGhlIF9wYXJzZUNvbXBsZXgoKSBtZXRob2QgYW5kIHNwbGl0IHRoZSB2YWx1ZXMgdXAgYXBwcm9wcmlhdGVseS4gVGhlIG5lYXQgdGhpbmcgYWJvdXQgdGhpcyBfZ2V0Rm9ybWF0dGVyKCkgZnVuY3Rpb24gaXMgdGhhdCB0aGUgZGZsdCBkZWZpbmVzIGEgcGF0dGVybiBhcyB3ZWxsIGFzIGEgZGVmYXVsdCwgc28gZm9yIGV4YW1wbGUsIF9nZXRGb3JtYXR0ZXIoXCIwcHggMHB4IDBweCAwcHggIzc3N1wiLCB0cnVlKSBub3Qgb25seSBzZXRzIHRoZSBkZWZhdWx0IGFzIDBweCBmb3IgYWxsIGRpc3RhbmNlcyBhbmQgIzc3NyBmb3IgdGhlIGNvbG9yLCBidXQgYWxzbyBzZXRzIHRoZSBwYXR0ZXJuIHN1Y2ggdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gZGZsdCBUaGUgZGVmYXVsdCB2YWx1ZSBhbmQgcGF0dGVybiB0byBmb2xsb3cuIFNvIFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiB3aWxsIGVuc3VyZSB0aGF0IDQgbnVtYmVycyBhbmQgYSBjb2xvciB3aWxsIGFsd2F5cyBnZXQgcmV0dXJuZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY2xyIElmIHRydWUsIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHNlYXJjaGVkIGZvciBjb2xvci1yZWxhdGVkIGRhdGEuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgdmFsdWVzIHR5cGljYWxseSBjb250YWluIGEgY29sb3Igd2hlcmVhcyBib3JkZXJSYWRpdXMgZG9uJ3QuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gY29sbGFwc2libGUgSWYgdHJ1ZSwgdGhlIHZhbHVlIGlzIGEgdG9wL2xlZnQvcmlnaHQvYm90dG9tIHN0eWxlIG9uZSB0aGF0IGFjdHMgbGlrZSBtYXJnaW4gb3IgcGFkZGluZywgd2hlcmUgaWYgb25seSBvbmUgdmFsdWUgaXMgcmVjZWl2ZWQsIGl0J3MgdXNlZCBmb3IgYWxsIDQ7IGlmIDIgYXJlIHJlY2VpdmVkLCB0aGUgZmlyc3QgaXMgZHVwbGljYXRlZCBmb3IgM3JkIChib3R0b20pIGFuZCB0aGUgMm5kIGlzIGR1cGxpY2F0ZWQgZm9yIHRoZSA0dGggc3BvdCAobGVmdCksIGV0Yy5cblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0ICovXG5cdFx0dmFyIF9nZXRGb3JtYXR0ZXIgPSBmdW5jdGlvbihkZmx0LCBjbHIsIGNvbGxhcHNpYmxlLCBtdWx0aSkge1xuXHRcdFx0XHRpZiAoZGZsdCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHYpIHtyZXR1cm4gdjt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBkQ29sb3IgPSBjbHIgPyAoZGZsdC5tYXRjaChfY29sb3JFeHApIHx8IFtcIlwiXSlbMF0gOiBcIlwiLFxuXHRcdFx0XHRcdGRWYWxzID0gZGZsdC5zcGxpdChkQ29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW10sXG5cdFx0XHRcdFx0cGZ4ID0gZGZsdC5zdWJzdHIoMCwgZGZsdC5pbmRleE9mKGRWYWxzWzBdKSksXG5cdFx0XHRcdFx0c2Z4ID0gKGRmbHQuY2hhckF0KGRmbHQubGVuZ3RoIC0gMSkgPT09IFwiKVwiKSA/IFwiKVwiIDogXCJcIixcblx0XHRcdFx0XHRkZWxpbSA9IChkZmx0LmluZGV4T2YoXCIgXCIpICE9PSAtMSkgPyBcIiBcIiA6IFwiLFwiLFxuXHRcdFx0XHRcdG51bVZhbHMgPSBkVmFscy5sZW5ndGgsXG5cdFx0XHRcdFx0ZFNmeCA9IChudW1WYWxzID4gMCkgPyBkVmFsc1swXS5yZXBsYWNlKF9udW1FeHAsIFwiXCIpIDogXCJcIixcblx0XHRcdFx0XHRmb3JtYXR0ZXI7XG5cdFx0XHRcdGlmICghbnVtVmFscykge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xyKSB7XG5cdFx0XHRcdFx0Zm9ybWF0dGVyID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHRcdFx0dmFyIGNvbG9yLCB2YWxzLCBpLCBhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG11bHRpICYmIF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdCh2KSkge1xuXHRcdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0YVtpXSA9IGZvcm1hdHRlcihhW2ldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbG9yID0gKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbZENvbG9yXSlbMF07XG5cdFx0XHRcdFx0XHR2YWxzID0gdi5zcGxpdChjb2xvcikuam9pbihcIlwiKS5tYXRjaChfdmFsdWVzRXhwKSB8fCBbXTtcblx0XHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgrK2kgPCBudW1WYWxzKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIGRlbGltICsgY29sb3IgKyBzZnggKyAodi5pbmRleE9mKFwiaW5zZXRcIikgIT09IC0xID8gXCIgaW5zZXRcIiA6IFwiXCIpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHR2YXIgdmFscywgYSwgaTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHR2ICs9IGRTZng7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdGEgPSB2LnJlcGxhY2UoX2NvbW1hc091dHNpZGVQYXJlbkV4cCwgXCJ8XCIpLnNwbGl0KFwifFwiKTtcblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gYS5qb2luKFwiLFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFscyA9IHYubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0aSA9IHZhbHMubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChudW1WYWxzID4gaS0tKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHR2YWxzW2ldID0gY29sbGFwc2libGUgPyB2YWxzWygoKGkgLSAxKSAvIDIpIHwgMCldIDogZFZhbHNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwZnggKyB2YWxzLmpvaW4oZGVsaW0pICsgc2Z4O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gZm9ybWF0dGVyO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSByZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQncyB1c2VkIGZvciBlZGdlLXJlbGF0ZWQgdmFsdWVzIGxpa2UgbWFyZ2luVG9wLCBtYXJnaW5MZWZ0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nUmlnaHQsIGV0Yy4gSnVzdCBwYXNzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgcmVsYXRlZCB0byB0aGUgZWRnZXMuXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHByb3BzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgaW4gb3JkZXIgZnJvbSB0b3AgdG8gbGVmdCwgbGlrZSBcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiXG5cdFx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmb3JtYXR0ZXIgZnVuY3Rpb25cblx0XHRcdCAqL1xuXHRcdFx0X2dldEVkZ2VQYXJzZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0XHRwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdFx0XHR2YXIgYSA9IChlICsgXCJcIikuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRcdFx0aTtcblx0XHRcdFx0XHR2YXJzID0ge307XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyc1twcm9wc1tpXV0gPSBhW2ldID0gYVtpXSB8fCBhWygoKGkgLSAxKSAvIDIpID4+IDApXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBAcHJpdmF0ZSB1c2VkIHdoZW4gb3RoZXIgcGx1Z2lucyBtdXN0IHR3ZWVuIHZhbHVlcyBmaXJzdCwgbGlrZSBCZXppZXJQbHVnaW4gb3IgVGhyb3dQcm9wc1BsdWdpbiwgZXRjLiBUaGF0IHBsdWdpbidzIHNldFJhdGlvKCkgZ2V0cyBjYWxsZWQgZmlyc3Qgc28gdGhhdCB0aGUgdmFsdWVzIGFyZSB1cGRhdGVkLCBhbmQgdGhlbiB3ZSBsb29wIHRocm91Z2ggdGhlIE1pbmlQcm9wVHdlZW5zIHdoaWNoIGhhbmRsZSBjb3B5aW5nIHRoZSB2YWx1ZXMgaW50byB0aGVpciBhcHByb3ByaWF0ZSBzbG90cyBzbyB0aGF0IHRoZXkgY2FuIHRoZW4gYmUgYXBwbGllZCBjb3JyZWN0bHkgaW4gdGhlIG1haW4gQ1NTUGx1Z2luIHNldFJhdGlvKCkgbWV0aG9kLiBSZW1lbWJlciwgd2UgdHlwaWNhbGx5IGNyZWF0ZSBhIHByb3h5IG9iamVjdCB0aGF0IGhhcyBhIGJ1bmNoIG9mIHVuaXF1ZWx5LW5hbWVkIHByb3BlcnRpZXMgdGhhdCB3ZSBmZWVkIHRvIHRoZSBzdWItcGx1Z2luIGFuZCBpdCBkb2VzIGl0cyBtYWdpYyBub3JtYWxseSwgYW5kIHRoZW4gd2UgbXVzdCBpbnRlcnByZXQgdGhvc2UgdmFsdWVzIGFuZCBhcHBseSB0aGVtIHRvIHRoZSBjc3MgYmVjYXVzZSBvZnRlbiBudW1iZXJzIG11c3QgZ2V0IGNvbWJpbmVkL2NvbmNhdGVuYXRlZCwgc3VmZml4ZXMgYWRkZWQsIGV0Yy4gdG8gd29yayB3aXRoIGNzcywgbGlrZSBib3hTaGFkb3cgY291bGQgaGF2ZSA0IHZhbHVlcyBwbHVzIGEgY29sb3IuXG5cdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0UmF0aW8odik7XG5cdFx0XHRcdHZhciBkID0gdGhpcy5kYXRhLFxuXHRcdFx0XHRcdHByb3h5ID0gZC5wcm94eSxcblx0XHRcdFx0XHRtcHQgPSBkLmZpcnN0TVBULFxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdHZhbCwgcHQsIGksIHN0ciwgcDtcblx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdHZhbCA9IHByb3h5W21wdC52XTtcblx0XHRcdFx0XHRpZiAobXB0LnIpIHtcblx0XHRcdFx0XHRcdHZhbCA9IE1hdGgucm91bmQodmFsKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbiAmJiB2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtcHQudFttcHQucF0gPSB2YWw7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkLmF1dG9Sb3RhdGUpIHtcblx0XHRcdFx0XHRkLmF1dG9Sb3RhdGUucm90YXRpb24gPSBkLm1vZCA/IGQubW9kKHByb3h5LnJvdGF0aW9uLCB0aGlzLnQpIDogcHJveHkucm90YXRpb247IC8vc3BlY2lhbCBjYXNlIGZvciBNb2RpZnlQbHVnaW4gdG8gaG9vayBpbnRvIGFuIGF1dG8tcm90YXRpbmcgYmV6aWVyXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9hdCB0aGUgZW5kLCB3ZSBtdXN0IHNldCB0aGUgQ1NTUHJvcFR3ZWVuJ3MgXCJlXCIgKGVuZCkgdmFsdWUgZHluYW1pY2FsbHkgaGVyZSBiZWNhdXNlIHRoYXQncyB3aGF0IGlzIHVzZWQgaW4gdGhlIGZpbmFsIHNldFJhdGlvKCkgbWV0aG9kLiBTYW1lIGZvciBcImJcIiBhdCB0aGUgYmVnaW5uaW5nLlxuXHRcdFx0XHRpZiAodiA9PT0gMSB8fCB2ID09PSAwKSB7XG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVDtcblx0XHRcdFx0XHRwID0gKHYgPT09IDEpID8gXCJlXCIgOiBcImJcIjtcblx0XHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0XHRwdCA9IG1wdC50O1xuXHRcdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gcHQucyArIHB0LnhzMDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5zICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbcF0gPSBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIEBjb25zdHJ1Y3RvciBVc2VkIGJ5IGEgZmV3IFNwZWNpYWxQcm9wcyB0byBob2xkIGltcG9ydGFudCB2YWx1ZXMgZm9yIHByb3hpZXMuIEZvciBleGFtcGxlLCBfcGFyc2VUb1Byb3h5KCkgY3JlYXRlcyBhIE1pbmlQcm9wVHdlZW4gaW5zdGFuY2UgZm9yIGVhY2ggcHJvcGVydHkgdGhhdCBtdXN0IGdldCB0d2VlbmVkIG9uIHRoZSBwcm94eSwgYW5kIHdlIHJlY29yZCB0aGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZSBhcyB3ZWxsIGFzIHRoZSB1bmlxdWUgb25lIHdlIGNyZWF0ZSBmb3IgdGhlIHByb3h5LCBwbHVzIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBuZWVkcyB0byBiZSByb3VuZGVkIHBsdXMgdGhlIG9yaWdpbmFsIHZhbHVlLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgd2UncmUgdHdlZW5pbmcgKG9mdGVuIGEgQ1NTUHJvcFR3ZWVuKVxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIHByb3BlcnR5IG5hbWVcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmd8b2JqZWN0KX0gdiB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtNaW5pUHJvcFR3ZWVuPX0gbmV4dCBuZXh0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIGlmIHRydWUsIHRoZSB0d2VlbmVkIHZhbHVlIHNob3VsZCBiZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcblx0XHRcdCAqL1xuXHRcdFx0TWluaVByb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHYsIG5leHQsIHIpIHtcblx0XHRcdFx0dGhpcy50ID0gdDtcblx0XHRcdFx0dGhpcy5wID0gcDtcblx0XHRcdFx0dGhpcy52ID0gdjtcblx0XHRcdFx0dGhpcy5yID0gcjtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBNb3N0IG90aGVyIHBsdWdpbnMgKGxpa2UgQmV6aWVyUGx1Z2luIGFuZCBUaHJvd1Byb3BzUGx1Z2luIGFuZCBvdGhlcnMpIGNhbiBvbmx5IHR3ZWVuIG51bWVyaWMgdmFsdWVzLCBidXQgQ1NTUGx1Z2luIG11c3QgYWNjb21tb2RhdGUgc3BlY2lhbCB2YWx1ZXMgdGhhdCBoYXZlIGEgYnVuY2ggb2YgZXh0cmEgZGF0YSAobGlrZSBhIHN1ZmZpeCBvciBzdHJpbmdzIGJldHdlZW4gbnVtZXJpYyB2YWx1ZXMsIGV0Yy4pLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IGhhcyB2YWx1ZXMgbGlrZSBcIjEwcHggMTBweCAyMHB4IDMwcHggcmdiKDI1NSwwLDApXCIgd2hpY2ggd291bGQgdXR0ZXJseSBjb25mdXNlIG90aGVyIHBsdWdpbnMuIFRoaXMgbWV0aG9kIGFsbG93cyB1cyB0byBzcGxpdCB0aGF0IGRhdGEgYXBhcnQgYW5kIGdyYWIgb25seSB0aGUgbnVtZXJpYyBkYXRhIGFuZCBhdHRhY2ggaXQgdG8gdW5pcXVlbHktbmFtZWQgcHJvcGVydGllcyBvZiBhIGdlbmVyaWMgcHJveHkgb2JqZWN0ICh7fSkgc28gdGhhdCB3ZSBjYW4gZmVlZCB0aGF0IHRvIHZpcnR1YWxseSBhbnkgcGx1Z2luIHRvIGhhdmUgdGhlIG51bWJlcnMgdHdlZW5lZC4gSG93ZXZlciwgd2UgbXVzdCBhbHNvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcHJvcGVydGllcyBmcm9tIHRoZSBwcm94eSBnbyB3aXRoIHdoaWNoIENTU1Byb3BUd2VlbiB2YWx1ZXMgYW5kIGluc3RhbmNlcy4gU28gd2UgY3JlYXRlIGEgbGlua2VkIGxpc3Qgb2YgTWluaVByb3BUd2VlbnMuIEVhY2ggb25lIHJlY29yZHMgYSB0YXJnZXQgKHRoZSBvcmlnaW5hbCBDU1NQcm9wVHdlZW4pLCBwcm9wZXJ0eSAobGlrZSBcInNcIiBvciBcInhuMVwiIG9yIFwieG4yXCIpIHRoYXQgd2UncmUgdHdlZW5pbmcgYW5kIHRoZSB1bmlxdWUgcHJvcGVydHkgbmFtZSB0aGF0IHdhcyB1c2VkIGZvciB0aGUgcHJveHkgKGxpa2UgXCJib3hTaGFkb3dfeG4xXCIgYW5kIFwiYm94U2hhZG93X3huMlwiKSBhbmQgd2hldGhlciBvciBub3QgdGhleSBuZWVkIHRvIGJlIHJvdW5kZWQuIFRoYXQgd2F5LCBpbiB0aGUgX3NldFBsdWdpblJhdGlvKCkgbWV0aG9kIHdlIGNhbiBzaW1wbHkgY29weSB0aGUgdmFsdWVzIG92ZXIgZnJvbSB0aGUgcHJveHkgdG8gdGhlIENTU1Byb3BUd2VlbiBpbnN0YW5jZShzKS4gVGhlbiwgd2hlbiB0aGUgbWFpbiBDU1NQbHVnaW4gc2V0UmF0aW8oKSBtZXRob2QgcnVucyBhbmQgYXBwbGllcyB0aGUgQ1NTUHJvcFR3ZWVuIHZhbHVlcyBhY2NvcmRpbmdseSwgdGhleSdyZSB1cGRhdGVkIG5pY2VseS4gU28gdGhlIGV4dGVybmFsIHBsdWdpbiB0d2VlbnMgdGhlIG51bWJlcnMsIF9zZXRQbHVnaW5SYXRpbygpIGNvcGllcyB0aGVtIG92ZXIsIGFuZCBzZXRSYXRpbygpIGFjdHMgbm9ybWFsbHksIGFwcGx5aW5nIGNzcy1zcGVjaWZpYyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQuXG5cdFx0XHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0XHQgKiAgLSBwcm94eTogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFydGluZyB2YWx1ZXMgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdHdlZW5lZCBieSB0aGUgZXh0ZXJuYWwgcGx1Z2luLiAgVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIF9vbkluaXRUd2VlbigpIGFzIHRoZSB0YXJnZXRcblx0XHRcdCAqICAtIGVuZDogYSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHRoZSBlbmRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gVGhpcyBpcyB3aGF0IHdlIGZlZWQgdG8gdGhlIGV4dGVybmFsIHBsdWdpbidzIF9vbkluaXRUd2VlbigpIGFzIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXNcblx0XHRcdCAqICAtIGZpcnN0TVBUOiB0aGUgZmlyc3QgTWluaVByb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqICAtIHB0OiB0aGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB0aGF0IHdhcyBjcmVhdGVkIHdoZW4gcGFyc2luZy4gSWYgc2hhbGxvdyBpcyB0cnVlLCB0aGlzIGxpbmtlZCBsaXN0IHdpbGwgTk9UIGF0dGFjaCB0byB0aGUgb25lIHBhc3NlZCBpbnRvIHRoZSBfcGFyc2VUb1Byb3h5KCkgYXMgdGhlIFwicHRcIiAoNHRoKSBwYXJhbWV0ZXIuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0XHQgKiBAcGFyYW0geyEoT2JqZWN0fHN0cmluZyl9IHZhcnMgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdHdlZW5pbmcgdmFsdWVzICh0eXBpY2FsbHkgdGhlIGVuZC9kZXN0aW5hdGlvbiB2YWx1ZXMpIHRoYXQgc2hvdWxkIGJlIHBhcnNlZFxuXHRcdFx0ICogQHBhcmFtIHshQ1NTUGx1Z2lufSBjc3NwIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gcHQgdGhlIG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiB0aGUgZXh0ZXJuYWwgVHdlZW5QbHVnaW4gaW5zdGFuY2UgdGhhdCB3aWxsIGJlIGhhbmRsaW5nIHR3ZWVuaW5nIHRoZSBudW1lcmljIHZhbHVlc1xuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gc2hhbGxvdyBpZiB0cnVlLCB0aGUgcmVzdWx0aW5nIGxpbmtlZCBsaXN0IGZyb20gdGhlIHBhcnNlIHdpbGwgTk9UIGJlIGF0dGFjaGVkIHRvIHRoZSBDU1NQcm9wVHdlZW4gdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IHByb3h5LCBlbmQsIGZpcnN0TVBULCBhbmQgcHQgKHNlZSBhYm92ZSBmb3IgZGVzY3JpcHRpb25zKVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5ID0gZnVuY3Rpb24odCwgdmFycywgY3NzcCwgcHQsIHBsdWdpbiwgc2hhbGxvdykge1xuXHRcdFx0XHR2YXIgYnB0ID0gcHQsXG5cdFx0XHRcdFx0c3RhcnQgPSB7fSxcblx0XHRcdFx0XHRlbmQgPSB7fSxcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBjc3NwLl90cmFuc2Zvcm0sXG5cdFx0XHRcdFx0b2xkRm9yY2UgPSBfZm9yY2VQVCxcblx0XHRcdFx0XHRpLCBwLCB4cCwgbXB0LCBmaXJzdFBUO1xuXHRcdFx0XHRjc3NwLl90cmFuc2Zvcm0gPSBudWxsO1xuXHRcdFx0XHRfZm9yY2VQVCA9IHZhcnM7XG5cdFx0XHRcdHB0ID0gZmlyc3RQVCA9IGNzc3AucGFyc2UodCwgdmFycywgcHQsIHBsdWdpbik7XG5cdFx0XHRcdF9mb3JjZVBUID0gb2xkRm9yY2U7XG5cdFx0XHRcdC8vYnJlYWsgb2ZmIGZyb20gdGhlIGxpbmtlZCBsaXN0IHNvIHRoZSBuZXcgb25lcyBhcmUgaXNvbGF0ZWQuXG5cdFx0XHRcdGlmIChzaGFsbG93KSB7XG5cdFx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRcdGlmIChicHQpIHtcblx0XHRcdFx0XHRcdGJwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoYnB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdGJwdC5fcHJldi5fbmV4dCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChwdCAmJiBwdCAhPT0gYnB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgPD0gMSkge1xuXHRcdFx0XHRcdFx0cCA9IHB0LnA7XG5cdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdHN0YXJ0W3BdID0gcHQucztcblx0XHRcdFx0XHRcdGlmICghc2hhbGxvdykge1xuXHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgXCJzXCIsIHAsIG1wdCwgcHQucik7XG5cdFx0XHRcdFx0XHRcdHB0LmMgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0eHAgPSBcInhuXCIgKyBpO1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBwdC5wICsgXCJfXCIgKyB4cDtcblx0XHRcdFx0XHRcdFx0XHRlbmRbcF0gPSBwdC5kYXRhW3hwXTtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0W3hwXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1wdCA9IG5ldyBNaW5pUHJvcFR3ZWVuKHB0LCB4cCwgcCwgbXB0LCBwdC5yeHBbeHBdKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge3Byb3h5OnN0YXJ0LCBlbmQ6ZW5kLCBmaXJzdE1QVDptcHQsIHB0OmZpcnN0UFR9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yIEVhY2ggcHJvcGVydHkgdGhhdCBpcyB0d2VlbmVkIGhhcyBhdCBsZWFzdCBvbmUgQ1NTUHJvcFR3ZWVuIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlc2UgaW5zdGFuY2VzIHN0b3JlIGltcG9ydGFudCBpbmZvcm1hdGlvbiBsaWtlIHRoZSB0YXJnZXQsIHByb3BlcnR5LCBzdGFydGluZyB2YWx1ZSwgYW1vdW50IG9mIGNoYW5nZSwgZXRjLiBUaGV5IGNhbiBhbHNvIG9wdGlvbmFsbHkgaGF2ZSBhIG51bWJlciBvZiBcImV4dHJhXCIgc3RyaW5ncyBhbmQgbnVtZXJpYyB2YWx1ZXMgbmFtZWQgeHMxLCB4bjEsIHhzMiwgeG4yLCB4czMsIHhuMywgZXRjLiB3aGVyZSBcInNcIiBpbmRpY2F0ZXMgc3RyaW5nIGFuZCBcIm5cIiBpbmRpY2F0ZXMgbnVtYmVyLiBUaGVzZSBjYW4gYmUgcGllY2VkIHRvZ2V0aGVyIGluIGEgY29tcGxleC12YWx1ZSB0d2VlbiAodHlwZToxKSB0aGF0IGhhcyBhbHRlcm5hdGluZyB0eXBlcyBvZiBkYXRhIGxpa2UgYSBzdHJpbmcsIG51bWJlciwgc3RyaW5nLCBudW1iZXIsIGV0Yy4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBjb3VsZCBiZSBcIjVweCA1cHggOHB4IHJnYigxMDIsIDEwMiwgNTEpXCIuIEluIHRoYXQgdmFsdWUsIHRoZXJlIGFyZSA2IG51bWJlcnMgdGhhdCBtYXkgbmVlZCB0byB0d2VlbiBhbmQgdGhlbiBwaWVjZWQgYmFjayB0b2dldGhlciBpbnRvIGEgc3RyaW5nIGFnYWluIHdpdGggc3BhY2VzLCBzdWZmaXhlcywgZXRjLiB4czAgaXMgc3BlY2lhbCBpbiB0aGF0IGl0IHN0b3JlcyB0aGUgc3VmZml4IGZvciBzdGFuZGFyZCAodHlwZTowKSB0d2VlbnMsIC1PUi0gdGhlIGZpcnN0IHN0cmluZyAocHJlZml4KSBpbiBhIGNvbXBsZXgtdmFsdWUgKHR5cGU6MSkgQ1NTUHJvcFR3ZWVuIC1PUi0gaXQgY2FuIGJlIHRoZSBub24tdHdlZW5pbmcgdmFsdWUgaW4gYSB0eXBlOi0xIENTU1Byb3BUd2Vlbi4gV2UgZG8gdGhpcyB0byBjb25zZXJ2ZSBtZW1vcnkuXG5cdFx0XHQgKiBDU1NQcm9wVHdlZW5zIGhhdmUgdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIGFzIHdlbGwgKG5vdCBkZWZpbmVkIHRocm91Z2ggdGhlIGNvbnN0cnVjdG9yKTpcblx0XHRcdCAqICAtIGw6IExlbmd0aCBpbiB0ZXJtcyBvZiB0aGUgbnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgdGhhdCB0aGUgQ1NTUHJvcFR3ZWVuIGhhcyAoZGVmYXVsdDogMCkuIEZvciBleGFtcGxlLCBmb3IgYSBib3hTaGFkb3cgd2UgbWF5IG5lZWQgdG8gdHdlZW4gNSBudW1iZXJzIGluIHdoaWNoIGNhc2UgbCB3b3VsZCBiZSA1OyBLZWVwIGluIG1pbmQgdGhhdCB0aGUgc3RhcnQvZW5kIHZhbHVlcyBmb3IgdGhlIGZpcnN0IG51bWJlciB0aGF0J3MgdHdlZW5lZCBhcmUgYWx3YXlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBwcm9wZXJ0aWVzIHRvIGNvbnNlcnZlIG1lbW9yeS4gQWxsIGFkZGl0aW9uYWwgdmFsdWVzIHRoZXJlYWZ0ZXIgYXJlIHN0b3JlZCBpbiB4bjEsIHhuMiwgZXRjLlxuXHRcdFx0ICogIC0geGZpcnN0OiBUaGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IHN1Yi1DU1NQcm9wVHdlZW5zIHRoYXQgYXJlIHR3ZWVuaW5nIHByb3BlcnRpZXMgb2YgdGhpcyBpbnN0YW5jZS4gRm9yIGV4YW1wbGUsIHdlIG1heSBzcGxpdCB1cCBhIGJveFNoYWRvdyB0d2VlbiBzbyB0aGF0IHRoZXJlJ3MgYSBtYWluIENTU1Byb3BUd2VlbiBvZiB0eXBlOjEgdGhhdCBoYXMgdmFyaW91cyB4cyogYW5kIHhuKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBoLXNoYWRvdywgdi1zaGFkb3csIGJsdXIsIGNvbG9yLCBldGMuIFRoZW4gd2Ugc3Bhd24gYSBDU1NQcm9wVHdlZW4gZm9yIGVhY2ggb2YgdGhvc2UgdGhhdCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgYW5kIHJ1bnMgQkVGT1JFIHRoZSBtYWluIENTU1Byb3BUd2VlbiBzbyB0aGF0IHRoZSB2YWx1ZXMgYXJlIGFsbCBzZXQgYnkgdGhlIHRpbWUgaXQgbmVlZHMgdG8gcmUtYXNzZW1ibGUgdGhlbS4gVGhlIHhmaXJzdCBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byBpZGVudGlmeSB0aGUgZmlyc3Qgb25lIGluIHRoYXQgY2hhaW4gd2hpY2ggdHlwaWNhbGx5IGVuZHMgYXQgdGhlIG1haW4gb25lIChiZWNhdXNlIHRoZXkncmUgYWxsIHByZXBlbmRlIHRvIHRoZSBsaW5rZWQgbGlzdClcblx0XHRcdCAqICAtIHBsdWdpbjogVGhlIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGFueSBjb21wbGV4IHZhbHVlcy4gRm9yIGV4YW1wbGUsIHNvbWV0aW1lcyB3ZSBkb24ndCB3YW50IHRvIHVzZSBub3JtYWwgc3VidHdlZW5zIChsaWtlIHhmaXJzdCByZWZlcnMgdG8pIHRvIHR3ZWVuIHRoZSB2YWx1ZXMgLSB3ZSBtaWdodCB3YW50IFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luIHNvbWUgb3RoZXIgcGx1Z2luIHRvIGRvIHRoZSBhY3R1YWwgdHdlZW5pbmcsIHNvIHdlIGNyZWF0ZSBhIHBsdWdpbiBpbnN0YW5jZSBhbmQgc3RvcmUgYSByZWZlcmVuY2UgaGVyZS4gV2UgbmVlZCB0aGlzIHJlZmVyZW5jZSBzbyB0aGF0IGlmIHdlIGdldCBhIHJlcXVlc3QgdG8gcm91bmQgdmFsdWVzIG9yIGRpc2FibGUgYSB0d2Vlbiwgd2UgY2FuIHBhc3MgYWxvbmcgdGhhdCByZXF1ZXN0LlxuXHRcdFx0ICogIC0gZGF0YTogQXJiaXRyYXJ5IGRhdGEgdGhhdCBuZWVkcyB0byBiZSBzdG9yZWQgd2l0aCB0aGUgQ1NTUHJvcFR3ZWVuLiBUeXBpY2FsbHkgaWYgd2UncmUgZ29pbmcgdG8gaGF2ZSBhIHBsdWdpbiBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGEgY29tcGxleC12YWx1ZSB0d2Vlbiwgd2UgY3JlYXRlIGEgZ2VuZXJpYyBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIEVORCB2YWx1ZXMgdGhhdCB3ZSdyZSB0d2VlbmluZyB0byBhbmQgdGhlIENTU1Byb3BUd2VlbidzIHhzMSwgeHMyLCBldGMuIGhhdmUgdGhlIHN0YXJ0aW5nIHZhbHVlcy4gV2Ugc3RvcmUgdGhhdCBvYmplY3QgYXMgZGF0YS4gVGhhdCB3YXksIHdlIGNhbiBzaW1wbHkgcGFzcyB0aGF0IG9iamVjdCB0byB0aGUgcGx1Z2luIGFuZCB1c2UgdGhlIENTU1Byb3BUd2VlbiBhcyB0aGUgdGFyZ2V0LlxuXHRcdFx0ICogIC0gc2V0UmF0aW86IE9ubHkgdXNlZCBmb3IgdHlwZToyIHR3ZWVucyB0aGF0IHJlcXVpcmUgY3VzdG9tIGZ1bmN0aW9uYWxpdHkuIEluIHRoaXMgY2FzZSwgd2UgY2FsbCB0aGUgQ1NTUHJvcFR3ZWVuJ3Mgc2V0UmF0aW8oKSBtZXRob2QgYW5kIHBhc3MgdGhlIHJhdGlvIGVhY2ggdGltZSB0aGUgdHdlZW4gdXBkYXRlcy4gVGhpcyBpc24ndCBxdWl0ZSBhcyBlZmZpY2llbnQgYXMgZG9pbmcgdGhpbmdzIGRpcmVjdGx5IGluIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIG1ldGhvZCwgYnV0IGl0J3MgdmVyeSBjb252ZW5pZW50IGFuZCBmbGV4aWJsZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdpbGwgYmUgdHdlZW5lZC4gT2Z0ZW4gYSBET00gZWxlbWVudCwgYnV0IG5vdCBhbHdheXMuIEl0IGNvdWxkIGJlIGFueXRoaW5nLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IHAgUHJvcGVydHkgdG8gdHdlZW4gKG5hbWUpLiBGb3IgZXhhbXBsZSwgdG8gdHdlZW4gZWxlbWVudC53aWR0aCwgcCB3b3VsZCBiZSBcIndpZHRoXCIuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gcyBTdGFydGluZyBudW1lcmljIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcn0gYyBDaGFuZ2UgaW4gbnVtZXJpYyB2YWx1ZSBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIGVudGlyZSB0d2Vlbi4gRm9yIGV4YW1wbGUsIGlmIGVsZW1lbnQud2lkdGggc3RhcnRzIGF0IDUgYW5kIHNob3VsZCBlbmQgYXQgMTAwLCBjIHdvdWxkIGJlIDk1LlxuXHRcdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBuZXh0IFRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QuIElmIG9uZSBpcyBkZWZpbmVkLCB3ZSB3aWxsIGRlZmluZSBpdHMgX3ByZXYgYXMgdGhlIG5ldyBpbnN0YW5jZSwgYW5kIHRoZSBuZXcgaW5zdGFuY2UncyBfbmV4dCB3aWxsIGJlIHBvaW50ZWQgYXQgaXQuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHR5cGUgVGhlIHR5cGUgb2YgQ1NTUHJvcFR3ZWVuIHdoZXJlIC0xID0gYSBub24tdHdlZW5pbmcgdmFsdWUsIDAgPSBhIHN0YW5kYXJkIHNpbXBsZSB0d2VlbiwgMSA9IGEgY29tcGxleCB2YWx1ZSAobGlrZSBvbmUgdGhhdCBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbiBhIGNvbW1hLSBvciBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIGxpa2UgYm9yZGVyOlwiMXB4IHNvbGlkIHJlZFwiKSwgYW5kIDIgPSBvbmUgdGhhdCB1c2VzIGEgY3VzdG9tIHNldFJhdGlvIGZ1bmN0aW9uIHRoYXQgZG9lcyBhbGwgb2YgdGhlIHdvcmsgb2YgYXBwbHlpbmcgdGhlIHZhbHVlcyBvbiBlYWNoIHVwZGF0ZS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gbiBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBvdmVyd3JpdGluZyBwdXJwb3NlcyB3aGljaCBpcyB0eXBpY2FsbHkgdGhlIHNhbWUgYXMgcCBidXQgbm90IGFsd2F5cy4gRm9yIGV4YW1wbGUsIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIHN1YnR3ZWVuIGZvciB0aGUgMm5kIHBhcnQgb2YgYSBcImNsaXA6cmVjdCguLi4pXCIgdHdlZW4gaW4gd2hpY2ggY2FzZSBcInBcIiBtaWdodCBiZSB4czEgYnV0IFwiblwiIGlzIHN0aWxsIFwiY2xpcFwiXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByIElmIHRydWUsIHRoZSB2YWx1ZShzKSBzaG91bGQgYmUgcm91bmRlZFxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSBwciBQcmlvcml0eSBpbiB0aGUgbGlua2VkIGxpc3Qgb3JkZXIuIEhpZ2hlciBwcmlvcml0eSBDU1NQcm9wVHdlZW5zIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gYiBCZWdpbm5pbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IGl0IHdhcyB3aGVuIHRoZSB0d2VlbiBiZWdhbiB3aXRob3V0IGFueSByaXNrIG9mIGludGVycHJldGF0aW9uIGlzc3Vlcy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gZSBFbmRpbmcgdmFsdWUuIFdlIHN0b3JlIHRoaXMgdG8gZW5zdXJlIHRoYXQgaXQgaXMgRVhBQ1RMWSB3aGF0IHRoZSB1c2VyIGRlZmluZWQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKi9cblx0XHRcdENTU1Byb3BUd2VlbiA9IF9pbnRlcm5hbHMuQ1NTUHJvcFR3ZWVuID0gZnVuY3Rpb24odCwgcCwgcywgYywgbmV4dCwgdHlwZSwgbiwgciwgcHIsIGIsIGUpIHtcblx0XHRcdFx0dGhpcy50ID0gdDsgLy90YXJnZXRcblx0XHRcdFx0dGhpcy5wID0gcDsgLy9wcm9wZXJ0eVxuXHRcdFx0XHR0aGlzLnMgPSBzOyAvL3N0YXJ0aW5nIHZhbHVlXG5cdFx0XHRcdHRoaXMuYyA9IGM7IC8vY2hhbmdlIHZhbHVlXG5cdFx0XHRcdHRoaXMubiA9IG4gfHwgcDsgLy9uYW1lIHRoYXQgdGhpcyBDU1NQcm9wVHdlZW4gc2hvdWxkIGJlIGFzc29jaWF0ZWQgdG8gKHVzdWFsbHkgdGhlIHNhbWUgYXMgcCwgYnV0IG5vdCBhbHdheXMgLSBuIGlzIHdoYXQgb3ZlcndyaXRpbmcgbG9va3MgYXQpXG5cdFx0XHRcdGlmICghKHQgaW5zdGFuY2VvZiBDU1NQcm9wVHdlZW4pKSB7XG5cdFx0XHRcdFx0X292ZXJ3cml0ZVByb3BzLnB1c2godGhpcy5uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnIgPSByOyAvL3JvdW5kIChib29sZWFuKVxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlIHx8IDA7IC8vMCA9IG5vcm1hbCB0d2VlbiwgLTEgPSBub24tdHdlZW5pbmcgKGluIHdoaWNoIGNhc2UgeHMwIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdGFyZ2V0J3MgcHJvcGVydHksIGxpa2UgdHAudFt0cC5wXSA9IHRwLnhzMCksIDEgPSBjb21wbGV4LXZhbHVlIFNwZWNpYWxQcm9wLCAyID0gY3VzdG9tIHNldFJhdGlvKCkgdGhhdCBkb2VzIGFsbCB0aGUgd29ya1xuXHRcdFx0XHRpZiAocHIpIHtcblx0XHRcdFx0XHR0aGlzLnByID0gcHI7XG5cdFx0XHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmIgPSAoYiA9PT0gdW5kZWZpbmVkKSA/IHMgOiBiO1xuXHRcdFx0XHR0aGlzLmUgPSAoZSA9PT0gdW5kZWZpbmVkKSA/IHMgKyBjIDogZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0X2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBuZXh0LCBvdmVyd3JpdGVQcm9wKSB7IC8vY2xlYW5zIHVwIHNvbWUgY29kZSByZWR1bmRhbmNpZXMgYW5kIGhlbHBzIG1pbmlmaWNhdGlvbi4gSnVzdCBhIGZhc3Qgd2F5IHRvIGFkZCBhIE5VTUVSSUMgbm9uLXR3ZWVuaW5nIENTU1Byb3BUd2VlblxuXHRcdFx0XHR2YXIgcHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCAtIHN0YXJ0LCBuZXh0LCAtMSwgb3ZlcndyaXRlUHJvcCk7XG5cdFx0XHRcdHB0LmIgPSBzdGFydDtcblx0XHRcdFx0cHQuZSA9IHB0LnhzMCA9IGVuZDtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUYWtlcyBhIHRhcmdldCwgdGhlIGJlZ2lubmluZyB2YWx1ZSBhbmQgZW5kaW5nIHZhbHVlIChhcyBzdHJpbmdzKSBhbmQgcGFyc2VzIHRoZW0gaW50byBhIENTU1Byb3BUd2VlbiAocG9zc2libHkgd2l0aCBjaGlsZCBDU1NQcm9wVHdlZW5zKSB0aGF0IGFjY29tbW9kYXRlcyBtdWx0aXBsZSBudW1iZXJzLCBjb2xvcnMsIGNvbW1hLWRlbGltaXRlZCB2YWx1ZXMsIGV0Yy4gRm9yIGV4YW1wbGU6XG5cdFx0XHQgKiBzcC5wYXJzZUNvbXBsZXgoZWxlbWVudCwgXCJib3hTaGFkb3dcIiwgXCI1cHggMTBweCAyMHB4IHJnYigyNTUsMTAyLDUxKVwiLCBcIjBweCAwcHggMHB4IHJlZFwiLCB0cnVlLCBcIjBweCAwcHggMHB4IHJnYigwLDAsMCwwKVwiLCBwdCk7XG5cdFx0XHQgKiBJdCB3aWxsIHdhbGsgdGhyb3VnaCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZm9ybWF0IHdpdGggdGhlIHNhbWUgbnVtYmVyIGFuZCB0eXBlIG9mIHZhbHVlcykgYW5kIGZpZ3VyZSBvdXQgd2hpY2ggcGFydHMgYXJlIG51bWJlcnMsIHdoYXQgc3RyaW5ncyBzZXBhcmF0ZSB0aGUgbnVtZXJpYy90d2VlbmFibGUgdmFsdWVzLCBhbmQgdGhlbiBjcmVhdGUgdGhlIENTU1Byb3BUd2VlbnMgYWNjb3JkaW5nbHkuIElmIGEgcGx1Z2luIGlzIGRlZmluZWQsIG5vIGNoaWxkIENTU1Byb3BUd2VlbnMgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGUgZW5kaW5nIHZhbHVlcyB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgXCJkYXRhXCIgcHJvcGVydHkgb2YgdGhlIHJldHVybmVkIENTU1Byb3BUd2VlbiBsaWtlOiB7czotNSwgeG4xOi0xMCwgeG4yOi0yMCwgeG4zOjI1NSwgeG40OjAsIHhuNTowfSBzbyB0aGF0IGl0IGNhbiBiZSBmZWQgdG8gYW55IG90aGVyIHBsdWdpbiBhbmQgaXQnbGwgYmUgcGxhaW4gbnVtZXJpYyB0d2VlbnMgYnV0IHRoZSByZWNvbXBvc2l0aW9uIG9mIHRoZSBjb21wbGV4IHZhbHVlIHdpbGwgYmUgaGFuZGxlZCBpbnNpZGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKS5cblx0XHRcdCAqIElmIGEgc2V0UmF0aW8gaXMgZGVmaW5lZCwgdGhlIHR5cGUgb2YgdGhlIENTU1Byb3BUd2VlbiB3aWxsIGJlIHNldCB0byAyIGFuZCByZWNvbXBvc2l0aW9uIG9mIHRoZSB2YWx1ZXMgd2lsbCBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhhdCBtZXRob2QuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWRcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSB0aGF0IHdpbGwgYmUgdHdlZW5lZCAoaXRzIG5hbWUsIGxpa2UgXCJsZWZ0XCIgb3IgXCJiYWNrZ3JvdW5kQ29sb3JcIiBvciBcImJveFNoYWRvd1wiKVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGIgQmVnaW5uaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZSBFbmRpbmcgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xycyBJZiB0cnVlLCB0aGUgdmFsdWUgY291bGQgY29udGFpbiBhIGNvbG9yIHZhbHVlIGxpa2UgXCJyZ2IoMjU1LDAsMClcIiBvciBcIiNGMDBcIiBvciBcInJlZFwiLiBUaGUgZGVmYXVsdCBpcyBmYWxzZSwgc28gbm8gY29sb3JzIHdpbGwgYmUgcmVjb2duaXplZCAoYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cdFx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfE9iamVjdCl9IGRmbHQgVGhlIGRlZmF1bHQgYmVnaW5uaW5nIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgaWYgbm8gdmFsaWQgYmVnaW5uaW5nIHZhbHVlIGlzIGRlZmluZWQgb3IgaWYgdGhlIG51bWJlciBvZiB2YWx1ZXMgaW5zaWRlIHRoZSBjb21wbGV4IGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBkb24ndCBtYXRjaFxuXHRcdFx0ICogQHBhcmFtIHs/Q1NTUHJvcFR3ZWVufSBwdCBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byB0aGlzKS5cblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHNob3VsZCBoYW5kbGUgdGhlIHR3ZWVuaW5nIG9mIGV4dHJhIHByb3BlcnRpZXMsIHBhc3MgdGhlIHBsdWdpbiBpbnN0YW5jZSBoZXJlLiBJZiBvbmUgaXMgZGVmaW5lZCwgdGhlbiBOTyBzdWJ0d2VlbnMgd2lsbCBiZSBjcmVhdGVkIGZvciBhbnkgZXh0cmEgcHJvcGVydGllcyAodGhlIHByb3BlcnRpZXMgd2lsbCBiZSBjcmVhdGVkIC0ganVzdCBub3QgYWRkaXRpb25hbCBDU1NQcm9wVHdlZW4gaW5zdGFuY2VzIHRvIHR3ZWVuIHRoZW0pIGJlY2F1c2UgdGhlIHBsdWdpbiBpcyBleHBlY3RlZCB0byBkbyBzby4gSG93ZXZlciwgdGhlIGVuZCB2YWx1ZXMgV0lMTCBiZSBwb3B1bGF0ZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5LCBsaWtlIHtzOjEwMCwgeG4xOjUwLCB4bjI6MzAwfVxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpPX0gc2V0UmF0aW8gSWYgdmFsdWVzIHNob3VsZCBiZSBzZXQgaW4gYSBjdXN0b20gZnVuY3Rpb24gaW5zdGVhZCBvZiBiZWluZyBwaWVjZWQgdG9nZXRoZXIgaW4gYSB0eXBlOjEgKGNvbXBsZXgtdmFsdWUpIENTU1Byb3BUd2VlbiwgZGVmaW5lIHRoYXQgY3VzdG9tIGZ1bmN0aW9uIGhlcmUuXG5cdFx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZUNvbXBsZXgoKSBjYWxsLlxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VDb21wbGV4ID0gQ1NTUGx1Z2luLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIHAsIGIsIGUsIGNscnMsIGRmbHQsIHB0LCBwciwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwicGFyc2VDb21wbGV4OiBcIitwK1wiLCBiOiBcIitiK1wiLCBlOiBcIitlKTtcblx0XHRcdFx0YiA9IGIgfHwgZGZsdCB8fCBcIlwiO1xuXHRcdFx0XHRpZiAodHlwZW9mKGUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlID0gZShfaW5kZXgsIF90YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgKHNldFJhdGlvID8gMiA6IDEpLCBudWxsLCBmYWxzZSwgcHIsIGIsIGUpO1xuXHRcdFx0XHRlICs9IFwiXCI7IC8vZW5zdXJlcyBpdCdzIGEgc3RyaW5nXG5cdFx0XHRcdGlmIChjbHJzICYmIF9jb2xvckV4cC50ZXN0KGUgKyBiKSkgeyAvL2lmIGNvbG9ycyBhcmUgZm91bmQsIG5vcm1hbGl6ZSB0aGUgZm9ybWF0dGluZyB0byByZ2JhKCkgb3IgaHNsYSgpLlxuXHRcdFx0XHRcdGUgPSBbYiwgZV07XG5cdFx0XHRcdFx0Q1NTUGx1Z2luLmNvbG9yU3RyaW5nRmlsdGVyKGUpO1xuXHRcdFx0XHRcdGIgPSBlWzBdO1xuXHRcdFx0XHRcdGUgPSBlWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBiYSA9IGIuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksIC8vYmVnaW5uaW5nIGFycmF5XG5cdFx0XHRcdFx0ZWEgPSBlLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2VuZGluZyBhcnJheVxuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGgsXG5cdFx0XHRcdFx0YXV0b1JvdW5kID0gKF9hdXRvUm91bmQgIT09IGZhbHNlKSxcblx0XHRcdFx0XHRpLCB4aSwgbmksIGJ2LCBldiwgYm51bXMsIGVudW1zLCBibiwgaGFzQWxwaGEsIHRlbXAsIGN2LCBzdHIsIHVzZUhTTDtcblx0XHRcdFx0aWYgKGUuaW5kZXhPZihcIixcIikgIT09IC0xIHx8IGIuaW5kZXhPZihcIixcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YmEgPSBiYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZWEuam9pbihcIiBcIikucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsICE9PSBlYS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwibWlzbWF0Y2hlZCBmb3JtYXR0aW5nIGRldGVjdGVkIG9uIFwiICsgcCArIFwiIChcIiArIGIgKyBcIiB2cyBcIiArIGUgKyBcIilcIik7XG5cdFx0XHRcdFx0YmEgPSAoZGZsdCB8fCBcIlwiKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gc2V0UmF0aW87XG5cdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YnYgPSBiYVtpXTtcblx0XHRcdFx0XHRldiA9IGVhW2ldO1xuXHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChidik7XG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgYmVnaW5zIHdpdGggYSBudW1iZXIgKG1vc3QgY29tbW9uKS4gSXQncyBmaW5lIGlmIGl0IGhhcyBhIHN1ZmZpeCBsaWtlIHB4XG5cdFx0XHRcdFx0aWYgKGJuIHx8IGJuID09PSAwKSB7XG5cdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJuLCBfcGFyc2VDaGFuZ2UoZXYsIGJuKSwgZXYucmVwbGFjZShfcmVsTnVtRXhwLCBcIlwiKSwgKGF1dG9Sb3VuZCAmJiBldi5pbmRleE9mKFwicHhcIikgIT09IC0xKSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvL2lmIHRoZSB2YWx1ZSBpcyBhIGNvbG9yXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjbHJzICYmIF9jb2xvckV4cC50ZXN0KGJ2KSkge1xuXHRcdFx0XHRcdFx0c3RyID0gZXYuaW5kZXhPZihcIilcIikgKyAxO1xuXHRcdFx0XHRcdFx0c3RyID0gXCIpXCIgKyAoc3RyID8gZXYuc3Vic3RyKHN0cikgOiBcIlwiKTsgLy9pZiB0aGVyZSdzIGEgY29tbWEgb3IgKSBhdCB0aGUgZW5kLCByZXRhaW4gaXQuXG5cdFx0XHRcdFx0XHR1c2VIU0wgPSAoZXYuaW5kZXhPZihcImhzbFwiKSAhPT0gLTEgJiYgX3N1cHBvcnRzT3BhY2l0eSk7XG5cdFx0XHRcdFx0XHRidiA9IF9wYXJzZUNvbG9yKGJ2LCB1c2VIU0wpO1xuXHRcdFx0XHRcdFx0ZXYgPSBfcGFyc2VDb2xvcihldiwgdXNlSFNMKTtcblx0XHRcdFx0XHRcdGhhc0FscGhhID0gKGJ2Lmxlbmd0aCArIGV2Lmxlbmd0aCA+IDYpO1xuXHRcdFx0XHRcdFx0aWYgKGhhc0FscGhhICYmICFfc3VwcG9ydHNPcGFjaXR5ICYmIGV2WzNdID09PSAwKSB7IC8vb2xkZXIgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCksIHNvIGlmIHRoZSBkZXN0aW5hdGlvbiBhbHBoYSBpcyAwLCBqdXN0IHVzZSBcInRyYW5zcGFyZW50XCIgZm9yIHRoZSBlbmQgY29sb3Jcblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gcHQubCA/IFwiIHRyYW5zcGFyZW50XCIgOiBcInRyYW5zcGFyZW50XCI7XG5cdFx0XHRcdFx0XHRcdHB0LmUgPSBwdC5lLnNwbGl0KGVhW2ldKS5qb2luKFwidHJhbnNwYXJlbnRcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkpIHsgLy9vbGQgdmVyc2lvbnMgb2YgSUUgZG9uJ3Qgc3VwcG9ydCByZ2JhKCkuXG5cdFx0XHRcdFx0XHRcdFx0aGFzQWxwaGEgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAodXNlSFNMKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYSgoaGFzQWxwaGEgPyBcImhzbGEoXCIgOiBcImhzbChcIiksIGJ2WzBdLCBfcGFyc2VDaGFuZ2UoZXZbMF0sIGJ2WzBdKSwgXCIsXCIsIGZhbHNlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIF9wYXJzZUNoYW5nZShldlsxXSwgYnZbMV0pLCBcIiUsXCIsIGZhbHNlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIF9wYXJzZUNoYW5nZShldlsyXSwgYnZbMl0pLCAoaGFzQWxwaGEgPyBcIiUsXCIgOiBcIiVcIiArIHN0ciksIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKChoYXNBbHBoYSA/IFwicmdiYShcIiA6IFwicmdiKFwiKSwgYnZbMF0sIGV2WzBdIC0gYnZbMF0sIFwiLFwiLCB0cnVlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIGV2WzFdIC0gYnZbMV0sIFwiLFwiLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIGV2WzJdIC0gYnZbMl0sIChoYXNBbHBoYSA/IFwiLFwiIDogc3RyKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoaGFzQWxwaGEpIHtcblx0XHRcdFx0XHRcdFx0XHRidiA9IChidi5sZW5ndGggPCA0KSA/IDEgOiBidlszXTtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKFwiXCIsIGJ2LCAoKGV2Lmxlbmd0aCA8IDQpID8gMSA6IGV2WzNdKSAtIGJ2LCBzdHIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2NvbG9yRXhwLmxhc3RJbmRleCA9IDA7IC8vb3RoZXJ3aXNlIHRoZSB0ZXN0KCkgb24gdGhlIFJlZ0V4cCBjb3VsZCBtb3ZlIHRoZSBsYXN0SW5kZXggYW5kIHRhaW50IGZ1dHVyZSByZXN1bHRzLlxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJudW1zID0gYnYubWF0Y2goX251bUV4cCk7IC8vZ2V0cyBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGJlZ2lubmluZyB2YWx1ZSBzdHJpbmcgYW5kIGRyb3BzIHRoZW0gaW50byBhbiBhcnJheVxuXG5cdFx0XHRcdFx0XHQvL2lmIG5vIG51bWJlciBpcyBmb3VuZCwgdHJlYXQgaXQgYXMgYSBub24tdHdlZW5pbmcgdmFsdWUgYW5kIGp1c3QgYXBwZW5kIHRoZSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgeHMuXG5cdFx0XHRcdFx0XHRpZiAoIWJudW1zKSB7XG5cdFx0XHRcdFx0XHRcdHB0W1wieHNcIiArIHB0LmxdICs9IChwdC5sIHx8IHB0W1wieHNcIiArIHB0LmxdKSA/IFwiIFwiICsgZXYgOiBldjtcblxuXHRcdFx0XHRcdFx0Ly9sb29wIHRocm91Z2ggYWxsIHRoZSBudW1iZXJzIHRoYXQgYXJlIGZvdW5kIGFuZCBjb25zdHJ1Y3QgdGhlIGV4dHJhIHZhbHVlcyBvbiB0aGUgcHQuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbnVtcyA9IGV2Lm1hdGNoKF9yZWxOdW1FeHApOyAvL2dldCBlYWNoIGdyb3VwIG9mIG51bWJlcnMgaW4gdGhlIGVuZCB2YWx1ZSBzdHJpbmcgYW5kIGRyb3AgdGhlbSBpbnRvIGFuIGFycmF5LiBXZSBhbGxvdyByZWxhdGl2ZSB2YWx1ZXMgdG9vLCBsaWtlICs9NTAgb3IgLT0uNVxuXHRcdFx0XHRcdFx0XHRpZiAoIWVudW1zIHx8IGVudW1zLmxlbmd0aCAhPT0gYm51bXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuaSA9IDA7XG5cdFx0XHRcdFx0XHRcdGZvciAoeGkgPSAwOyB4aSA8IGJudW1zLmxlbmd0aDsgeGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGN2ID0gYm51bXNbeGldO1xuXHRcdFx0XHRcdFx0XHRcdHRlbXAgPSBidi5pbmRleE9mKGN2LCBuaSk7XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShidi5zdWJzdHIobmksIHRlbXAgLSBuaSksIE51bWJlcihjdiksIF9wYXJzZUNoYW5nZShlbnVtc1t4aV0sIGN2KSwgXCJcIiwgKGF1dG9Sb3VuZCAmJiBidi5zdWJzdHIodGVtcCArIGN2Lmxlbmd0aCwgMikgPT09IFwicHhcIiksICh4aSA9PT0gMCkpO1xuXHRcdFx0XHRcdFx0XHRcdG5pID0gdGVtcCArIGN2Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBidi5zdWJzdHIobmkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL2lmIHRoZXJlIGFyZSByZWxhdGl2ZSB2YWx1ZXMgKFwiKz1cIiBvciBcIi09XCIgcHJlZml4KSwgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGVuZGluZyB2YWx1ZSB0byBlbGltaW5hdGUgdGhlIHByZWZpeGVzIGFuZCBjb21iaW5lIHRoZSB2YWx1ZXMgcHJvcGVybHkuXG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCI9XCIpICE9PSAtMSkgaWYgKHB0LmRhdGEpIHtcblx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyBwdC5kYXRhLnM7XG5cdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieHNcIiArIGldICsgcHQuZGF0YVtcInhuXCIgKyBpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQuZSA9IHN0ciArIHB0W1wieHNcIiArIGldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcHQubCkge1xuXHRcdFx0XHRcdHB0LnR5cGUgPSAtMTtcblx0XHRcdFx0XHRwdC54czAgPSBwdC5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdC54Zmlyc3QgfHwgcHQ7XG5cdFx0XHR9LFxuXHRcdFx0aSA9IDk7XG5cblxuXHRcdHAgPSBDU1NQcm9wVHdlZW4ucHJvdG90eXBlO1xuXHRcdHAubCA9IHAucHIgPSAwOyAvL2xlbmd0aCAobnVtYmVyIG9mIGV4dHJhIHByb3BlcnRpZXMgbGlrZSB4bjEsIHhuMiwgeG4zLCBldGMuXG5cdFx0d2hpbGUgKC0taSA+IDApIHtcblx0XHRcdHBbXCJ4blwiICsgaV0gPSAwO1xuXHRcdFx0cFtcInhzXCIgKyBpXSA9IFwiXCI7XG5cdFx0fVxuXHRcdHAueHMwID0gXCJcIjtcblx0XHRwLl9uZXh0ID0gcC5fcHJldiA9IHAueGZpcnN0ID0gcC5kYXRhID0gcC5wbHVnaW4gPSBwLnNldFJhdGlvID0gcC5yeHAgPSBudWxsO1xuXG5cblx0XHQvKipcblx0XHQgKiBBcHBlbmRzIGFuZCBleHRyYSB0d2VlbmluZyB2YWx1ZSB0byBhIENTU1Byb3BUd2VlbiBhbmQgYXV0b21hdGljYWxseSBtYW5hZ2VzIGFueSBwcmVmaXggYW5kIHN1ZmZpeCBzdHJpbmdzLiBUaGUgZmlyc3QgZXh0cmEgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBzIGFuZCBjIG9mIHRoZSBtYWluIENTU1Byb3BUd2VlbiBpbnN0YW5jZSwgYnV0IHRoZXJlYWZ0ZXIgYW55IGV4dHJhcyBhcmUgc3RvcmVkIGluIHRoZSB4bjEsIHhuMiwgeG4zLCBldGMuIFRoZSBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgYXJlIHN0b3JlZCBpbiB0aGUgeHMwLCB4czEsIHhzMiwgZXRjLiBwcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSwgaWYgSSB3YWxrIHRocm91Z2ggYSBjbGlwIHZhbHVlIGxpa2UgXCJyZWN0KDEwcHgsIDVweCwgMHB4LCAyMHB4KVwiLCB0aGUgdmFsdWVzIHdvdWxkIGJlIHN0b3JlZCBsaWtlIHRoaXM6XG5cdFx0ICogeHMwOlwicmVjdChcIiwgczoxMCwgeHMxOlwicHgsIFwiLCB4bjE6NSwgeHMyOlwicHgsIFwiLCB4bjI6MCwgeHMzOlwicHgsIFwiLCB4bjM6MjAsIHhuNDpcInB4KVwiXG5cdFx0ICogQW5kIHRoZXknZCBhbGwgZ2V0IGpvaW5lZCB0b2dldGhlciB3aGVuIHRoZSBDU1NQbHVnaW4gcmVuZGVycyAoaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHBmeCBQcmVmaXggKGlmIGFueSlcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IHMgU3RhcnRpbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiB0aGUgc3RhcnQgaXMgNSBhbmQgdGhlIGVuZCBpcyAxMDAsIHRoZSBjaGFuZ2Ugd291bGQgYmUgOTUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBzZnggU3VmZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBSb3VuZCAoaWYgdHJ1ZSkuXG5cdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFkIElmIHRydWUsIHRoaXMgZXh0cmEgdmFsdWUgc2hvdWxkIGJlIHNlcGFyYXRlZCBieSB0aGUgcHJldmlvdXMgb25lIGJ5IGEgc3BhY2UuIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGV4dHJhIGFuZCBwYWQgaXMgdHJ1ZSwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRyb3AgdGhlIHNwYWNlLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbn0gcmV0dXJucyBpdHNlbGYgc28gdGhhdCBtdWx0aXBsZSBtZXRob2RzIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLlxuXHRcdCAqL1xuXHRcdHAuYXBwZW5kWHRyYSA9IGZ1bmN0aW9uKHBmeCwgcywgYywgc2Z4LCByLCBwYWQpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMsXG5cdFx0XHRcdGwgPSBwdC5sO1xuXHRcdFx0cHRbXCJ4c1wiICsgbF0gKz0gKHBhZCAmJiAobCB8fCBwdFtcInhzXCIgKyBsXSkpID8gXCIgXCIgKyBwZnggOiBwZnggfHwgXCJcIjtcblx0XHRcdGlmICghYykgaWYgKGwgIT09IDAgJiYgIXB0LnBsdWdpbikgeyAvL3R5cGljYWxseSB3ZSdsbCBjb21iaW5lIG5vbi1jaGFuZ2luZyB2YWx1ZXMgcmlnaHQgaW50byB0aGUgeHMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UsIGJ1dCB3ZSBkb24ndCBjb21iaW5lIHRoZW0gd2hlbiB0aGVyZSdzIGEgcGx1Z2luIHRoYXQgd2lsbCBiZSB0d2VlbmluZyB0aGUgdmFsdWVzIGJlY2F1c2UgaXQgbWF5IGRlcGVuZCBvbiB0aGUgdmFsdWVzIGJlaW5nIHNwbGl0IGFwYXJ0LCBsaWtlIGZvciBhIGJlemllciwgaWYgYSB2YWx1ZSBkb2Vzbid0IGNoYW5nZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGl0ZXJhdGlvbiBidXQgdGhlbiBpdCBkb2VzIG9uIHRoZSAzcmQsIHdlJ2xsIHJ1biBpbnRvIHRyb3VibGUgYmVjYXVzZSB0aGVyZSdzIG5vIHhuIHNsb3QgZm9yIHRoYXQgdmFsdWUhXG5cdFx0XHRcdHB0W1wieHNcIiArIGxdICs9IHMgKyAoc2Z4IHx8IFwiXCIpO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9XG5cdFx0XHRwdC5sKys7XG5cdFx0XHRwdC50eXBlID0gcHQuc2V0UmF0aW8gPyAyIDogMTtcblx0XHRcdHB0W1wieHNcIiArIHB0LmxdID0gc2Z4IHx8IFwiXCI7XG5cdFx0XHRpZiAobCA+IDApIHtcblx0XHRcdFx0cHQuZGF0YVtcInhuXCIgKyBsXSA9IHMgKyBjO1xuXHRcdFx0XHRwdC5yeHBbXCJ4blwiICsgbF0gPSByOyAvL3JvdW5kIGV4dHJhIHByb3BlcnR5ICh3ZSBuZWVkIHRvIHRhcCBpbnRvIHRoaXMgaW4gdGhlIF9wYXJzZVRvUHJveHkoKSBtZXRob2QpXG5cdFx0XHRcdHB0W1wieG5cIiArIGxdID0gcztcblx0XHRcdFx0aWYgKCFwdC5wbHVnaW4pIHtcblx0XHRcdFx0XHRwdC54Zmlyc3QgPSBuZXcgQ1NTUHJvcFR3ZWVuKHB0LCBcInhuXCIgKyBsLCBzLCBjLCBwdC54Zmlyc3QgfHwgcHQsIDAsIHB0Lm4sIHIsIHB0LnByKTtcblx0XHRcdFx0XHRwdC54Zmlyc3QueHMwID0gMDsgLy9qdXN0IHRvIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBzdGF5cyBudW1lcmljIHdoaWNoIGhlbHBzIG1vZGVybiBicm93c2VycyBzcGVlZCB1cCBwcm9jZXNzaW5nLiBSZW1lbWJlciwgaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kLCB3ZSBkbyBwdC50W3B0LnBdID0gdmFsICsgcHQueHMwIHNvIGlmIHB0LnhzMCBpcyBcIlwiICh0aGUgZGVmYXVsdCksIGl0J2xsIGNhc3QgdGhlIGVuZCB2YWx1ZSBhcyBhIHN0cmluZy4gV2hlbiBhIHByb3BlcnR5IGlzIGEgbnVtYmVyIHNvbWV0aW1lcyBhbmQgYSBzdHJpbmcgc29tZXRpbWVzLCBpdCBwcmV2ZW50cyB0aGUgY29tcGlsZXIgZnJvbSBsb2NraW5nIGluIHRoZSBkYXRhIHR5cGUsIHNsb3dpbmcgdGhpbmdzIGRvd24gc2xpZ2h0bHkuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQuZGF0YSA9IHtzOnMgKyBjfTtcblx0XHRcdHB0LnJ4cCA9IHt9O1xuXHRcdFx0cHQucyA9IHM7XG5cdFx0XHRwdC5jID0gYztcblx0XHRcdHB0LnIgPSByO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAY29uc3RydWN0b3IgQSBTcGVjaWFsUHJvcCBpcyBiYXNpY2FsbHkgYSBjc3MgcHJvcGVydHkgdGhhdCBuZWVkcyB0byBiZSB0cmVhdGVkIGluIGEgbm9uLXN0YW5kYXJkIHdheSwgbGlrZSBpZiBpdCBtYXkgY29udGFpbiBhIGNvbXBsZXggdmFsdWUgbGlrZSBib3hTaGFkb3c6XCI1cHggMTBweCAxNXB4IHJnYigyNTUsIDEwMiwgNTEpXCIgb3IgaWYgaXQgaXMgYXNzb2NpYXRlZCB3aXRoIGFub3RoZXIgcGx1Z2luIGxpa2UgVGhyb3dQcm9wc1BsdWdpbiBvciBCZXppZXJQbHVnaW4uIEV2ZXJ5IFNwZWNpYWxQcm9wIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgcHJvcGVydHkgbmFtZSBsaWtlIFwiYm94U2hhZG93XCIgb3IgXCJ0aHJvd1Byb3BzXCIgb3IgXCJiZXppZXJcIiBhbmQgaXQgd2lsbCBpbnRlcmNlcHQgdGhvc2UgdmFsdWVzIGluIHRoZSB2YXJzIG9iamVjdCB0aGF0J3MgcGFzc2VkIHRvIHRoZSBDU1NQbHVnaW4gYW5kIGhhbmRsZSB0aGVtIGFjY29yZGluZ2x5LlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBQcm9wZXJ0eSBuYW1lIChsaWtlIFwiYm94U2hhZG93XCIgb3IgXCJ0aHJvd1Byb3BzXCIpXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb24gb3B0aW9uczpcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGRlZmF1bHRWYWx1ZTogdGhlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIHBhcnNlcjogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBuYW1lIGlzIGZvdW5kIGluIHRoZSB2YXJzLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UgYW5kIGl0IHNob3VsZCBlbnN1cmUgdGhhdCBpdCBpcyBwcm9wZXJseSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdC4gSXQgd2lsbCByZWNlaXZlIDQgcGFyYW10ZXJzOiAxKSBUaGUgdGFyZ2V0LCAyKSBUaGUgdmFsdWUgZGVmaW5lZCBpbiB0aGUgdmFycywgMykgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSAod2hvc2UgX2ZpcnN0UFQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBsaW5rZWQgbGlzdCksIGFuZCA0KSBBIGNvbXB1dGVkIHN0eWxlIG9iamVjdCBpZiBvbmUgd2FzIGNhbGN1bGF0ZWQgKHRoaXMgaXMgYSBzcGVlZCBvcHRpbWl6YXRpb24gdGhhdCBhbGxvd3MgcmV0cmlldmFsIG9mIHN0YXJ0aW5nIHZhbHVlcyBxdWlja2VyKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gZm9ybWF0dGVyOiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhbnkgdmFsdWUgcmVjZWl2ZWQgZm9yIHRoaXMgc3BlY2lhbCBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGJveFNoYWRvdyBjb3VsZCB0YWtlIFwiNXB4IDVweCByZWRcIiBhbmQgZm9ybWF0IGl0IHRvIFwiNXB4IDVweCAwcHggMHB4IHJlZFwiIHNvIHRoYXQgYm90aCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIGhhdmUgYSBjb21tb24gb3JkZXIgYW5kIHF1YW50aXR5IG9mIHZhbHVlcy4pXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwcmVmaXg6IGlmIHRydWUsIHdlJ2xsIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHByb3BlcnR5IHJlcXVpcmVzIGEgdmVuZG9yIHByZWZpeCAobGlrZSBXZWJraXQgb3IgTW96IG9yIG1zIG9yIE8pXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBjb2xvcjogc2V0IHRoaXMgdG8gdHJ1ZSBpZiB0aGUgdmFsdWUgZm9yIHRoaXMgU3BlY2lhbFByb3AgbWF5IGNvbnRhaW4gY29sb3ItcmVsYXRlZCB2YWx1ZXMgbGlrZSByZ2IoKSwgcmdiYSgpLCBldGMuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwcmlvcml0eTogcHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgU3BlY2lhbFByb3BzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgMC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIG11bHRpOiBpZiB0cnVlLCB0aGUgZm9ybWF0dGVyIHNob3VsZCBhY2NvbW1vZGF0ZSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcywgbGlrZSBib3hTaGFkb3cgY291bGQgaGF2ZSBtdWx0aXBsZSBib3hTaGFkb3dzIGxpc3RlZCBvdXQuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBjb2xsYXBzaWJsZTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgdHJlYXQgdGhlIHZhbHVlIGxpa2UgaXQncyBhIHRvcC9yaWdodC9ib3R0b20vbGVmdCB2YWx1ZSB0aGF0IGNvdWxkIGJlIGNvbGxhcHNlZCwgbGlrZSBcIjVweFwiIHdvdWxkIGFwcGx5IHRvIGFsbCwgXCI1cHgsIDEwcHhcIiB3b3VsZCB1c2UgNXB4IGZvciB0b3AvYm90dG9tIGFuZCAxMHB4IGZvciByaWdodC9sZWZ0LCBldGMuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBrZXl3b3JkOiBhIHNwZWNpYWwga2V5d29yZCB0aGF0IGNhbiBbb3B0aW9uYWxseV0gYmUgZm91bmQgaW5zaWRlIHRoZSB2YWx1ZSAobGlrZSBcImluc2V0XCIgZm9yIGJveFNoYWRvdykuIFRoaXMgYWxsb3dzIHVzIHRvIHZhbGlkYXRlIGJlZ2lubmluZy9lbmRpbmcgdmFsdWVzIHRvIG1ha2Ugc3VyZSB0aGV5IG1hdGNoIChpZiB0aGUga2V5d29yZCBpcyBmb3VuZCBpbiBvbmUsIGl0J2xsIGJlIGFkZGVkIHRvIHRoZSBvdGhlciBmb3IgY29uc2lzdGVuY3kgYnkgZGVmYXVsdCkuXG5cdFx0ICovXG5cdFx0dmFyIFNwZWNpYWxQcm9wID0gZnVuY3Rpb24ocCwgb3B0aW9ucykge1xuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdFx0dGhpcy5wID0gb3B0aW9ucy5wcmVmaXggPyBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHAgOiBwO1xuXHRcdFx0XHRfc3BlY2lhbFByb3BzW3BdID0gX3NwZWNpYWxQcm9wc1t0aGlzLnBdID0gdGhpcztcblx0XHRcdFx0dGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdHRlciB8fCBfZ2V0Rm9ybWF0dGVyKG9wdGlvbnMuZGVmYXVsdFZhbHVlLCBvcHRpb25zLmNvbG9yLCBvcHRpb25zLmNvbGxhcHNpYmxlLCBvcHRpb25zLm11bHRpKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMucGFyc2VyKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJzZSA9IG9wdGlvbnMucGFyc2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2xycyA9IG9wdGlvbnMuY29sb3I7XG5cdFx0XHRcdHRoaXMubXVsdGkgPSBvcHRpb25zLm11bHRpO1xuXHRcdFx0XHR0aGlzLmtleXdvcmQgPSBvcHRpb25zLmtleXdvcmQ7XG5cdFx0XHRcdHRoaXMuZGZsdCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHR0aGlzLnByID0gb3B0aW9ucy5wcmlvcml0eSB8fCAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly9zaG9ydGN1dCBmb3IgY3JlYXRpbmcgYSBuZXcgU3BlY2lhbFByb3AgdGhhdCBjYW4gYWNjZXB0IG11bHRpcGxlIHByb3BlcnRpZXMgYXMgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCAoaGVscHMgbWluaWZpY2F0aW9uKS4gZGZsdCBjYW4gYmUgYW4gYXJyYXkgZm9yIG11bHRpcGxlIHZhbHVlcyAod2UgZG9uJ3QgZG8gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBiZWNhdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG1heSBjb250YWluIGNvbW1hcywgbGlrZSByZWN0KDBweCwwcHgsMHB4LDBweCkpLiBXZSBhdHRhY2ggdGhpcyBtZXRob2QgdG8gdGhlIFNwZWNpYWxQcm9wIGNsYXNzL29iamVjdCBpbnN0ZWFkIG9mIHVzaW5nIGEgcHJpdmF0ZSBfY3JlYXRlU3BlY2lhbFByb3AoKSBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gdGFwIGludG8gaXQgZXh0ZXJuYWxseSBpZiBuZWNlc3NhcnksIGxpa2UgZnJvbSBhbm90aGVyIHBsdWdpbi5cblx0XHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IF9pbnRlcm5hbHMuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wID0gZnVuY3Rpb24ocCwgb3B0aW9ucywgZGVmYXVsdHMpIHtcblx0XHRcdFx0aWYgKHR5cGVvZihvcHRpb25zKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB7cGFyc2VyOmRlZmF1bHRzfTsgLy90byBtYWtlIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgQmV6aWVyUGx1Z2luIGFuZCBUaHJvd1Byb3BzUGx1Z2luXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGEgPSBwLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRkID0gb3B0aW9ucy5kZWZhdWx0VmFsdWUsXG5cdFx0XHRcdFx0aSwgdGVtcDtcblx0XHRcdFx0ZGVmYXVsdHMgPSBkZWZhdWx0cyB8fCBbZF07XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5wcmVmaXggPSAoaSA9PT0gMCAmJiBvcHRpb25zLnByZWZpeCk7XG5cdFx0XHRcdFx0b3B0aW9ucy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1tpXSB8fCBkO1xuXHRcdFx0XHRcdHRlbXAgPSBuZXcgU3BlY2lhbFByb3AoYVtpXSwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vY3JlYXRlcyBhIHBsYWNlaG9sZGVyIHNwZWNpYWwgcHJvcCBmb3IgYSBwbHVnaW4gc28gdGhhdCB0aGUgcHJvcGVydHkgZ2V0cyBjYXVnaHQgdGhlIGZpcnN0IHRpbWUgYSB0d2VlbiBvZiBpdCBpcyBhdHRlbXB0ZWQsIGFuZCBhdCB0aGF0IHRpbWUgaXQgbWFrZXMgdGhlIHBsdWdpbiByZWdpc3RlciBpdHNlbGYsIHRodXMgdGFraW5nIG92ZXIgZm9yIGFsbCBmdXR1cmUgdHdlZW5zIG9mIHRoYXQgcHJvcGVydHkuIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCBtYW5kYXRlIHRoYXQgdGhpbmdzIGxvYWQgaW4gYSBwYXJ0aWN1bGFyIG9yZGVyIGFuZCBpdCBhbHNvIGFsbG93cyB1cyB0byBsb2coKSBhbiBlcnJvciB0aGF0IGluZm9ybXMgdGhlIHVzZXIgd2hlbiB0aGV5IGF0dGVtcHQgdG8gdHdlZW4gYW4gZXh0ZXJuYWwgcGx1Z2luLXJlbGF0ZWQgcHJvcGVydHkgd2l0aG91dCBsb2FkaW5nIGl0cyAuanMgZmlsZS5cblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AgPSBfaW50ZXJuYWxzLl9yZWdpc3RlclBsdWdpblByb3AgPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmICghX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdHZhciBwbHVnaW5OYW1lID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpICsgXCJQbHVnaW5cIjtcblx0XHRcdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AocCwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGx1Z2luQ2xhc3MgPSBfZ2xvYmFscy5jb20uZ3JlZW5zb2NrLnBsdWdpbnNbcGx1Z2luTmFtZV07XG5cdFx0XHRcdFx0XHRpZiAoIXBsdWdpbkNsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9sb2coXCJFcnJvcjogXCIgKyBwbHVnaW5OYW1lICsgXCIganMgZmlsZSBub3QgbG9hZGVkLlwiKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGx1Z2luQ2xhc3MuX2Nzc1JlZ2lzdGVyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX3NwZWNpYWxQcm9wc1twXS5wYXJzZSh0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKTtcblx0XHRcdFx0XHR9fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblxuXHRcdHAgPSBTcGVjaWFsUHJvcC5wcm90b3R5cGU7XG5cblx0XHQvKipcblx0XHQgKiBBbGlhcyBmb3IgX3BhcnNlQ29tcGxleCgpIHRoYXQgYXV0b21hdGljYWxseSBwbHVncyBpbiBjZXJ0YWluIHZhbHVlcyBmb3IgdGhpcyBTcGVjaWFsUHJvcCwgbGlrZSBpdHMgcHJvcGVydHkgbmFtZSwgd2hldGhlciBvciBub3QgY29sb3JzIHNob3VsZCBiZSBzZW5zZWQsIHRoZSBkZWZhdWx0IHZhbHVlLCBhbmQgcHJpb3JpdHkuIEl0IGFsc28gbG9va3MgZm9yIGFueSBrZXl3b3JkIHRoYXQgdGhlIFNwZWNpYWxQcm9wIGRlZmluZXMgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiB2YWx1ZXMgZm9yIFNwZWNpYWxQcm9wcyB3aGVyZSBtdWx0aSBpcyB0cnVlIChsaWtlIGJveFNoYWRvdyBhbmQgdGV4dFNoYWRvdyBjYW4gaGF2ZSBhIGNvbW1hLWRlbGltaXRlZCBsaXN0KVxuXHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXJ8b2JqZWN0KX0gYiBiZWdpbm5pbmcgdmFsdWVcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGUgZW5kaW5nIChkZXN0aW5hdGlvbikgdmFsdWVcblx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IHB0IG5leHQgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYW5vdGhlciBwbHVnaW4gd2lsbCBiZSB0d2VlbmluZyB0aGUgY29tcGxleCB2YWx1ZSwgdGhhdCBUd2VlblBsdWdpbiBpbnN0YW5jZSBnb2VzIGhlcmUuXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbj19IHNldFJhdGlvIElmIGEgY3VzdG9tIHNldFJhdGlvKCkgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGhhbmRsZSB0aGlzIGNvbXBsZXggdmFsdWUsIHRoYXQgZ29lcyBoZXJlLlxuXHRcdCAqIEByZXR1cm4ge0NTU1Byb3BUd2Vlbj19IEZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKi9cblx0XHRwLnBhcnNlQ29tcGxleCA9IGZ1bmN0aW9uKHQsIGIsIGUsIHB0LCBwbHVnaW4sIHNldFJhdGlvKSB7XG5cdFx0XHR2YXIga3dkID0gdGhpcy5rZXl3b3JkLFxuXHRcdFx0XHRpLCBiYSwgZWEsIGwsIGJpLCBlaTtcblx0XHRcdC8vaWYgdGhpcyBTcGVjaWFsUHJvcCdzIHZhbHVlIGNhbiBjb250YWluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIChsaWtlIGJveFNoYWRvdyBvciB0ZXh0U2hhZG93KSwgd2UgbXVzdCBwYXJzZSB0aGVtIGluIGEgc3BlY2lhbCB3YXksIGFuZCBsb29rIGZvciBhIGtleXdvcmQgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpIGFuZCBlbnN1cmUgdGhhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgQk9USCBoYXZlIGl0IGlmIHRoZSBlbmQgZGVmaW5lcyBpdCBhcyBzdWNoLiBXZSBhbHNvIG11c3QgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIGFuIGVxdWFsIG51bWJlciBvZiB2YWx1ZXMgc3BlY2lmaWVkICh3ZSBjYW4ndCB0d2VlbiAxIGJveFNoYWRvdyB0byAzIGZvciBleGFtcGxlKVxuXHRcdFx0aWYgKHRoaXMubXVsdGkpIGlmIChfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QoZSkgfHwgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGIpKSB7XG5cdFx0XHRcdGJhID0gYi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdGVhID0gZS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHR9IGVsc2UgaWYgKGt3ZCkge1xuXHRcdFx0XHRiYSA9IFtiXTtcblx0XHRcdFx0ZWEgPSBbZV07XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWEpIHtcblx0XHRcdFx0bCA9IChlYS5sZW5ndGggPiBiYS5sZW5ndGgpID8gZWEubGVuZ3RoIDogYmEubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0YiA9IGJhW2ldID0gYmFbaV0gfHwgdGhpcy5kZmx0O1xuXHRcdFx0XHRcdGUgPSBlYVtpXSA9IGVhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRpZiAoa3dkKSB7XG5cdFx0XHRcdFx0XHRiaSA9IGIuaW5kZXhPZihrd2QpO1xuXHRcdFx0XHRcdFx0ZWkgPSBlLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGlmIChiaSAhPT0gZWkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGVpID09PSAtMSkgeyAvL2lmIHRoZSBrZXl3b3JkIGlzbid0IGluIHRoZSBlbmQgdmFsdWUsIHJlbW92ZSBpdCBmcm9tIHRoZSBiZWdpbm5pbmcgb25lLlxuXHRcdFx0XHRcdFx0XHRcdGJhW2ldID0gYmFbaV0uc3BsaXQoa3dkKS5qb2luKFwiXCIpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGJpID09PSAtMSkgeyAvL2lmIHRoZSBrZXl3b3JkIGlzbid0IGluIHRoZSBiZWdpbm5pbmcsIGFkZCBpdC5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSArPSBcIiBcIiArIGt3ZDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRiID0gYmEuam9pbihcIiwgXCIpO1xuXHRcdFx0XHRlID0gZWEuam9pbihcIiwgXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9wYXJzZUNvbXBsZXgodCwgdGhpcy5wLCBiLCBlLCB0aGlzLmNscnMsIHRoaXMuZGZsdCwgcHQsIHRoaXMucHIsIHBsdWdpbiwgc2V0UmF0aW8pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBY2NlcHRzIGEgdGFyZ2V0IGFuZCBlbmQgdmFsdWUgYW5kIHNwaXRzIGJhY2sgYSBDU1NQcm9wVHdlZW4gdGhhdCBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBDU1NQbHVnaW4ncyBsaW5rZWQgbGlzdCBhbmQgY29uZm9ybXMgd2l0aCBhbGwgdGhlIGNvbnZlbnRpb25zIHdlIHVzZSBpbnRlcm5hbGx5LCBsaWtlIHR5cGU6LTEsIDAsIDEsIG9yIDIsIHNldHRpbmcgdXAgYW55IGV4dHJhIHByb3BlcnR5IHR3ZWVucywgcHJpb3JpdHksIGV0Yy4gRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmUgYSBib3hTaGFkb3cgU3BlY2lhbFByb3AgYW5kIGNhbGw6XG5cdFx0ICogdGhpcy5fZmlyc3RQVCA9IHNwLnBhcnNlKGVsZW1lbnQsIFwiNXB4IDEwcHggMjBweCByZ2IoMjU1MCwxMDIsNTEpXCIsIFwiYm94U2hhZG93XCIsIHRoaXMpO1xuXHRcdCAqIEl0IHNob3VsZCBmaWd1cmUgb3V0IHRoZSBzdGFydGluZyB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGJveFNoYWRvdywgY29tcGFyZSBpdCB0byB0aGUgcHJvdmlkZWQgZW5kIHZhbHVlIGFuZCBjcmVhdGUgYWxsIHRoZSBuZWNlc3NhcnkgQ1NTUHJvcFR3ZWVucyBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgdG8gdHdlZW4gdGhlIGJveFNoYWRvdy4gVGhlIENTU1Byb3BUd2VlbiB0aGF0IGdldHMgc3BpdCBiYWNrIHNob3VsZCBhbHJlYWR5IGJlIGluc2VydGVkIGludG8gdGhlIGxpbmtlZCBsaXN0ICh0aGUgNHRoIHBhcmFtZXRlciBpcyB0aGUgY3VycmVudCBoZWFkLCBzbyBwcmVwZW5kIHRvIHRoYXQpLlxuXHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIGJlaW5nIHR3ZWVuZWRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZSBFbmQgdmFsdWUgYXMgcHJvdmlkZWQgaW4gdGhlIHZhcnMgb2JqZWN0ICh0eXBpY2FsbHkgYSBzdHJpbmcsIGJ1dCBub3QgYWx3YXlzIC0gbGlrZSBhIHRocm93UHJvcHMgd291bGQgYmUgYW4gb2JqZWN0KS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZVxuXHRcdCAqIEBwYXJhbSB7IUNTU1BsdWdpbn0gY3NzcCBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHR3ZWVuLlxuXHRcdCAqIEBwYXJhbSB7P0NTU1Byb3BUd2Vlbn0gcHQgVGhlIENTU1Byb3BUd2VlbiB0aGF0IGlzIHRoZSBjdXJyZW50IGhlYWQgb2YgdGhlIGxpbmtlZCBsaXN0ICh3ZSdsbCBwcmVwZW5kIHRvIGl0KVxuXHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gSWYgYSBwbHVnaW4gd2lsbCBiZSB1c2VkIHRvIHR3ZWVuIHRoZSBwYXJzZWQgdmFsdWUsIHRoaXMgaXMgdGhlIHBsdWdpbiBpbnN0YW5jZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdD19IHZhcnMgT3JpZ2luYWwgdmFycyBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YSBmb3IgcGFyc2luZy5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IFRoZSBmaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0IHdoaWNoIGluY2x1ZGVzIHRoZSBuZXcgb25lKHMpIGFkZGVkIGJ5IHRoZSBwYXJzZSgpIGNhbGwuXG5cdFx0ICovXG5cdFx0cC5wYXJzZSA9IGZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgdGhpcy5wLCBfY3MsIGZhbHNlLCB0aGlzLmRmbHQpKSwgdGhpcy5mb3JtYXQoZSksIHB0LCBwbHVnaW4pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSZWdpc3RlcnMgYSBzcGVjaWFsIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGZyb20gYW55IFwiY3NzXCIgb2JqZWN0cyBkZWZpbmVkIGluIHR3ZWVucy4gVGhpcyBhbGxvd3MgeW91IHRvIGhhbmRsZSB0aGVtIGhvd2V2ZXIgeW91IHdhbnQgd2l0aG91dCBDU1NQbHVnaW4gZG9pbmcgaXQgZm9yIHlvdS4gVGhlIDJuZCBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIDMgcGFyYW1ldGVyczpcblx0XHQgKiAgMSkgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBzaG91bGQgYmUgdHdlZW5lZCAodHlwaWNhbGx5IGEgRE9NIGVsZW1lbnQpXG5cdFx0ICogIDIpIFRoZSBlbmQvZGVzdGluYXRpb24gdmFsdWUgKGNvdWxkIGJlIGEgc3RyaW5nLCBudW1iZXIsIG9iamVjdCwgb3Igd2hhdGV2ZXIgeW91IHdhbnQpXG5cdFx0ICogIDMpIFRoZSB0d2VlbiBpbnN0YW5jZSAoeW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhpcywgYnV0IGl0IGNhbiBiZSB1c2VmdWwgZm9yIGxvb2tpbmcgdXAgaW5mb3JtYXRpb24gbGlrZSB0aGUgZHVyYXRpb24pXG5cdFx0ICpcblx0XHQgKiBUaGVuLCB5b3VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBlYWNoIHRpbWUgdGhlIHR3ZWVuIGdldHMgcmVuZGVyZWQsIHBhc3NpbmcgYSBudW1lcmljIFwicmF0aW9cIiBwYXJhbWV0ZXIgdG8geW91ciBmdW5jdGlvbiB0aGF0IGluZGljYXRlcyB0aGUgY2hhbmdlIGZhY3RvciAodXN1YWxseSBiZXR3ZWVuIDAgYW5kIDEpLiBGb3IgZXhhbXBsZTpcblx0XHQgKlxuXHRcdCAqIENTU1BsdWdpbi5yZWdpc3RlclNwZWNpYWxQcm9wKFwibXlDdXN0b21Qcm9wXCIsIGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuKSB7XG5cdFx0ICogICAgICB2YXIgc3RhcnQgPSB0YXJnZXQuc3R5bGUud2lkdGg7XG5cdFx0ICogICAgICByZXR1cm4gZnVuY3Rpb24ocmF0aW8pIHtcblx0XHQgKiAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gKHN0YXJ0ICsgdmFsdWUgKiByYXRpbykgKyBcInB4XCI7XG5cdFx0ICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2V0IHdpZHRoIHRvIFwiICsgdGFyZ2V0LnN0eWxlLndpZHRoKTtcblx0XHQgKiAgICAgICAgICB9XG5cdFx0ICogfSwgMCk7XG5cdFx0ICpcblx0XHQgKiBUaGVuLCB3aGVuIEkgZG8gdGhpcyB0d2VlbiwgaXQgd2lsbCB0cmlnZ2VyIG15IHNwZWNpYWwgcHJvcGVydHk6XG5cdFx0ICpcblx0XHQgKiBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7bXlDdXN0b21Qcm9wOjEwMH19KTtcblx0XHQgKlxuXHRcdCAqIEluIHRoZSBleGFtcGxlLCBvZiBjb3Vyc2UsIHdlJ3JlIGp1c3QgY2hhbmdpbmcgdGhlIHdpZHRoLCBidXQgeW91IGNhbiBkbyBhbnl0aGluZyB5b3Ugd2FudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIChvciBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcykgdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQgYW5kIGhhbmRsZWQgYnkgeW91ciBmdW5jdGlvbi4gRm9yIGV4YW1wbGUsIGlmIEkgZGVmaW5lIFwibXlDdXN0b21Qcm9wXCIsIHRoZW4gaXQgd291bGQgaGFuZGxlIHRoYXQgcG9ydGlvbiBvZiB0aGUgZm9sbG93aW5nIHR3ZWVuOiBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7bXlDdXN0b21Qcm9wOjEwMH19KVxuXHRcdCAqIEBwYXJhbSB7IWZ1bmN0aW9uKE9iamVjdCwgT2JqZWN0LCBPYmplY3QsIHN0cmluZyk6ZnVuY3Rpb24obnVtYmVyKX0gb25Jbml0VHdlZW4gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHR3ZWVuIG9mIHRoaXMgc3BlY2lhbCBwcm9wZXJ0eSBpcyBwZXJmb3JtZWQuIFRoZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgNCBwYXJhbWV0ZXJzOiAxKSBUYXJnZXQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHR3ZWVuZWQsIDIpIFZhbHVlIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgdHdlZW4sIDMpIFRoZSB0d2VlbiBpbnN0YW5jZSBpdHNlbGYgKHJhcmVseSB1c2VkKSwgYW5kIDQpIFRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQncyBiZWluZyB0d2VlbmVkLiBZb3VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgb24gZXZlcnkgdXBkYXRlIG9mIHRoZSB0d2Vlbi4gVGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYSBzaW5nbGUgcGFyYW1ldGVyIHRoYXQgaXMgYSBcImNoYW5nZSBmYWN0b3JcIiB2YWx1ZSAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgaW5kaWNhdGluZyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcyBhIHJhdGlvLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoZSB2YWx1ZXMgYXBwcm9wcmlhdGVseSBpbiB5b3VyIGZ1bmN0aW9uLlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHJpb3JpdHkgUHJpb3JpdHkgdGhhdCBoZWxwcyB0aGUgZW5naW5lIGRldGVybWluZSB0aGUgb3JkZXIgaW4gd2hpY2ggdG8gc2V0IHRoZSBwcm9wZXJ0aWVzIChkZWZhdWx0OiAwKS4gSGlnaGVyIHByaW9yaXR5IHByb3BlcnRpZXMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLlxuXHRcdCAqL1xuXHRcdENTU1BsdWdpbi5yZWdpc3RlclNwZWNpYWxQcm9wID0gZnVuY3Rpb24obmFtZSwgb25Jbml0VHdlZW4sIHByaW9yaXR5KSB7XG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AobmFtZSwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdHZhciBydiA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIsIHAsIGZhbHNlLCBwcmlvcml0eSk7XG5cdFx0XHRcdHJ2LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cnYuc2V0UmF0aW8gPSBvbkluaXRUd2Vlbih0LCBlLCBjc3NwLl90d2VlbiwgcCk7XG5cdFx0XHRcdHJldHVybiBydjtcblx0XHRcdH0sIHByaW9yaXR5OnByaW9yaXR5fSk7XG5cdFx0fTtcblxuXG5cblxuXG5cblx0XHQvL3RyYW5zZm9ybS1yZWxhdGVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblx0XHRDU1NQbHVnaW4udXNlU1ZHVHJhbnNmb3JtQXR0ciA9IHRydWU7IC8vU2FmYXJpIGFuZCBGaXJlZm94IGJvdGggaGF2ZSBzb21lIHJlbmRlcmluZyBidWdzIHdoZW4gYXBwbHlpbmcgQ1NTIHRyYW5zZm9ybXMgdG8gU1ZHIGVsZW1lbnRzLCBzbyBkZWZhdWx0IHRvIHVzaW5nIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSBpbnN0ZWFkICh1c2VycyBjYW4gb3ZlcnJpZGUgdGhpcykuXG5cdFx0dmFyIF90cmFuc2Zvcm1Qcm9wcyA9IChcInNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHNrZXdYLHNrZXdZLHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscGVyc3BlY3RpdmUseFBlcmNlbnQseVBlcmNlbnRcIikuc3BsaXQoXCIsXCIpLFxuXHRcdFx0X3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KFwidHJhbnNmb3JtXCIpLCAvL3RoZSBKYXZhc2NyaXB0IChjYW1lbENhc2UpIHRyYW5zZm9ybSBwcm9wZXJ0eSwgbGlrZSBtc1RyYW5zZm9ybSwgV2Via2l0VHJhbnNmb3JtLCBNb3pUcmFuc2Zvcm0sIG9yIE9UcmFuc2Zvcm0uXG5cdFx0XHRfdHJhbnNmb3JtUHJvcENTUyA9IF9wcmVmaXhDU1MgKyBcInRyYW5zZm9ybVwiLFxuXHRcdFx0X3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcm9wUHJlZml4KFwidHJhbnNmb3JtT3JpZ2luXCIpLFxuXHRcdFx0X3N1cHBvcnRzM0QgPSAoX2NoZWNrUHJvcFByZWZpeChcInBlcnNwZWN0aXZlXCIpICE9PSBudWxsKSxcblx0XHRcdFRyYW5zZm9ybSA9IF9pbnRlcm5hbHMuVHJhbnNmb3JtID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGVyc3BlY3RpdmUgPSBwYXJzZUZsb2F0KENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpIHx8IDA7XG5cdFx0XHRcdHRoaXMuZm9yY2UzRCA9IChDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgPT09IGZhbHNlIHx8ICFfc3VwcG9ydHMzRCkgPyBmYWxzZSA6IENTU1BsdWdpbi5kZWZhdWx0Rm9yY2UzRCB8fCBcImF1dG9cIjtcblx0XHRcdH0sXG5cdFx0XHRfU1ZHRWxlbWVudCA9IF9nc1Njb3BlLlNWR0VsZW1lbnQsXG5cdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0cixcblx0XHRcdC8vU29tZSBicm93c2VycyAobGlrZSBGaXJlZm94IGFuZCBJRSkgZG9uJ3QgaG9ub3IgdHJhbnNmb3JtLW9yaWdpbiBwcm9wZXJseSBpbiBTVkcgZWxlbWVudHMsIHNvIHdlIG5lZWQgdG8gbWFudWFsbHkgYWRqdXN0IHRoZSBtYXRyaXggYWNjb3JkaW5nbHkuIFdlIGZlYXR1cmUgZGV0ZWN0IGhlcmUgcmF0aGVyIHRoYW4gYWx3YXlzIGRvaW5nIHRoZSBjb252ZXJzaW9uIGZvciBjZXJ0YWluIGJyb3dzZXJzIGJlY2F1c2UgdGhleSBtYXkgZml4IHRoZSBwcm9ibGVtIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cblxuXHRcdFx0X2NyZWF0ZVNWRyA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRhaW5lciwgYXR0cmlidXRlcykge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdHlwZSksXG5cdFx0XHRcdFx0cmVnID0gLyhbYS16XSkoW0EtWl0pL2csXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIHAucmVwbGFjZShyZWcsIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSwgYXR0cmlidXRlc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH0sXG5cdFx0XHRfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50IHx8IHt9LFxuXHRcdFx0X2ZvcmNlU1ZHVHJhbnNmb3JtQXR0ciA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly9JRSBhbmQgQW5kcm9pZCBzdG9jayBkb24ndCBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIG9uIFNWRyBlbGVtZW50cywgc28gd2UgbXVzdCB3cml0ZSB0aGVtIHRvIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZS4gV2UgcG9wdWxhdGUgdGhpcyB2YXJpYWJsZSBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgbWV0aG9kLCBhbmQgb25seSBpZi93aGVuIHdlIGNvbWUgYWNyb3NzIGFuIFNWRyBlbGVtZW50XG5cdFx0XHRcdHZhciBmb3JjZSA9IF9pZVZlcnMgfHwgKC9BbmRyb2lkL2kudGVzdChfYWdlbnQpICYmICFfZ3NTY29wZS5jaHJvbWUpLFxuXHRcdFx0XHRcdHN2ZywgcmVjdCwgd2lkdGg7XG5cdFx0XHRcdGlmIChfZG9jLmNyZWF0ZUVsZW1lbnROUyAmJiAhZm9yY2UpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9lc24ndCBzdXBwb3J0IFNWRyBhbnl3YXlcblx0XHRcdFx0XHRzdmcgPSBfY3JlYXRlU1ZHKFwic3ZnXCIsIF9kb2NFbGVtZW50KTtcblx0XHRcdFx0XHRyZWN0ID0gX2NyZWF0ZVNWRyhcInJlY3RcIiwgc3ZnLCB7d2lkdGg6MTAwLCBoZWlnaHQ6NTAsIHg6MTAwfSk7XG5cdFx0XHRcdFx0d2lkdGggPSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCI1MCUgNTAlXCI7XG5cdFx0XHRcdFx0cmVjdC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcInNjYWxlWCgwLjUpXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAod2lkdGggPT09IHJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggJiYgIShfaXNGaXJlZm94ICYmIF9zdXBwb3J0czNEKSk7IC8vbm90ZTogRmlyZWZveCBmYWlscyB0aGUgdGVzdCBldmVuIHRob3VnaCBpdCBkb2VzIHN1cHBvcnQgQ1NTIHRyYW5zZm9ybXMgaW4gM0QuIFNpbmNlIHdlIGNhbid0IHB1c2ggM0Qgc3R1ZmYgaW50byB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSwgd2UgZm9yY2UgRmlyZWZveCB0byBwYXNzIHRoZSB0ZXN0IGhlcmUgKGFzIGxvbmcgYXMgaXQgZG9lcyB0cnVseSBzdXBwb3J0IDNEKS5cblx0XHRcdFx0XHRfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChzdmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmb3JjZTtcblx0XHRcdH0pKCksXG5cdFx0XHRfcGFyc2VTVkdPcmlnaW4gPSBmdW5jdGlvbihlLCBsb2NhbCwgZGVjb3JhdGVlLCBhYnNvbHV0ZSwgc21vb3RoT3JpZ2luLCBza2lwUmVjb3JkKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtLFxuXHRcdFx0XHRcdG0gPSBfZ2V0TWF0cml4KGUsIHRydWUpLFxuXHRcdFx0XHRcdHYsIHgsIHksIHhPcmlnaW4sIHlPcmlnaW4sIGEsIGIsIGMsIGQsIHR4LCB0eSwgZGV0ZXJtaW5hbnQsIHhPcmlnaW5PbGQsIHlPcmlnaW5PbGQ7XG5cdFx0XHRcdGlmICh0bSkge1xuXHRcdFx0XHRcdHhPcmlnaW5PbGQgPSB0bS54T3JpZ2luOyAvL3JlY29yZCB0aGUgb3JpZ2luYWwgdmFsdWVzIGJlZm9yZSB3ZSBhbHRlciB0aGVtLlxuXHRcdFx0XHRcdHlPcmlnaW5PbGQgPSB0bS55T3JpZ2luO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYWJzb2x1dGUgfHwgKHYgPSBhYnNvbHV0ZS5zcGxpdChcIiBcIikpLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0XHRiID0gZS5nZXRCQm94KCk7XG5cdFx0XHRcdFx0aWYgKGIueCA9PT0gMCAmJiBiLnkgPT09IDAgJiYgYi53aWR0aCArIGIuaGVpZ2h0ID09PSAwKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSBtaXNyZXBvcnQgdGhlIGJvdW5kcyBpZiB0aGUgZWxlbWVudCBoYXMgemVybyB3aWR0aCBhbmQgaGVpZ2h0IChpdCBqdXN0IGFzc3VtZXMgaXQncyBhdCB4OjAsIHk6MCksIHRodXMgd2UgbmVlZCB0byBtYW51YWxseSBncmFiIHRoZSBwb3NpdGlvbiBpbiB0aGF0IGNhc2UuXG5cdFx0XHRcdFx0XHRiID0ge3g6IHBhcnNlRmxvYXQoZS5oYXNBdHRyaWJ1dGUoXCJ4XCIpID8gZS5nZXRBdHRyaWJ1dGUoXCJ4XCIpIDogZS5oYXNBdHRyaWJ1dGUoXCJjeFwiKSA/IGUuZ2V0QXR0cmlidXRlKFwiY3hcIikgOiAwKSB8fCAwLCB5OiBwYXJzZUZsb2F0KGUuaGFzQXR0cmlidXRlKFwieVwiKSA/IGUuZ2V0QXR0cmlidXRlKFwieVwiKSA6IGUuaGFzQXR0cmlidXRlKFwiY3lcIikgPyBlLmdldEF0dHJpYnV0ZShcImN5XCIpIDogMCkgfHwgMCwgd2lkdGg6MCwgaGVpZ2h0OjB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsb2NhbCA9IF9wYXJzZVBvc2l0aW9uKGxvY2FsKS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0diA9IFsobG9jYWxbMF0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFswXSkgLyAxMDAgKiBiLndpZHRoIDogcGFyc2VGbG9hdChsb2NhbFswXSkpICsgYi54LFxuXHRcdFx0XHRcdFx0IChsb2NhbFsxXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEgPyBwYXJzZUZsb2F0KGxvY2FsWzFdKSAvIDEwMCAqIGIuaGVpZ2h0IDogcGFyc2VGbG9hdChsb2NhbFsxXSkpICsgYi55XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWNvcmF0ZWUueE9yaWdpbiA9IHhPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMF0pO1xuXHRcdFx0XHRkZWNvcmF0ZWUueU9yaWdpbiA9IHlPcmlnaW4gPSBwYXJzZUZsb2F0KHZbMV0pO1xuXHRcdFx0XHRpZiAoYWJzb2x1dGUgJiYgbSAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHsgLy9pZiBzdmdPcmlnaW4gaXMgYmVpbmcgc2V0LCB3ZSBtdXN0IGludmVydCB0aGUgbWF0cml4IGFuZCBkZXRlcm1pbmUgd2hlcmUgdGhlIGFic29sdXRlIHBvaW50IGlzLCBmYWN0b3JpbmcgaW4gdGhlIGN1cnJlbnQgdHJhbnNmb3Jtcy4gT3RoZXJ3aXNlLCB0aGUgc3ZnT3JpZ2luIHdvdWxkIGJlIGJhc2VkIG9uIHRoZSBlbGVtZW50J3Mgbm9uLXRyYW5zZm9ybWVkIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuXG5cdFx0XHRcdFx0YSA9IG1bMF07XG5cdFx0XHRcdFx0YiA9IG1bMV07XG5cdFx0XHRcdFx0YyA9IG1bMl07XG5cdFx0XHRcdFx0ZCA9IG1bM107XG5cdFx0XHRcdFx0dHggPSBtWzRdO1xuXHRcdFx0XHRcdHR5ID0gbVs1XTtcblx0XHRcdFx0XHRkZXRlcm1pbmFudCA9IChhICogZCAtIGIgKiBjKTtcblx0XHRcdFx0XHRpZiAoZGV0ZXJtaW5hbnQpIHsgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG5cdFx0XHRcdFx0XHR4ID0geE9yaWdpbiAqIChkIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqICgtYyAvIGRldGVybWluYW50KSArICgoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdFx0XHRcdHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQpO1xuXHRcdFx0XHRcdFx0eE9yaWdpbiA9IGRlY29yYXRlZS54T3JpZ2luID0gdlswXSA9IHg7XG5cdFx0XHRcdFx0XHR5T3JpZ2luID0gZGVjb3JhdGVlLnlPcmlnaW4gPSB2WzFdID0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRtKSB7IC8vYXZvaWQganVtcCB3aGVuIHRyYW5zZm9ybU9yaWdpbiBpcyBjaGFuZ2VkIC0gYWRqdXN0IHRoZSB4L3kgdmFsdWVzIGFjY29yZGluZ2x5XG5cdFx0XHRcdFx0aWYgKHNraXBSZWNvcmQpIHtcblx0XHRcdFx0XHRcdGRlY29yYXRlZS54T2Zmc2V0ID0gdG0ueE9mZnNldDtcblx0XHRcdFx0XHRcdGRlY29yYXRlZS55T2Zmc2V0ID0gdG0ueU9mZnNldDtcblx0XHRcdFx0XHRcdHRtID0gZGVjb3JhdGVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc21vb3RoT3JpZ2luIHx8IChzbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIENTU1BsdWdpbi5kZWZhdWx0U21vb3RoT3JpZ2luICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcblx0XHRcdFx0XHRcdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcblx0XHRcdFx0XHRcdC8vb3JpZ2luYWxseSwgd2Ugc2ltcGx5IGFkanVzdGVkIHRoZSB4IGFuZCB5IHZhbHVlcywgYnV0IHRoYXQgd291bGQgY2F1c2UgcHJvYmxlbXMgaWYsIGZvciBleGFtcGxlLCB5b3UgY3JlYXRlZCBhIHJvdGF0aW9uYWwgdHdlZW4gcGFydC13YXkgdGhyb3VnaCBhbiB4L3kgdHdlZW4uIE1hbmFnaW5nIHRoZSBvZmZzZXQgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSBnaXZlcyB1cyB1bHRpbWF0ZSBmbGV4aWJpbGl0eS5cblx0XHRcdFx0XHRcdC8vdG0ueCAtPSB4IC0gKHggKiBtWzBdICsgeSAqIG1bMl0pO1xuXHRcdFx0XHRcdFx0Ly90bS55IC09IHkgLSAoeCAqIG1bMV0gKyB5ICogbVszXSk7XG5cdFx0XHRcdFx0XHR0bS54T2Zmc2V0ICs9ICh4ICogbVswXSArIHkgKiBtWzJdKSAtIHg7XG5cdFx0XHRcdFx0XHR0bS55T2Zmc2V0ICs9ICh4ICogbVsxXSArIHkgKiBtWzNdKSAtIHk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRtLnhPZmZzZXQgPSB0bS55T2Zmc2V0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwUmVjb3JkKSB7XG5cdFx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiwgdi5qb2luKFwiIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfZ2V0QkJveEhhY2sgPSBmdW5jdGlvbihzd2FwSWZQb3NzaWJsZSkgeyAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuXHRcdFx0XHR2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcblx0XHRcdFx0XHRvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0b2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRcdFx0b2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRcdGJib3g7XG5cdFx0XHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcblx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0XHRpZiAoc3dhcElmUG9zc2libGUpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxHZXRCQm94ID0gdGhpcy5nZXRCQm94O1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHsgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX29yaWdpbmFsR2V0QkJveCkge1xuXHRcdFx0XHRcdGJib3ggPSB0aGlzLl9vcmlnaW5hbEdldEJCb3goKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2xkU2libGluZykge1xuXHRcdFx0XHRcdG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cdFx0XHRcdHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcblx0XHRcdFx0cmV0dXJuIGJib3g7XG5cdFx0XHR9LFxuXHRcdFx0X2dldEJCb3ggPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGUuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2dldEJCb3hIYWNrLmNhbGwoZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfaXNTVkcgPSBmdW5jdGlvbihlKSB7IC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5cdFx0XHRcdHJldHVybiAhIShfU1ZHRWxlbWVudCAmJiBlLmdldENUTSAmJiBfZ2V0QkJveChlKSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkpO1xuXHRcdFx0fSxcblx0XHRcdF9pZGVudGl0eTJETWF0cml4ID0gWzEsMCwwLDEsMCwwXSxcblx0XHRcdF9nZXRNYXRyaXggPSBmdW5jdGlvbihlLCBmb3JjZTJEKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0c3R5bGUgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGlzRGVmYXVsdCwgcywgbSwgbiwgZGVjLCBub25lO1xuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFLCB3ZSBuZWVkIHRvIGludGVycHJldCB0aGUgZmlsdGVyIHBvcnRpb24gdGhhdCBpcyBpbiB0aGUgZm9ybWF0OiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT02LjEyMzIzMzk5NTczNjc2NmUtMTcsIE0xMj0tMSwgTTIxPTEsIE0yMj02LjEyMzIzMzk5NTczNjc2NmUtMTcsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSBOb3RpY2UgdGhhdCB3ZSBuZWVkIHRvIHN3YXAgYiBhbmQgYyBjb21wYXJlZCB0byBhIG5vcm1hbCBtYXRyaXguXG5cdFx0XHRcdFx0cyA9IGUuY3VycmVudFN0eWxlLmZpbHRlci5tYXRjaChfaWVHZXRNYXRyaXhFeHApO1xuXHRcdFx0XHRcdHMgPSAocyAmJiBzLmxlbmd0aCA9PT0gNCkgPyBbc1swXS5zdWJzdHIoNCksIE51bWJlcihzWzJdLnN1YnN0cig0KSksIE51bWJlcihzWzFdLnN1YnN0cig0KSksIHNbM10uc3Vic3RyKDQpLCAodG0ueCB8fCAwKSwgKHRtLnkgfHwgMCldLmpvaW4oXCIsXCIpIDogXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgX3RyYW5zZm9ybVByb3AgJiYgKChub25lID0gKF9nZXRDb21wdXRlZFN0eWxlKGUpLmRpc3BsYXkgPT09IFwibm9uZVwiKSkgfHwgIWUucGFyZW50Tm9kZSkpIHtcblx0XHRcdFx0XHRpZiAobm9uZSkgeyAvL2Jyb3dzZXJzIGRvbid0IHJlcG9ydCB0cmFuc2Zvcm1zIGFjY3VyYXRlbHkgdW5sZXNzIHRoZSBlbGVtZW50IGlzIGluIHRoZSBET00gYW5kIGhhcyBhIGRpc3BsYXkgdmFsdWUgdGhhdCdzIG5vdCBcIm5vbmVcIi5cblx0XHRcdFx0XHRcdG4gPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFlLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRcdGRlYyA9IDE7IC8vZmxhZ1xuXHRcdFx0XHRcdFx0X2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHMgPSBfZ2V0U3R5bGUoZSwgX3RyYW5zZm9ybVByb3BDU1MsIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdGlzRGVmYXVsdCA9ICghcyB8fCBzID09PSBcIm5vbmVcIiB8fCBzID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiKTtcblx0XHRcdFx0XHRpZiAobikge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IG47XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub25lKSB7XG5cdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzdHlsZSwgXCJkaXNwbGF5XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGVjKSB7XG5cdFx0XHRcdFx0XHRfZG9jRWxlbWVudC5yZW1vdmVDaGlsZChlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRtLnN2ZyB8fCAoZS5nZXRDVE0gJiYgX2lzU1ZHKGUpKSkge1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgKHN0eWxlW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmluZGV4T2YoXCJtYXRyaXhcIikgIT09IC0xKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUgNDApIGRvbid0IGNvcnJlY3RseSByZXBvcnQgdHJhbnNmb3JtcyB0aGF0IGFyZSBhcHBsaWVkIGlubGluZSBvbiBhbiBTVkcgZWxlbWVudCAodGhleSBkb24ndCBnZXQgaW5jbHVkZWQgaW4gdGhlIGNvbXB1dGVkIHN0eWxlKSwgc28gd2UgZG91YmxlLWNoZWNrIGhlcmUgYW5kIGFjY2VwdCBtYXRyaXggdmFsdWVzXG5cdFx0XHRcdFx0XHRzID0gc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuXHRcdFx0XHRcdFx0aXNEZWZhdWx0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bSA9IGUuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RlZmF1bHQgJiYgbSkge1xuXHRcdFx0XHRcdFx0aWYgKG0uaW5kZXhPZihcIm1hdHJpeFwiKSAhPT0gLTEpIHsgLy9qdXN0IGluIGNhc2UgdGhlcmUncyBhIFwidHJhbnNmb3JtXCIgdmFsdWUgc3BlY2lmaWVkIGFzIGFuIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIENTUyBzdHlsZS4gQWNjZXB0IGVpdGhlciBhIG1hdHJpeCgpIG9yIHNpbXBsZSB0cmFuc2xhdGUoKSB2YWx1ZSB0aG91Z2guXG5cdFx0XHRcdFx0XHRcdHMgPSBtO1xuXHRcdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtLmluZGV4T2YoXCJ0cmFuc2xhdGVcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHMgPSBcIm1hdHJpeCgxLDAsMCwxLFwiICsgbS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKS5qb2luKFwiLFwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRpc0RlZmF1bHQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNEZWZhdWx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9pZGVudGl0eTJETWF0cml4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vc3BsaXQgdGhlIG1hdHJpeCB2YWx1ZXMgb3V0IGludG8gYW4gYXJyYXkgKG0gZm9yIG1hdHJpeClcblx0XHRcdFx0bSA9IChzIHx8IFwiXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuXHRcdFx0XHRpID0gbS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdG4gPSBOdW1iZXIobVtpXSk7XG5cdFx0XHRcdFx0bVtpXSA9IChkZWMgPSBuIC0gKG4gfD0gMCkpID8gKChkZWMgKiBybmQgKyAoZGVjIDwgMCA/IC0wLjUgOiAwLjUpKSB8IDApIC8gcm5kICsgbiA6IG47IC8vY29udmVydCBzdHJpbmdzIHRvIE51bWJlcnMgYW5kIHJvdW5kIHRvIDUgZGVjaW1hbCBwbGFjZXMgdG8gYXZvaWQgaXNzdWVzIHdpdGggdGlueSBudW1iZXJzLiBSb3VnaGx5IDIweCBmYXN0ZXIgdGhhbiBOdW1iZXIudG9GaXhlZCgpLiBXZSBhbHNvIG11c3QgbWFrZSBzdXJlIHRvIHJvdW5kIGJlZm9yZSBkaXZpZGluZyBzbyB0aGF0IHZhbHVlcyBsaWtlIDAuOTk5OTk5OTk5OSBiZWNvbWUgMSB0byBhdm9pZCBnbGl0Y2hlcyBpbiBicm93c2VyIHJlbmRlcmluZyBhbmQgaW50ZXJwcmV0YXRpb24gb2YgZmxpcHBlZC9yb3RhdGVkIDNEIG1hdHJpY2VzLiBBbmQgZG9uJ3QganVzdCBtdWx0aXBseSB0aGUgbnVtYmVyIGJ5IHJuZCwgZmxvb3IgaXQsIGFuZCB0aGVuIGRpdmlkZSBieSBybmQgYmVjYXVzZSB0aGUgYml0d2lzZSBvcGVyYXRpb25zIG1heCBvdXQgYXQgYSAzMi1iaXQgc2lnbmVkIGludGVnZXIsIHRodXMgaXQgY291bGQgZ2V0IGNsaXBwZWQgYXQgYSByZWxhdGl2ZWx5IGxvdyB2YWx1ZSAobGlrZSAyMiwwMDAuMDAwMDAgZm9yIGV4YW1wbGUpLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoZm9yY2UyRCAmJiBtLmxlbmd0aCA+IDYpID8gW21bMF0sIG1bMV0sIG1bNF0sIG1bNV0sIG1bMTJdLCBtWzEzXV0gOiBtO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYXJzZXMgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgZm9yIGFuIGVsZW1lbnQsIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCB4LCB5LCB6LCBzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCByb3RhdGlvbiwgcm90YXRpb25YLCByb3RhdGlvblksIHNrZXdYLCBhbmQgc2tld1kgcHJvcGVydGllcy4gTm90ZTogYnkgZGVmYXVsdCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBhbGwgc2tld2luZyBpcyBjb21iaW5lZCBpbnRvIHNrZXdYIGFuZCByb3RhdGlvbiBidXQgc2tld1kgc3RpbGwgaGFzIGEgcGxhY2UgaW4gdGhlIHRyYW5zZm9ybSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVjb3JkIGhvdyBtdWNoIG9mIHRoZSBza2V3IGlzIGF0dHJpYnV0ZWQgdG8gc2tld1ggdnMgc2tld1kuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgYW5kIHNrZXdYIG9mIC0xMC5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBjcyBjb21wdXRlZCBzdHlsZSBvYmplY3QgKG9wdGlvbmFsKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjIGlmIHRydWUsIHRoZSB0cmFuc2Zvcm0gdmFsdWVzIHdpbGwgYmUgcmVjb3JkZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50J3MgX2dzVHJhbnNmb3JtIG9iamVjdCwgbGlrZSB0YXJnZXQuX2dzVHJhbnNmb3JtID0ge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcGFyc2UgaWYgdHJ1ZSwgd2UnbGwgaWdub3JlIGFueSBfZ3NUcmFuc2Zvcm0gdmFsdWVzIHRoYXQgYWxyZWFkeSBleGlzdCBvbiB0aGUgZWxlbWVudCwgYW5kIGZvcmNlIGEgcmVwYXJzaW5nIG9mIHRoZSBjc3MgKGNhbGN1bGF0ZWQgc3R5bGUpXG5cdFx0XHQgKiBAcmV0dXJuIHtvYmplY3R9IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMvdmFsdWVzIGxpa2Uge3g6MCwgeTowLCB6OjAsIHNjYWxlWDoxLi4ufVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0VHJhbnNmb3JtID0gX2ludGVybmFscy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih0LCBjcywgcmVjLCBwYXJzZSkge1xuXHRcdFx0XHRpZiAodC5fZ3NUcmFuc2Zvcm0gJiYgcmVjICYmICFwYXJzZSkge1xuXHRcdFx0XHRcdHJldHVybiB0Ll9nc1RyYW5zZm9ybTsgLy9pZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyBhIF9nc1RyYW5zZm9ybSwgdXNlIHRoYXQuIE5vdGU6IHNvbWUgYnJvd3NlcnMgZG9uJ3QgYWNjdXJhdGVseSByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgc3R5bGUgZm9yIHRoZSB0cmFuc2Zvcm0gKHBhcnRpY3VsYXJseSBmb3IgU1ZHKSwgc28gaXQncyBhbG1vc3QgYWx3YXlzIHNhZmVzdCB0byBqdXN0IHVzZSB0aGUgdmFsdWVzIHdlJ3ZlIGFscmVhZHkgYXBwbGllZCByYXRoZXIgdGhhbiByZS1wYXJzaW5nIHRoaW5ncy5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdG0gPSByZWMgPyB0Ll9nc1RyYW5zZm9ybSB8fCBuZXcgVHJhbnNmb3JtKCkgOiBuZXcgVHJhbnNmb3JtKCksXG5cdFx0XHRcdFx0aW52WCA9ICh0bS5zY2FsZVggPCAwKSwgLy9pbiBvcmRlciB0byBpbnRlcnByZXQgdGhpbmdzIHByb3Blcmx5LCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlIHVzZXIgYXBwbGllZCBhIG5lZ2F0aXZlIHNjYWxlWCBwcmV2aW91c2x5IHNvIHRoYXQgd2UgY2FuIGFkanVzdCB0aGUgcm90YXRpb24gYW5kIHNrZXdYIGFjY29yZGluZ2x5LiBPdGhlcndpc2UsIGlmIHdlIGFsd2F5cyBpbnRlcnByZXQgYSBmbGlwcGVkIG1hdHJpeCBhcyBhZmZlY3Rpbmcgc2NhbGVZIGFuZCB0aGUgdXNlciBvbmx5IHdhbnRzIHRvIHR3ZWVuIHRoZSBzY2FsZVggb24gbXVsdGlwbGUgc2VxdWVudGlhbCB0d2VlbnMsIGl0IHdvdWxkIGtlZXAgdGhlIG5lZ2F0aXZlIHNjYWxlWSB3aXRob3V0IHRoYXQgYmVpbmcgdGhlIHVzZXIncyBpbnRlbnQuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMixcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0ek9yaWdpbiA9IF9zdXBwb3J0czNEID8gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pIHx8IHRtLnpPcmlnaW4gIHx8IDAgOiAwLFxuXHRcdFx0XHRcdGRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBhcnNlRmxvYXQoQ1NTUGx1Z2luLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSkgfHwgMCxcblx0XHRcdFx0XHRtLCBpLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYO1xuXG5cdFx0XHRcdHRtLnN2ZyA9ICEhKHQuZ2V0Q1RNICYmIF9pc1NWRyh0KSk7XG5cdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX2dldFN0eWxlKHQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBjcywgZmFsc2UsIFwiNTAlIDUwJVwiKSArIFwiXCIsIHRtLCB0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSk7XG5cdFx0XHRcdFx0X3VzZVNWR1RyYW5zZm9ybUF0dHIgPSBDU1NQbHVnaW4udXNlU1ZHVHJhbnNmb3JtQXR0ciB8fCBfZm9yY2VTVkdUcmFuc2Zvcm1BdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0gPSBfZ2V0TWF0cml4KHQpO1xuXHRcdFx0XHRpZiAobSAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcblxuXHRcdFx0XHRcdGlmIChtLmxlbmd0aCA9PT0gMTYpIHtcblx0XHRcdFx0XHRcdC8vd2UnbGwgb25seSBsb29rIGF0IHRoZXNlIHBvc2l0aW9uLXJlbGF0ZWQgNiB2YXJpYWJsZXMgZmlyc3QgYmVjYXVzZSBpZiB4L3kveiBhbGwgbWF0Y2gsIGl0J3MgcmVsYXRpdmVseSBzYWZlIHRvIGFzc3VtZSB3ZSBkb24ndCBuZWVkIHRvIHJlLXBhcnNlIGV2ZXJ5dGhpbmcgd2hpY2ggcmlza3MgbG9zaW5nIGltcG9ydGFudCByb3RhdGlvbmFsIGluZm9ybWF0aW9uIChsaWtlIHJvdGF0aW9uWDoxODAgcGx1cyByb3RhdGlvblk6MTgwIHdvdWxkIGxvb2sgdGhlIHNhbWUgYXMgcm90YXRpb246MTgwIC0gdGhlcmUncyBubyB3YXkgdG8ga25vdyBmb3Igc3VyZSB3aGljaCBkaXJlY3Rpb24gd2FzIHRha2VuIGJhc2VkIHNvbGVseSBvbiB0aGUgbWF0cml4M2QoKSB2YWx1ZXMpXG5cdFx0XHRcdFx0XHR2YXIgYTExID0gbVswXSwgYTIxID0gbVsxXSwgYTMxID0gbVsyXSwgYTQxID0gbVszXSxcblx0XHRcdFx0XHRcdFx0YTEyID0gbVs0XSwgYTIyID0gbVs1XSwgYTMyID0gbVs2XSwgYTQyID0gbVs3XSxcblx0XHRcdFx0XHRcdFx0YTEzID0gbVs4XSwgYTIzID0gbVs5XSwgYTMzID0gbVsxMF0sXG5cdFx0XHRcdFx0XHRcdGExNCA9IG1bMTJdLCBhMjQgPSBtWzEzXSwgYTM0ID0gbVsxNF0sXG5cdFx0XHRcdFx0XHRcdGE0MyA9IG1bMTFdLFxuXHRcdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTMyLCBhMzMpLFxuXHRcdFx0XHRcdFx0XHR0MSwgdDIsIHQzLCB0NCwgY29zLCBzaW47XG5cblx0XHRcdFx0XHRcdC8vd2UgbWFudWFsbHkgY29tcGVuc2F0ZSBmb3Igbm9uLXplcm8geiBjb21wb25lbnQgb2YgdHJhbnNmb3JtT3JpZ2luIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gU2FmYXJpXG5cdFx0XHRcdFx0XHRpZiAodG0uek9yaWdpbikge1xuXHRcdFx0XHRcdFx0XHRhMzQgPSAtdG0uek9yaWdpbjtcblx0XHRcdFx0XHRcdFx0YTE0ID0gYTEzKmEzNC1tWzEyXTtcblx0XHRcdFx0XHRcdFx0YTI0ID0gYTIzKmEzNC1tWzEzXTtcblx0XHRcdFx0XHRcdFx0YTM0ID0gYTMzKmEzNCt0bS56T3JpZ2luLW1bMTRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdC8vcm90YXRpb25YXG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTIqY29zK2ExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMipjb3MrYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTEzID0gYTEyKi1zaW4rYTEzKmNvcztcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIyKi1zaW4rYTIzKmNvcztcblx0XHRcdFx0XHRcdFx0YTMzID0gYTMyKi1zaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQyKi1zaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTEyID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzIgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25ZXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWEzMSwgYTMzKTtcblx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblx0XHRcdFx0XHRcdFx0dDEgPSBhMTEqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdHQyID0gYTIxKmNvcy1hMjMqc2luO1xuXHRcdFx0XHRcdFx0XHR0MyA9IGEzMSpjb3MtYTMzKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIzID0gYTIxKnNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzEqc2luK2EzMypjb3M7XG5cdFx0XHRcdFx0XHRcdGE0MyA9IGE0MSpzaW4rYTQzKmNvcztcblx0XHRcdFx0XHRcdFx0YTExID0gdDE7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0XHRhMzEgPSB0Mztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRpb25aXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoYTIxLCBhMTEpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0aWYgKGFuZ2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cdFx0XHRcdFx0XHRcdGExMSA9IGExMSpjb3MrYTEyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zK2EyMipzaW47XG5cdFx0XHRcdFx0XHRcdGEyMiA9IGEyMSotc2luK2EyMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IGEzMSotc2luK2EzMipjb3M7XG5cdFx0XHRcdFx0XHRcdGEyMSA9IHQyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodG0ucm90YXRpb25YICYmIE1hdGguYWJzKHRtLnJvdGF0aW9uWCkgKyBNYXRoLmFicyh0bS5yb3RhdGlvbikgPiAzNTkuOSkgeyAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblkgPSAxODAgLSB0bS5yb3RhdGlvblk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9ICgoTWF0aC5zcXJ0KGExMSAqIGExMSArIGEyMSAqIGEyMSkgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSAoKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMjMgKiBhMjMpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gKChNYXRoLnNxcnQoYTMyICogYTMyICsgYTMzICogYTMzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdGlmICh0bS5yb3RhdGlvblggfHwgdG0ucm90YXRpb25ZKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnNrZXdYID0gMDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRtLnNrZXdYID0gKGExMiB8fCBhMjIpID8gTWF0aC5hdGFuMihhMTIsIGEyMikgKiBfUkFEMkRFRyArIHRtLnJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKHRtLnNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHRtLnNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnZYKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bS5zY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb24gKz0gKHRtLnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0dG0uc2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHRcdFx0dG0uc2tld1ggKz0gKHRtLnNrZXdYIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gYTQzID8gMSAvICgoYTQzIDwgMCkgPyAtYTQzIDogYTQzKSA6IDA7XG5cdFx0XHRcdFx0XHR0bS54ID0gYTE0O1xuXHRcdFx0XHRcdFx0dG0ueSA9IGEyNDtcblx0XHRcdFx0XHRcdHRtLnogPSBhMzQ7XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYTExIC0gdG0ueU9yaWdpbiAqIGExMik7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS55T3JpZ2luICogYTIxIC0gdG0ueE9yaWdpbiAqIGEyMik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCghX3N1cHBvcnRzM0QgfHwgcGFyc2UgfHwgIW0ubGVuZ3RoIHx8IHRtLnggIT09IG1bNF0gfHwgdG0ueSAhPT0gbVs1XSB8fCAoIXRtLnJvdGF0aW9uWCAmJiAhdG0ucm90YXRpb25ZKSkpIHsgLy9zb21ldGltZXMgYSA2LWVsZW1lbnQgbWF0cml4IGlzIHJldHVybmVkIGV2ZW4gd2hlbiB3ZSBwZXJmb3JtZWQgM0QgdHJhbnNmb3JtcywgbGlrZSBpZiByb3RhdGlvblggYW5kIHJvdGF0aW9uWSBhcmUgMTgwLiBJbiBjYXNlcyBsaWtlIHRoaXMsIHdlIHN0aWxsIG5lZWQgdG8gaG9ub3IgdGhlIDNEIHRyYW5zZm9ybXMuIElmIHdlIGp1c3QgcmVseSBvbiB0aGUgMkQgaW5mbywgaXQgY291bGQgYWZmZWN0IGhvdyB0aGUgZGF0YSBpcyBpbnRlcnByZXRlZCwgbGlrZSBzY2FsZVkgbWlnaHQgZ2V0IHNldCB0byAtMSBvciByb3RhdGlvbiBjb3VsZCBnZXQgb2Zmc2V0IGJ5IDE4MCBkZWdyZWVzLiBGb3IgZXhhbXBsZSwgZG8gYSBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjE4MCwgcm90YXRpb25ZOjE4MH19KSBhbmQgdGhlbiBsYXRlciwgVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e3JvdGF0aW9uWDowfX0pIGFuZCB3aXRob3V0IHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW4gcGxhY2UsIGl0J2QganVtcCB0byBhIHN0YXRlIG9mIGJlaW5nIHVucm90YXRlZCB3aGVuIHRoZSAybmQgdHdlZW4gc3RhcnRzLiBUaGVuIGFnYWluLCB3ZSBuZWVkIHRvIGhvbm9yIHRoZSBmYWN0IHRoYXQgdGhlIHVzZXIgQ09VTEQgYWx0ZXIgdGhlIHRyYW5zZm9ybXMgb3V0c2lkZSBvZiBDU1NQbHVnaW4sIGxpa2UgYnkgbWFudWFsbHkgYXBwbHlpbmcgbmV3IGNzcywgc28gd2UgdHJ5IHRvIHNlbnNlIHRoYXQgYnkgbG9va2luZyBhdCB4IGFuZCB5IGJlY2F1c2UgaWYgdGhvc2UgY2hhbmdlZCwgd2Uga25vdyB0aGUgY2hhbmdlcyB3ZXJlIG1hZGUgb3V0c2lkZSBDU1NQbHVnaW4gYW5kIHdlIGZvcmNlIGEgcmVpbnRlcnByZXRhdGlvbiBvZiB0aGUgbWF0cml4IHZhbHVlcy4gQWxzbywgaW4gV2Via2l0IGJyb3dzZXJzLCBpZiB0aGUgZWxlbWVudCdzIFwiZGlzcGxheVwiIGlzIFwibm9uZVwiLCBpdHMgY2FsY3VsYXRlZCBzdHlsZSB2YWx1ZSB3aWxsIGFsd2F5cyByZXR1cm4gZW1wdHksIHNvIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlIHZhbHVlcyBpbiB0aGUgX2dzVHJhbnNmb3JtIG9iamVjdCwgd2UnbGwganVzdCByZWx5IG9uIHRob3NlLlxuXHRcdFx0XHRcdFx0dmFyIGsgPSAobS5sZW5ndGggPj0gNiksXG5cdFx0XHRcdFx0XHRcdGEgPSBrID8gbVswXSA6IDEsXG5cdFx0XHRcdFx0XHRcdGIgPSBtWzFdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGMgPSBtWzJdIHx8IDAsXG5cdFx0XHRcdFx0XHRcdGQgPSBrID8gbVszXSA6IDE7XG5cdFx0XHRcdFx0XHR0bS54ID0gbVs0XSB8fCAwO1xuXHRcdFx0XHRcdFx0dG0ueSA9IG1bNV0gfHwgMDtcblx0XHRcdFx0XHRcdHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdFx0XHRcdHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcblx0XHRcdFx0XHRcdHJvdGF0aW9uID0gKGEgfHwgYikgPyBNYXRoLmF0YW4yKGIsIGEpICogX1JBRDJERUcgOiB0bS5yb3RhdGlvbiB8fCAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXHRcdFx0XHRcdFx0c2tld1ggPSAoYyB8fCBkKSA/IE1hdGguYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogdG0uc2tld1ggfHwgMDtcblx0XHRcdFx0XHRcdGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0XHRzY2FsZVggKj0gLTE7XG5cdFx0XHRcdFx0XHRcdFx0c2tld1ggKz0gKHJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdFx0XHRcdFx0XHRyb3RhdGlvbiArPSAocm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNjYWxlWSAqPSAtMTtcblx0XHRcdFx0XHRcdFx0XHRza2V3WCArPSAoc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVggPSBzY2FsZVg7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSBzY2FsZVk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0XHRcdFx0dG0uc2tld1ggPSBza2V3WDtcblx0XHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvblkgPSB0bS56ID0gMDtcblx0XHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBkZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmU7XG5cdFx0XHRcdFx0XHRcdHRtLnNjYWxlWiA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodG0uc3ZnKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnggLT0gdG0ueE9yaWdpbiAtICh0bS54T3JpZ2luICogYSArIHRtLnlPcmlnaW4gKiBjKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBiICsgdG0ueU9yaWdpbiAqIGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKyBcIiwgb3JpZ2luOiBcIisgdG0ueE9yaWdpbisgXCIsXCIrIHRtLnlPcmlnaW4pO1xuXHRcdFx0XHRpZiAocmVjKSB7XG5cdFx0XHRcdFx0dC5fZ3NUcmFuc2Zvcm0gPSB0bTsgLy9yZWNvcmQgdG8gdGhlIG9iamVjdCdzIF9nc1RyYW5zZm9ybSB3aGljaCB3ZSB1c2Ugc28gdGhhdCB0d2VlbnMgY2FuIGNvbnRyb2wgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkgKHdlIG5lZWQgYWxsIHRoZSBwcm9wZXJ0aWVzIHRvIGFjY3VyYXRlbHkgcmVjb21wb3NlIHRoZSBtYXRyaXggaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKVxuXHRcdFx0XHRcdGlmICh0bS5zdmcpIHsgLy9pZiB3ZSdyZSBzdXBwb3NlZCB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHRoZSBTVkcgZWxlbWVudCdzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBtYWtlIHN1cmUgdGhlcmUgYXJlbid0IGFueSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9yIHRoZXknbGwgb3ZlcnJpZGUgdGhlIGF0dHJpYnV0ZSBvbmVzLiBBbHNvIGNsZWFyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIENTUywganVzdCB0byBiZSBjbGVhbi5cblx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7IC8vaWYgd2UgYXBwbHkgdGhpcyByaWdodCBhd2F5IChiZWZvcmUgYW55dGhpbmcgaGFzIHJlbmRlcmVkKSwgd2UgcmlzayB0aGVyZSBiZWluZyBubyB0cmFuc2Zvcm1zIGZvciBhIGJyaWVmIG1vbWVudCBhbmQgaXQgYWxzbyBpbnRlcmZlcmVzIHdpdGggYWRqdXN0aW5nIHRoZSB0cmFuc2Zvcm1PcmlnaW4gaW4gYSB0d2VlbiB3aXRoIGltbWVkaWF0ZVJlbmRlcjp0cnVlIChpdCdkIHRyeSByZWFkaW5nIHRoZSBtYXRyaXggYW5kIGl0IHdvdWxkbid0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgaW4gcGxhY2UgYmVjYXVzZSB3ZSBqdXN0IHJlbW92ZWQgaXQpLlxuXHRcdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHQuc3R5bGUsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2ZvciBzZXR0aW5nIDJEIHRyYW5zZm9ybXMgaW4gSUU2LCBJRTcsIGFuZCBJRTggKG11c3QgdXNlIGEgXCJmaWx0ZXJcIiB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciBvZiBtb2Rlcm4gZGF5IGJyb3dzZXIgdHJhbnNmb3Jtcylcblx0XHRcdF9zZXRJRVRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0YW5nID0gLXQucm90YXRpb24gKiBfREVHMlJBRCxcblx0XHRcdFx0XHRza2V3ID0gYW5nICsgdC5za2V3WCAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHRhID0gKChNYXRoLmNvcyhhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YiA9ICgoTWF0aC5zaW4oYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGMgPSAoKE1hdGguc2luKHNrZXcpICogLXQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGQgPSAoKE1hdGguY29zKHNrZXcpICogdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0Y3MgPSB0aGlzLnQuY3VycmVudFN0eWxlLFxuXHRcdFx0XHRcdGZpbHRlcnMsIHZhbDtcblx0XHRcdFx0aWYgKCFjcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWwgPSBiOyAvL2p1c3QgZm9yIHN3YXBwaW5nIHRoZSB2YXJpYWJsZXMgYW4gaW52ZXJ0aW5nIHRoZW0gKHJldXNlZCBcInZhbFwiIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXIgdmFyaWFibGUgaW4gbWVtb3J5KS4gSUUncyBmaWx0ZXIgbWF0cml4IHVzZXMgYSBub24tc3RhbmRhcmQgbWF0cml4IGNvbmZpZ3VyYXRpb24gKGFuZ2xlIGdvZXMgdGhlIG9wcG9zaXRlIHdheSwgYW5kIGIgYW5kIGMgYXJlIHJldmVyc2VkIGFuZCBpbnZlcnRlZClcblx0XHRcdFx0YiA9IC1jO1xuXHRcdFx0XHRjID0gLXZhbDtcblx0XHRcdFx0ZmlsdGVycyA9IGNzLmZpbHRlcjtcblx0XHRcdFx0c3R5bGUuZmlsdGVyID0gXCJcIjsgLy9yZW1vdmUgZmlsdGVycyBzbyB0aGF0IHdlIGNhbiBhY2N1cmF0ZWx5IG1lYXN1cmUgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdHZhciB3ID0gdGhpcy50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdGggPSB0aGlzLnQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGNsaXAgPSAoY3MucG9zaXRpb24gIT09IFwiYWJzb2x1dGVcIiksXG5cdFx0XHRcdFx0bSA9IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIgKyBhICsgXCIsIE0xMj1cIiArIGIgKyBcIiwgTTIxPVwiICsgYyArIFwiLCBNMjI9XCIgKyBkLFxuXHRcdFx0XHRcdG94ID0gdC54ICsgKHcgKiB0LnhQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRveSA9IHQueSArIChoICogdC55UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0ZHgsIGR5O1xuXG5cdFx0XHRcdC8vaWYgdHJhbnNmb3JtT3JpZ2luIGlzIGJlaW5nIHVzZWQsIGFkanVzdCB0aGUgb2Zmc2V0IHggYW5kIHlcblx0XHRcdFx0aWYgKHQub3ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGR4ID0gKCh0Lm94cCkgPyB3ICogdC5veCAqIDAuMDEgOiB0Lm94KSAtIHcgLyAyO1xuXHRcdFx0XHRcdGR5ID0gKCh0Lm95cCkgPyBoICogdC5veSAqIDAuMDEgOiB0Lm95KSAtIGggLyAyO1xuXHRcdFx0XHRcdG94ICs9IGR4IC0gKGR4ICogYSArIGR5ICogYik7XG5cdFx0XHRcdFx0b3kgKz0gZHkgLSAoZHggKiBjICsgZHkgKiBkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdG0gKz0gXCIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKVwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGR4ID0gKHcgLyAyKTtcblx0XHRcdFx0XHRkeSA9IChoIC8gMik7XG5cdFx0XHRcdFx0Ly90cmFuc2xhdGUgdG8gZW5zdXJlIHRoYXQgdHJhbnNmb3JtYXRpb25zIG9jY3VyIGFyb3VuZCB0aGUgY29ycmVjdCBvcmlnaW4gKGRlZmF1bHQgaXMgY2VudGVyKS5cblx0XHRcdFx0XHRtICs9IFwiLCBEeD1cIiArIChkeCAtIChkeCAqIGEgKyBkeSAqIGIpICsgb3gpICsgXCIsIER5PVwiICsgKGR5IC0gKGR4ICogYyArIGR5ICogZCkgKyBveSkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX2llU2V0TWF0cml4RXhwLCBtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBtICsgXCIgXCIgKyBmaWx0ZXJzOyAvL3dlIG11c3QgYWx3YXlzIHB1dCB0aGUgdHJhbnNmb3JtL21hdHJpeCBGSVJTVCAoYmVmb3JlIGFscGhhKG9wYWNpdHk9eHgpKSB0byBhdm9pZCBhbiBJRSBidWcgdGhhdCBzbGljZXMgcGFydCBvZiB0aGUgb2JqZWN0IHdoZW4gcm90YXRpb24gaXMgYXBwbGllZCB3aXRoIGFscGhhLlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9hdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4sIGlmIHRoZSBtYXRyaXggaXMgbm9ybWFsICgxLCAwLCAwLCAxKSBhbmQgb3BhY2l0eSBpcyAxMDAgKG9yIGRvZXNuJ3QgZXhpc3QpLCByZW1vdmUgdGhlIGZpbHRlciB0byBpbXByb3ZlIGJyb3dzZXIgcGVyZm9ybWFuY2UuXG5cdFx0XHRcdGlmICh2ID09PSAwIHx8IHYgPT09IDEpIGlmIChhID09PSAxKSBpZiAoYiA9PT0gMCkgaWYgKGMgPT09IDApIGlmIChkID09PSAxKSBpZiAoIWNsaXAgfHwgbS5pbmRleE9mKFwiRHg9MCwgRHk9MFwiKSAhPT0gLTEpIGlmICghX29wYWNpdHlFeHAudGVzdChmaWx0ZXJzKSB8fCBwYXJzZUZsb2F0KFJlZ0V4cC4kMSkgPT09IDEwMCkgaWYgKGZpbHRlcnMuaW5kZXhPZihcImdyYWRpZW50KFwiICYmIGZpbHRlcnMuaW5kZXhPZihcIkFscGhhXCIpKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3dlIG11c3Qgc2V0IHRoZSBtYXJnaW5zIEFGVEVSIGFwcGx5aW5nIHRoZSBmaWx0ZXIgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBidWdzIGluIElFOCB0aGF0IGNvdWxkIChpbiByYXJlIHNjZW5hcmlvcykgY2F1c2UgdGhlbSB0byBiZSBpZ25vcmVkIGludGVybWl0dGVudGx5ICh2aWJyYXRpb24pLlxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHR2YXIgbXVsdCA9IChfaWVWZXJzIDwgOCkgPyAxIDogLTEsIC8vaW4gSW50ZXJuZXQgRXhwbG9yZXIgNyBhbmQgYmVmb3JlLCB0aGUgYm94IG1vZGVsIGlzIGJyb2tlbiwgY2F1c2luZyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhY3R1YWwgcm90YXRlZCBmaWx0ZXJlZCBpbWFnZSBhcyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3ggaXRzZWxmLCBidXQgTWljcm9zb2Z0IGNvcnJlY3RlZCB0aGF0IGluIElFOC4gV2UgbXVzdCB1c2UgYSBuZWdhdGl2ZSBvZmZzZXQgaW4gSUU4IG9uIHRoZSByaWdodC9ib3R0b21cblx0XHRcdFx0XHRcdG1hcmcsIHByb3AsIGRpZjtcblx0XHRcdFx0XHRkeCA9IHQuaWVPZmZzZXRYIHx8IDA7XG5cdFx0XHRcdFx0ZHkgPSB0LmllT2Zmc2V0WSB8fCAwO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRYID0gTWF0aC5yb3VuZCgodyAtICgoYSA8IDAgPyAtYSA6IGEpICogdyArIChiIDwgMCA/IC1iIDogYikgKiBoKSkgLyAyICsgb3gpO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRZID0gTWF0aC5yb3VuZCgoaCAtICgoZCA8IDAgPyAtZCA6IGQpICogaCArIChjIDwgMCA/IC1jIDogYykgKiB3KSkgLyAyICsgb3kpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHByb3AgPSBfbWFyZ2luc1tpXTtcblx0XHRcdFx0XHRcdG1hcmcgPSBjc1twcm9wXTtcblx0XHRcdFx0XHRcdC8vd2UgbmVlZCB0byBnZXQgdGhlIGN1cnJlbnQgbWFyZ2luIGluIGNhc2UgaXQgaXMgYmVpbmcgdHdlZW5lZCBzZXBhcmF0ZWx5ICh3ZSB3YW50IHRvIHJlc3BlY3QgdGhhdCB0d2VlbidzIGNoYW5nZXMpXG5cdFx0XHRcdFx0XHR2YWwgPSAobWFyZy5pbmRleE9mKFwicHhcIikgIT09IC0xKSA/IHBhcnNlRmxvYXQobWFyZykgOiBfY29udmVydFRvUGl4ZWxzKHRoaXMudCwgcHJvcCwgcGFyc2VGbG9hdChtYXJnKSwgbWFyZy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdFtwcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gLXQuaWVPZmZzZXRYIDogLXQuaWVPZmZzZXRZOyAvL2lmIGFub3RoZXIgdHdlZW4gaXMgY29udHJvbGxpbmcgYSBtYXJnaW4sIHdlIGNhbm5vdCBvbmx5IGFwcGx5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBpZU9mZnNldHMsIHNvIHdlIGVzc2VudGlhbGx5IHplcm8tb3V0IHRoZSBkeCBhbmQgZHkgaGVyZSBpbiB0aGF0IGNhc2UuIFdlIHJlY29yZCB0aGUgbWFyZ2luKHMpIGxhdGVyIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29tcGFyaW5nIHRoZW0sIG1ha2luZyB0aGlzIGNvZGUgdmVyeSBmbGV4aWJsZS5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyBkeCAtIHQuaWVPZmZzZXRYIDogZHkgLSB0LmllT2Zmc2V0WTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gKHRbcHJvcF0gPSBNYXRoLnJvdW5kKCB2YWwgLSBkaWYgKiAoKGkgPT09IDAgfHwgaSA9PT0gMikgPyAxIDogbXVsdCkgKSkgKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiB0cmFuc2xhdGVzIGEgc3VwZXIgc21hbGwgZGVjaW1hbCB0byBhIHN0cmluZyBXSVRIT1VUIHNjaWVudGlmaWMgbm90YXRpb25cblx0XHRcdF9zYWZlRGVjaW1hbCA9IGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0dmFyIHMgPSAobiA8IDAgPyAtbiA6IG4pICsgXCJcIixcblx0XHRcdFx0XHRhID0gcy5zcGxpdChcImUtXCIpO1xuXHRcdFx0XHRyZXR1cm4gKG4gPCAwID8gXCItMC5cIiA6IFwiMC5cIikgKyBuZXcgQXJyYXkocGFyc2VJbnQoYVsxXSwgMTApIHx8IDApLmpvaW4oXCIwXCIpICsgYVswXS5zcGxpdChcIi5cIikuam9pbihcIlwiKTtcblx0XHRcdH0sXG5cdFx0XHQqL1xuXG5cdFx0XHRfc2V0VHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDNEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uLFxuXHRcdFx0XHRcdHJvdGF0aW9uWCA9IHQucm90YXRpb25YLFxuXHRcdFx0XHRcdHJvdGF0aW9uWSA9IHQucm90YXRpb25ZLFxuXHRcdFx0XHRcdHN4ID0gdC5zY2FsZVgsXG5cdFx0XHRcdFx0c3kgPSB0LnNjYWxlWSxcblx0XHRcdFx0XHRzeiA9IHQuc2NhbGVaLFxuXHRcdFx0XHRcdHggPSB0LngsXG5cdFx0XHRcdFx0eSA9IHQueSxcblx0XHRcdFx0XHR6ID0gdC56LFxuXHRcdFx0XHRcdGlzU1ZHID0gdC5zdmcsXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0LnBlcnNwZWN0aXZlLFxuXHRcdFx0XHRcdGZvcmNlM0QgPSB0LmZvcmNlM0QsXG5cdFx0XHRcdFx0c2tld1kgPSB0LnNrZXdZLFxuXHRcdFx0XHRcdHNrZXdYID0gdC5za2V3WCxcblx0XHRcdFx0XHR0MSxcdGExMSwgYTEyLCBhMTMsIGEyMSwgYTIyLCBhMjMsIGEzMSwgYTMyLCBhMzMsIGE0MSwgYTQyLCBhNDMsXG5cdFx0XHRcdFx0ek9yaWdpbiwgbWluLCBjb3MsIHNpbiwgdDIsIHRyYW5zZm9ybSwgY29tbWEsIHplcm8sIHNrZXcsIHJuZDtcblx0XHRcdFx0aWYgKHNrZXdZKSB7IC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG5cdFx0XHRcdFx0c2tld1ggKz0gc2tld1k7XG5cdFx0XHRcdFx0YW5nbGUgKz0gc2tld1k7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGFzIDJEIChhbmQgU1ZHcyBtdXN0IHVzZSAyRCB3aGVuIF91c2VTVkdUcmFuc2Zvcm1BdHRyIGlzIHRydWUpXG5cdFx0XHRcdGlmICgoKCgodiA9PT0gMSB8fCB2ID09PSAwKSAmJiBmb3JjZTNEID09PSBcImF1dG9cIiAmJiAodGhpcy50d2Vlbi5fdG90YWxUaW1lID09PSB0aGlzLnR3ZWVuLl90b3RhbER1cmF0aW9uIHx8ICF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpKSB8fCAhZm9yY2UzRCkgJiYgIXogJiYgIXBlcnNwZWN0aXZlICYmICFyb3RhdGlvblkgJiYgIXJvdGF0aW9uWCAmJiBzeiA9PT0gMSkgfHwgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIGlzU1ZHKSB8fCAhX3N1cHBvcnRzM0QpIHsgLy9vbiB0aGUgZmluYWwgcmVuZGVyICh3aGljaCBjb3VsZCBiZSAwIGZvciBhIGZyb20gdHdlZW4pLCBpZiB0aGVyZSBhcmUgbm8gM0QgYXNwZWN0cywgcmVuZGVyIGluIDJEIHRvIGZyZWUgdXAgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuIENoZWNrIHRoZSB0d2VlbidzIHRvdGFsVGltZS90b3RhbER1cmF0aW9uIHRvbyBpbiBvcmRlciB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXBwZW4gYmV0d2VlbiByZXBlYXRzIGlmIGl0J3MgYSByZXBlYXRpbmcgdHdlZW4uXG5cblx0XHRcdFx0XHQvLzJEXG5cdFx0XHRcdFx0aWYgKGFuZ2xlIHx8IHNrZXdYIHx8IGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRcdHNrZXcgPSBza2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdFx0YTExID0gTWF0aC5jb3MoYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMjEgPSBNYXRoLnNpbihhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGExMiA9IE1hdGguc2luKGFuZ2xlIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0XHRhMjIgPSBNYXRoLmNvcyhhbmdsZSAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tldyAtIHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGExMiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2tld1kpIHtcblx0XHRcdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0XHRhMTEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0YTIxICo9IHQxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcpIHtcblx0XHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKSArIHQueU9mZnNldDtcblx0XHRcdFx0XHRcdFx0aWYgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmICh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpKSB7IC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgbWF0cml4IHRvIHNpbXVsYXRlIGl0LlxuXHRcdFx0XHRcdFx0XHRcdG1pbiA9IHRoaXMudC5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHRcdFx0eCArPSB0LnhQZXJjZW50ICogMC4wMSAqIG1pbi53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHR5ICs9IHQueVBlcmNlbnQgKiAwLjAxICogbWluLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMTtcblx0XHRcdFx0XHRcdFx0aWYgKHggPCBtaW4pIGlmICh4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh5IDwgbWluKSBpZiAoeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gKCgoYTExICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIxICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTEyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyB0cmFuc2Zvcm0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcy5cblx0XHRcdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyBzeCArIFwiLDAsMCxcIiArIHN5ICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGaXJlZm94KSB7IC8vRmlyZWZveCBoYXMgYSBidWcgKGF0IGxlYXN0IGluIHYyNSkgdGhhdCBjYXVzZXMgaXQgdG8gcmVuZGVyIHRoZSB0cmFuc3BhcmVudCBwYXJ0IG9mIDMyLWJpdCBQTkcgaW1hZ2VzIGFzIGJsYWNrIHdoZW4gZGlzcGxheWVkIGluc2lkZSBhbiBpZnJhbWUgYW5kIHRoZSAzRCBzY2FsZSBpcyB2ZXJ5IHNtYWxsIGFuZCBkb2Vzbid0IGNoYW5nZSBzdWZmaWNpZW50bHkgZW5vdWdoIGJldHdlZW4gcmVuZGVycyAobGlrZSBpZiB5b3UgdXNlIGEgUG93ZXI0LmVhc2VJbk91dCB0byBzY2FsZSBmcm9tIDAgdG8gMSB3aGVyZSB0aGUgYmVnaW5uaW5nIHZhbHVlcyBvbmx5IGNoYW5nZSBhIHRpbnkgYW1vdW50IHRvIGJlZ2luIHRoZSB0d2VlbiBiZWZvcmUgYWNjZWxlcmF0aW5nKS4gSW4gdGhpcyBjYXNlLCB3ZSBmb3JjZSB0aGUgc2NhbGUgdG8gYmUgMC4wMDAwMiBpbnN0ZWFkIHdoaWNoIGlzIHZpc3VhbGx5IHRoZSBzYW1lIGJ1dCB3b3JrcyBhcm91bmQgdGhlIEZpcmVmb3ggaXNzdWUuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAxO1xuXHRcdFx0XHRcdGlmIChzeCA8IG1pbiAmJiBzeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN4ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3kgPCBtaW4gJiYgc3kgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeSA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlICYmICF0LnogJiYgIXQucm90YXRpb25YICYmICF0LnJvdGF0aW9uWSkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnRzIHRvIGhhdmUgYW4gb2RkIHN1cGVyLXRoaW4sIGJyb2tlbi9kb3R0ZWQgYmxhY2sgYm9yZGVyIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHBlcnNwZWN0aXZlIHNldCBidXQgYXJlbid0IHV0aWxpemluZyAzRCBzcGFjZSAobm8gcm90YXRpb25YLCByb3RhdGlvblksIG9yIHopLlxuXHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5nbGUgfHwgc2tld1gpIHtcblx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRjb3MgPSBhMTEgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gYTIxID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGlmIChza2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGlmICh0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oKHNrZXdYIC0gc2tld1kpICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tld1kgKiBfREVHMlJBRCk7XG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICFpc1NWRykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUU1xuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdGEzMiA9IGEzMypzaW47XG5cdFx0XHRcdFx0YTQyID0gYTQzKnNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0YTMzID0gYTMzKmNvcztcblx0XHRcdFx0XHRhNDMgPSBhNDMqY29zO1xuXHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeiAhPT0gMSkge1xuXHRcdFx0XHRcdGExMyo9c3o7XG5cdFx0XHRcdFx0YTIzKj1zejtcblx0XHRcdFx0XHRhMzMqPXN6O1xuXHRcdFx0XHRcdGE0Myo9c3o7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN5ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEyKj1zeTtcblx0XHRcdFx0XHRhMjIqPXN5O1xuXHRcdFx0XHRcdGEzMio9c3k7XG5cdFx0XHRcdFx0YTQyKj1zeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggIT09IDEpIHtcblx0XHRcdFx0XHRhMTEqPXN4O1xuXHRcdFx0XHRcdGEyMSo9c3g7XG5cdFx0XHRcdFx0YTMxKj1zeDtcblx0XHRcdFx0XHRhNDEqPXN4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHpPcmlnaW4gfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRpZiAoek9yaWdpbikge1xuXHRcdFx0XHRcdFx0eCArPSBhMTMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR5ICs9IGEyMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHogKz0gYTMzKi16T3JpZ2luK3pPcmlnaW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpc1NWRykgeyAvL2R1ZSB0byBidWdzIGluIHNvbWUgYnJvd3NlcnMsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSB0cmFuc2Zvcm0tb3JpZ2luIG9mIFNWRyBtYW51YWxseVxuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMikgKyB0LnlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IDwgbWluICYmIHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR4ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgPCBtaW4gJiYgeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHkgPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeiA8IG1pbiAmJiB6ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eiA9IDA7IC8vZG9uJ3QgdXNlIHN0cmluZyBiZWNhdXNlIHdlIGNhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBsYXRlciBhbmQgbmVlZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vb3B0aW1pemVkIHdheSBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGUgdmFsdWVzIGludG8gYSBzdHJpbmcuIElmIHdlIGRvIGl0IGFsbCBpbiBvbmUgc2hvdCwgaXQncyBzbG93ZXIgYmVjYXVzZSBvZiB0aGUgd2F5IGJyb3dzZXJzIGhhdmUgdG8gY3JlYXRlIHRlbXAgc3RyaW5ncyBhbmQgdGhlIHdheSBpdCBhZmZlY3RzIG1lbW9yeS4gSWYgd2UgZG8gaXQgcGllY2UtYnktcGllY2Ugd2l0aCArPSwgaXQncyBhIGJpdCBzbG93ZXIgdG9vLiBXZSBmb3VuZCB0aGF0IGRvaW5nIGl0IGluIHRoZXNlIHNpemVkIGNodW5rcyB3b3JrcyBiZXN0IG92ZXJhbGw6XG5cdFx0XHRcdHRyYW5zZm9ybSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeDNkKFwiIDogXCJtYXRyaXgzZChcIik7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSAoKGExMSA8IG1pbiAmJiBhMTEgPiAtbWluKSA/IHplcm8gOiBhMTEpICsgY29tbWEgKyAoKGEyMSA8IG1pbiAmJiBhMjEgPiAtbWluKSA/IHplcm8gOiBhMjEpICsgY29tbWEgKyAoKGEzMSA8IG1pbiAmJiBhMzEgPiAtbWluKSA/IHplcm8gOiBhMzEpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGE0MSA8IG1pbiAmJiBhNDEgPiAtbWluKSA/IHplcm8gOiBhNDEpICsgY29tbWEgKyAoKGExMiA8IG1pbiAmJiBhMTIgPiAtbWluKSA/IHplcm8gOiBhMTIpICsgY29tbWEgKyAoKGEyMiA8IG1pbiAmJiBhMjIgPiAtbWluKSA/IHplcm8gOiBhMjIpO1xuXHRcdFx0XHRpZiAocm90YXRpb25YIHx8IHJvdGF0aW9uWSB8fCBzeiAhPT0gMSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH07XG5cblx0XHRwID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblx0XHRwLnggPSBwLnkgPSBwLnogPSBwLnNrZXdYID0gcC5za2V3WSA9IHAucm90YXRpb24gPSBwLnJvdGF0aW9uWCA9IHAucm90YXRpb25ZID0gcC56T3JpZ2luID0gcC54UGVyY2VudCA9IHAueVBlcmNlbnQgPSBwLnhPZmZzZXQgPSBwLnlPZmZzZXQgPSAwO1xuXHRcdHAuc2NhbGVYID0gcC5zY2FsZVkgPSBwLnNjYWxlWiA9IDE7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwYXJzaW5nUHJvcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0aWYgKGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPT09IHZhcnMpIHsgcmV0dXJuIHB0OyB9IC8vb25seSBuZWVkIHRvIHBhcnNlIHRoZSB0cmFuc2Zvcm0gb25jZSwgYW5kIG9ubHkgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG5cdFx0XHRjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gdmFycztcblx0XHRcdHZhciBzY2FsZUZ1bmMgPSAodmFycy5zY2FsZSAmJiB0eXBlb2YodmFycy5zY2FsZSkgPT09IFwiZnVuY3Rpb25cIikgPyB2YXJzLnNjYWxlIDogMCwgLy9pZiB0aGVyZSdzIGEgZnVuY3Rpb24tYmFzZWQgXCJzY2FsZVwiIHZhbHVlLCBzd2FwIGluIHRoZSByZXN1bHRpbmcgbnVtZXJpYyB2YWx1ZSB0ZW1wb3JhcmlseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGNhbGxlZCBmb3IgYm90aCBzY2FsZVggYW5kIHNjYWxlWSBpbmRlcGVuZGVudGx5LCB0aGV5IG1heSBub3QgbWF0Y2ggKGxpa2UgaWYgdGhlIGZ1bmN0aW9uIHVzZXMgTWF0aC5yYW5kb20oKSkuXG5cdFx0XHRcdHN3YXBGdW5jO1xuXHRcdFx0aWYgKHR5cGVvZih2YXJzW3BhcnNpbmdQcm9wXSkgPT09IFwiZnVuY3Rpb25cIikgeyAvL3doYXRldmVyIHByb3BlcnR5IHRyaWdnZXJzIHRoZSBpbml0aWFsIHBhcnNpbmcgbWlnaHQgYmUgYSBmdW5jdGlvbi1iYXNlZCB2YWx1ZSBpbiB3aGljaCBjYXNlIGl0IGFscmVhZHkgZ290IGNhbGxlZCBpbiBwYXJzZSgpLCB0aHVzIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCBhZ2FpbiBpbiBoZXJlLiBUaGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gdGVtcG9yYXJpbHkgc3dhcCB0aGUgdmFsdWUgZGlyZWN0bHkgaW50byB0aGUgdmFycyBvYmplY3QsIGFuZCB0aGVuIGFmdGVyIHdlIGRvIGFsbCBvdXIgcGFyc2luZyBpbiB0aGlzIGZ1bmN0aW9uLCB3ZSdsbCBzd2FwIGl0IGJhY2sgYWdhaW4uXG5cdFx0XHRcdHN3YXBGdW5jID0gdmFyc1twYXJzaW5nUHJvcF07XG5cdFx0XHRcdHZhcnNbcGFyc2luZ1Byb3BdID0gZTtcblx0XHRcdH1cblx0XHRcdGlmIChzY2FsZUZ1bmMpIHtcblx0XHRcdFx0dmFycy5zY2FsZSA9IHNjYWxlRnVuYyhfaW5kZXgsIHQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yaWdpbmFsR1NUcmFuc2Zvcm0gPSB0Ll9nc1RyYW5zZm9ybSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0aSA9IF90cmFuc2Zvcm1Qcm9wcy5sZW5ndGgsXG5cdFx0XHRcdHYgPSB2YXJzLFxuXHRcdFx0XHRlbmRSb3RhdGlvbnMgPSB7fSxcblx0XHRcdFx0dHJhbnNmb3JtT3JpZ2luU3RyaW5nID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcblx0XHRcdFx0bTEgPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdi5wYXJzZVRyYW5zZm9ybSksXG5cdFx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybSAmJiAoKHR5cGVvZih2LnRyYW5zZm9ybSkgPT09IFwiZnVuY3Rpb25cIikgPyB2LnRyYW5zZm9ybShfaW5kZXgsIF90YXJnZXQpIDogdi50cmFuc2Zvcm0pLFxuXHRcdFx0XHRtMiwgY29weSwgaGFzM0QsIGhhc0NoYW5nZSwgZHIsIHgsIHksIG1hdHJpeCwgcDtcblx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IG0xO1xuXHRcdFx0aWYgKG9yaWcgJiYgdHlwZW9mKG9yaWcpID09PSBcInN0cmluZ1wiICYmIF90cmFuc2Zvcm1Qcm9wKSB7IC8vZm9yIHZhbHVlcyBsaWtlIHRyYW5zZm9ybTpcInJvdGF0ZSg2MGRlZykgc2NhbGUoMC41LCAwLjgpXCJcblx0XHRcdFx0Y29weSA9IF90ZW1wRGl2LnN0eWxlOyAvL2Rvbid0IHVzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0IGJlY2F1c2UgaXQgbWlnaHQgYmUgU1ZHIGluIHdoaWNoIGNhc2Ugc29tZSBicm93c2VycyBkb24ndCByZXBvcnQgY29tcHV0ZWQgc3R5bGUgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5W190cmFuc2Zvcm1Qcm9wXSA9IG9yaWc7XG5cdFx0XHRcdGNvcHkuZGlzcGxheSA9IFwiYmxvY2tcIjsgLy9pZiBkaXNwbGF5IGlzIFwibm9uZVwiLCB0aGUgYnJvd3NlciBvZnRlbiByZWZ1c2VzIHRvIHJlcG9ydCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuXHRcdFx0XHRjb3B5LnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0XHRfZG9jLmJvZHkuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRtMiA9IF9nZXRUcmFuc2Zvcm0oX3RlbXBEaXYsIG51bGwsIGZhbHNlKTtcblx0XHRcdFx0aWYgKG0xLnN2ZykgeyAvL2lmIGl0J3MgYW4gU1ZHIGVsZW1lbnQsIHgveSBwYXJ0IG9mIHRoZSBtYXRyaXggd2lsbCBiZSBhZmZlY3RlZCBieSB3aGF0ZXZlciB3ZSB1c2UgYXMgdGhlIG9yaWdpbiBhbmQgdGhlIG9mZnNldHMsIHNvIGNvbXBlbnNhdGUgaGVyZS4uLlxuXHRcdFx0XHRcdHggPSBtMS54T3JpZ2luO1xuXHRcdFx0XHRcdHkgPSBtMS55T3JpZ2luO1xuXHRcdFx0XHRcdG0yLnggLT0gbTEueE9mZnNldDtcblx0XHRcdFx0XHRtMi55IC09IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKHYudHJhbnNmb3JtT3JpZ2luIHx8IHYuc3ZnT3JpZ2luKSB7IC8vaWYgdGhpcyB0d2VlbiBpcyBhbHRlcmluZyB0aGUgb3JpZ2luLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluIGhlcmUuIFRoZSBhY3R1YWwgd29yayBvZiByZWNvcmRpbmcgdGhlIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMgYW5kIHNldHRpbmcgdXAgdGhlIFByb3BUd2VlbiBpcyBkb25lIGxhdGVyIChzdGlsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbikgc28gd2UgY2Fubm90IGxlYXZlIHRoZSBjaGFuZ2VzIGludGFjdCBoZXJlIC0gd2Ugb25seSB3YW50IHRvIHVwZGF0ZSB0aGUgeC95IGFjY29yZGluZ2x5LlxuXHRcdFx0XHRcdFx0b3JpZyA9IHt9O1xuXHRcdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKHYudHJhbnNmb3JtT3JpZ2luKSwgb3JpZywgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luLCB0cnVlKTtcblx0XHRcdFx0XHRcdHggPSBvcmlnLnhPcmlnaW47XG5cdFx0XHRcdFx0XHR5ID0gb3JpZy55T3JpZ2luO1xuXHRcdFx0XHRcdFx0bTIueCAtPSBvcmlnLnhPZmZzZXQgLSBtMS54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0bTIueSAtPSBvcmlnLnlPZmZzZXQgLSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCB8fCB5KSB7XG5cdFx0XHRcdFx0XHRtYXRyaXggPSBfZ2V0TWF0cml4KF90ZW1wRGl2LCB0cnVlKTtcblx0XHRcdFx0XHRcdG0yLnggLT0geCAtICh4ICogbWF0cml4WzBdICsgeSAqIG1hdHJpeFsyXSk7XG5cdFx0XHRcdFx0XHRtMi55IC09IHkgLSAoeCAqIG1hdHJpeFsxXSArIHkgKiBtYXRyaXhbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfZG9jLmJvZHkucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRpZiAoIW0yLnBlcnNwZWN0aXZlKSB7XG5cdFx0XHRcdFx0bTIucGVyc3BlY3RpdmUgPSBtMS5wZXJzcGVjdGl2ZTsgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnhQZXJjZW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYueVBlcmNlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwib2JqZWN0XCIpIHsgLy9mb3IgdmFsdWVzIGxpa2Ugc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCB4LCB5LCBza2V3WCwgYW5kIHNrZXdZIG9yIHRyYW5zZm9ybTp7Li4ufSAob2JqZWN0KVxuXHRcdFx0XHRtMiA9IHtzY2FsZVg6X3BhcnNlVmFsKCh2LnNjYWxlWCAhPSBudWxsKSA/IHYuc2NhbGVYIDogdi5zY2FsZSwgbTEuc2NhbGVYKSxcblx0XHRcdFx0XHRzY2FsZVk6X3BhcnNlVmFsKCh2LnNjYWxlWSAhPSBudWxsKSA/IHYuc2NhbGVZIDogdi5zY2FsZSwgbTEuc2NhbGVZKSxcblx0XHRcdFx0XHRzY2FsZVo6X3BhcnNlVmFsKHYuc2NhbGVaLCBtMS5zY2FsZVopLFxuXHRcdFx0XHRcdHg6X3BhcnNlVmFsKHYueCwgbTEueCksXG5cdFx0XHRcdFx0eTpfcGFyc2VWYWwodi55LCBtMS55KSxcblx0XHRcdFx0XHR6Ol9wYXJzZVZhbCh2LnosIG0xLnopLFxuXHRcdFx0XHRcdHhQZXJjZW50Ol9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCksXG5cdFx0XHRcdFx0eVBlcmNlbnQ6X3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KSxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZTpfcGFyc2VWYWwodi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSwgbTEucGVyc3BlY3RpdmUpfTtcblx0XHRcdFx0ZHIgPSB2LmRpcmVjdGlvbmFsUm90YXRpb247XG5cdFx0XHRcdGlmIChkciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihkcikgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdGZvciAoY29weSBpbiBkcikge1xuXHRcdFx0XHRcdFx0XHR2W2NvcHldID0gZHJbY29weV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHYucm90YXRpb24gPSBkcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LngpID09PSBcInN0cmluZ1wiICYmIHYueC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi54ID0gMDtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LngsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueSkgPT09IFwic3RyaW5nXCIgJiYgdi55LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnkgPSAwO1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueSwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bTIucm90YXRpb24gPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblwiIGluIHYpID8gdi5yb3RhdGlvbiA6IChcInNob3J0Um90YXRpb25cIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvbiArIFwiX3Nob3J0XCIgOiAoXCJyb3RhdGlvblpcIiBpbiB2KSA/IHYucm90YXRpb25aIDogbTEucm90YXRpb24sIG0xLnJvdGF0aW9uLCBcInJvdGF0aW9uXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWCA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWFwiIGluIHYpID8gdi5yb3RhdGlvblggOiAoXCJzaG9ydFJvdGF0aW9uWFwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWCArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblggfHwgMCwgbTEucm90YXRpb25YLCBcInJvdGF0aW9uWFwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWSA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWVwiIGluIHYpID8gdi5yb3RhdGlvblkgOiAoXCJzaG9ydFJvdGF0aW9uWVwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWSArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblkgfHwgMCwgbTEucm90YXRpb25ZLCBcInJvdGF0aW9uWVwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0yLnNrZXdYID0gX3BhcnNlQW5nbGUodi5za2V3WCwgbTEuc2tld1gpO1xuXHRcdFx0XHRtMi5za2V3WSA9IF9wYXJzZUFuZ2xlKHYuc2tld1ksIG0xLnNrZXdZKTtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHMzRCAmJiB2LmZvcmNlM0QgIT0gbnVsbCkge1xuXHRcdFx0XHRtMS5mb3JjZTNEID0gdi5mb3JjZTNEO1xuXHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtMS5za2V3VHlwZSA9IHYuc2tld1R5cGUgfHwgbTEuc2tld1R5cGUgfHwgQ1NTUGx1Z2luLmRlZmF1bHRTa2V3VHlwZTtcblxuXHRcdFx0aGFzM0QgPSAobTEuZm9yY2UzRCB8fCBtMS56IHx8IG0xLnJvdGF0aW9uWCB8fCBtMS5yb3RhdGlvblkgfHwgbTIueiB8fCBtMi5yb3RhdGlvblggfHwgbTIucm90YXRpb25ZIHx8IG0yLnBlcnNwZWN0aXZlKTtcblx0XHRcdGlmICghaGFzM0QgJiYgdi5zY2FsZSAhPSBudWxsKSB7XG5cdFx0XHRcdG0yLnNjYWxlWiA9IDE7IC8vbm8gbmVlZCB0byB0d2VlbiBzY2FsZVouXG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwID0gX3RyYW5zZm9ybVByb3BzW2ldO1xuXHRcdFx0XHRvcmlnID0gbTJbcF0gLSBtMVtwXTtcblx0XHRcdFx0aWYgKG9yaWcgPiBtaW4gfHwgb3JpZyA8IC1taW4gfHwgdltwXSAhPSBudWxsIHx8IF9mb3JjZVBUW3BdICE9IG51bGwpIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgcCwgbTFbcF0sIG9yaWcsIHB0KTtcblx0XHRcdFx0XHRpZiAocCBpbiBlbmRSb3RhdGlvbnMpIHtcblx0XHRcdFx0XHRcdHB0LmUgPSBlbmRSb3RhdGlvbnNbcF07IC8vZGlyZWN0aW9uYWwgcm90YXRpb25zIHR5cGljYWxseSBoYXZlIGNvbXBlbnNhdGVkIHZhbHVlcyBkdXJpbmcgdGhlIHR3ZWVuLCBidXQgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhleSBlbmQgYXQgZXhhY3RseSB3aGF0IHRoZSB1c2VyIHJlcXVlc3RlZFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdC54czAgPSAwOyAvL2Vuc3VyZXMgdGhlIHZhbHVlIHN0YXlzIG51bWVyaWMgaW4gc2V0UmF0aW8oKVxuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybU9yaWdpbjtcblx0XHRcdGlmIChtMS5zdmcgJiYgKG9yaWcgfHwgdi5zdmdPcmlnaW4pKSB7XG5cdFx0XHRcdHggPSBtMS54T2Zmc2V0OyAvL3doZW4gd2UgY2hhbmdlIHRoZSBvcmlnaW4sIGluIG9yZGVyIHRvIHByZXZlbnQgdGhpbmdzIGZyb20ganVtcGluZyB3ZSBhZGp1c3QgdGhlIHgveSBzbyB3ZSBtdXN0IHJlY29yZCB0aG9zZSBoZXJlIHNvIHRoYXQgd2UgY2FuIGNyZWF0ZSBQcm9wVHdlZW5zIGZvciB0aGVtIGFuZCBmbGlwIHRoZW0gYXQgdGhlIHNhbWUgdGltZSBhcyB0aGUgb3JpZ2luXG5cdFx0XHRcdHkgPSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRfcGFyc2VTVkdPcmlnaW4odCwgX3BhcnNlUG9zaXRpb24ob3JpZyksIG0yLCB2LnN2Z09yaWdpbiwgdi5zbW9vdGhPcmlnaW4pO1xuXHRcdFx0XHRwdCA9IF9hZGROb25Ud2VlbmluZ051bWVyaWNQVChtMSwgXCJ4T3JpZ2luXCIsIChvcmlnaW5hbEdTVHJhbnNmb3JtID8gbTEgOiBtMikueE9yaWdpbiwgbTIueE9yaWdpbiwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7IC8vbm90ZTogaWYgdGhlcmUgd2Fzbid0IGEgdHJhbnNmb3JtT3JpZ2luIGRlZmluZWQgeWV0LCBqdXN0IHN0YXJ0IHdpdGggdGhlIGRlc3RpbmF0aW9uIG9uZTsgaXQncyB3YXN0ZWZ1bCBvdGhlcndpc2UsIGFuZCBpdCBjYXVzZXMgcHJvYmxlbXMgd2l0aCBmcm9tVG8oKSB0d2VlbnMuIEZvciBleGFtcGxlLCBUd2VlbkxpdGUudG8oXCIjd2hlZWxcIiwgMywge3JvdGF0aW9uOjE4MCwgdHJhbnNmb3JtT3JpZ2luOlwiNTAlIDUwJVwiLCBkZWxheToxfSk7IFR3ZWVuTGl0ZS5mcm9tVG8oXCIjd2hlZWxcIiwgMywge3NjYWxlOjAuNSwgdHJhbnNmb3JtT3JpZ2luOlwiNTAlIDUwJVwifSwge3NjYWxlOjEsIGRlbGF5OjJ9KTsgd291bGQgY2F1c2UgYSBqdW1wIHdoZW4gdGhlIGZyb20gdmFsdWVzIHJldmVydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSAybmQgdHdlZW4uXG5cdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInlPcmlnaW5cIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyBtMSA6IG0yKS55T3JpZ2luLCBtMi55T3JpZ2luLCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0aWYgKHggIT09IG0xLnhPZmZzZXQgfHwgeSAhPT0gbTEueU9mZnNldCkge1xuXHRcdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInhPZmZzZXRcIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyB4IDogbTEueE9mZnNldCksIG0xLnhPZmZzZXQsIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInlPZmZzZXRcIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyB5IDogbTEueU9mZnNldCksIG0xLnlPZmZzZXQsIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9yaWcgPSBcIjBweCAwcHhcIjsgLy9jZXJ0YWluIGJyb3dzZXJzIChsaWtlIGZpcmVmb3gpIGNvbXBsZXRlbHkgYm90Y2ggdHJhbnNmb3JtLW9yaWdpbiwgc28gd2UgbXVzdCByZW1vdmUgaXQgdG8gcHJldmVudCBpdCBmcm9tIGNvbnRhbWluYXRpbmcgdHJhbnNmb3Jtcy4gV2UgbWFuYWdlIGl0IG91cnNlbHZlcyB3aXRoIHhPcmlnaW4gYW5kIHlPcmlnaW5cblx0XHRcdH1cblx0XHRcdGlmIChvcmlnIHx8IChfc3VwcG9ydHMzRCAmJiBoYXMzRCAmJiBtMS56T3JpZ2luKSkgeyAvL2lmIGFueXRoaW5nIDNEIGlzIGhhcHBlbmluZyBhbmQgdGhlcmUncyBhIHRyYW5zZm9ybU9yaWdpbiB3aXRoIGEgeiBjb21wb25lbnQgdGhhdCdzIG5vbi16ZXJvLCB3ZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSB0cmFuc2Zvcm1PcmlnaW4ncyB6LWNvbXBvbmVudCBpcyBzZXQgdG8gMCBzbyB0aGF0IHdlIGNhbiBtYW51YWxseSBkbyB0aG9zZSBjYWxjdWxhdGlvbnMgdG8gZ2V0IGFyb3VuZCBTYWZhcmkgYnVncy4gRXZlbiBpZiB0aGUgdXNlciBkaWRuJ3Qgc3BlY2lmaWNhbGx5IGRlZmluZSBhIFwidHJhbnNmb3JtT3JpZ2luXCIgaW4gdGhpcyBwYXJ0aWN1bGFyIHR3ZWVuIChtYXliZSB0aGV5IGRpZCBpdCB2aWEgY3NzIGRpcmVjdGx5KS5cblx0XHRcdFx0aWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0aGFzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0XHRwID0gX3RyYW5zZm9ybU9yaWdpblByb3A7XG5cdFx0XHRcdFx0b3JpZyA9IChvcmlnIHx8IF9nZXRTdHlsZSh0LCBwLCBfY3MsIGZhbHNlLCBcIjUwJSA1MCVcIikpICsgXCJcIjsgLy9jYXN0IGFzIHN0cmluZyB0byBhdm9pZCBlcnJvcnNcblx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIDAsIDAsIHB0LCAtMSwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTtcblx0XHRcdFx0XHRwdC5iID0gc3R5bGVbcF07XG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdFx0Y29weSA9IG0xLnpPcmlnaW47XG5cdFx0XHRcdFx0XHRvcmlnID0gb3JpZy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0XHRtMS56T3JpZ2luID0gKChvcmlnLmxlbmd0aCA+IDIgJiYgIShjb3B5ICE9PSAwICYmIG9yaWdbMl0gPT09IFwiMHB4XCIpKSA/IHBhcnNlRmxvYXQob3JpZ1syXSkgOiBjb3B5KSB8fCAwOyAvL1NhZmFyaSBkb2Vzbid0IGhhbmRsZSB0aGUgeiBwYXJ0IG9mIHRyYW5zZm9ybU9yaWdpbiBjb3JyZWN0bHksIHNvIHdlJ2xsIG1hbnVhbGx5IGhhbmRsZSBpdCBpbiB0aGUgX3NldDNEVHJhbnNmb3JtUmF0aW8oKSBtZXRob2QuXG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZ1swXSArIFwiIFwiICsgKG9yaWdbMV0gfHwgXCI1MCVcIikgKyBcIiAwcHhcIjsgLy93ZSBtdXN0IGRlZmluZSBhIHogdmFsdWUgb2YgMHB4IHNwZWNpZmljYWxseSBvdGhlcndpc2UgaU9TIDUgU2FmYXJpIHdpbGwgc3RpY2sgd2l0aCB0aGUgb2xkIG9uZSAoaWYgb25lIHdhcyBkZWZpbmVkKSFcblx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihtMSwgXCJ6T3JpZ2luXCIsIDAsIDAsIHB0LCAtMSwgcHQubik7IC8vd2UgbXVzdCBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gZm9yIHRoZSBfZ3NUcmFuc2Zvcm0uek9yaWdpbiBzbyB0aGF0IGl0IGdldHMgcmVzZXQgcHJvcGVybHkgYXQgdGhlIGJlZ2lubmluZyBpZiB0aGUgdHdlZW4gcnVucyBiYWNrd2FyZCAoYXMgb3Bwb3NlZCB0byBqdXN0IHNldHRpbmcgbTEuek9yaWdpbiBoZXJlKVxuXHRcdFx0XHRcdFx0cHQuYiA9IGNvcHk7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQueHMwID0gcHQuZSA9IG9yaWc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgKDYtOCksIHdlIG5lZWQgdG8gbWFudWFsbHkgY2FsY3VsYXRlIHRoaW5ncyBpbnNpZGUgdGhlIHNldFJhdGlvKCkgZnVuY3Rpb24uIFdlIHJlY29yZCBvcmlnaW4geCBhbmQgeSAob3ggYW5kIG95KSBhbmQgd2hldGhlciBvciBub3QgdGhlIHZhbHVlcyBhcmUgcGVyY2VudGFnZXMgKG94cCBhbmQgb3lwKS5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfcGFyc2VQb3NpdGlvbihvcmlnICsgXCJcIiwgbTEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzQ2hhbmdlKSB7XG5cdFx0XHRcdGNzc3AuX3RyYW5zZm9ybVR5cGUgPSAoIShtMS5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmIChoYXMzRCB8fCB0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKSkgPyAzIDogMjsgLy9xdWlja2VyIHRoYW4gY2FsbGluZyBjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3dhcEZ1bmMpIHtcblx0XHRcdFx0dmFyc1twYXJzaW5nUHJvcF0gPSBzd2FwRnVuYztcblx0XHRcdH1cblx0XHRcdGlmIChzY2FsZUZ1bmMpIHtcblx0XHRcdFx0dmFycy5zY2FsZSA9IHNjYWxlRnVuYztcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9LCBwcmVmaXg6dHJ1ZX0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm94U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLCBwcmVmaXg6dHJ1ZSwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZSwga2V5d29yZDpcImluc2V0XCJ9KTtcblxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlclJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR2YXIgcHJvcHMgPSBbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0ZWExLCBpLCBlczIsIGJzMiwgYnMsIGVzLCBibiwgZW4sIHcsIGgsIGVzZngsIGJzZngsIHJlbCwgaG4sIHZuLCBlbTtcblx0XHRcdHcgPSBwYXJzZUZsb2F0KHQub2Zmc2V0V2lkdGgpO1xuXHRcdFx0aCA9IHBhcnNlRmxvYXQodC5vZmZzZXRIZWlnaHQpO1xuXHRcdFx0ZWExID0gZS5zcGxpdChcIiBcIik7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggcGVyY2VudGFnZXMsIHdlIG11c3QgY29udmVydCB0aGluZ3Mgc2VwYXJhdGVseSBmb3IgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGF4aXMhXG5cdFx0XHRcdGlmICh0aGlzLnAuaW5kZXhPZihcImJvcmRlclwiKSkgeyAvL29sZGVyIGJyb3dzZXJzIHVzZWQgYSBwcmVmaXhcblx0XHRcdFx0XHRwcm9wc1tpXSA9IF9jaGVja1Byb3BQcmVmaXgocHJvcHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJzID0gYnMyID0gX2dldFN0eWxlKHQsIHByb3BzW2ldLCBfY3MsIGZhbHNlLCBcIjBweFwiKTtcblx0XHRcdFx0aWYgKGJzLmluZGV4T2YoXCIgXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGJzMiA9IGJzLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRicyA9IGJzMlswXTtcblx0XHRcdFx0XHRiczIgPSBiczJbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXMgPSBlczIgPSBlYTFbaV07XG5cdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdGJzZnggPSBicy5zdWJzdHIoKGJuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0cmVsID0gKGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUludChlcy5jaGFyQXQoMCkrXCIxXCIsIDEwKTtcblx0XHRcdFx0XHRlcyA9IGVzLnN1YnN0cigyKTtcblx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCAtIChlbiA8IDAgPyAxIDogMCkpIHx8IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW4gPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRlc2Z4ID0gZXMuc3Vic3RyKChlbiArIFwiXCIpLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRlc2Z4ID0gX3N1ZmZpeE1hcFtwXSB8fCBic2Z4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlc2Z4ICE9PSBic2Z4KSB7XG5cdFx0XHRcdFx0aG4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCBibiwgYnNmeCk7IC8vaG9yaXpvbnRhbCBudW1iZXIgKHdlIHVzZSBhIGJvZ3VzIFwiYm9yZGVyTGVmdFwiIHByb3BlcnR5IGp1c3QgYmVjYXVzZSB0aGUgX2NvbnZlcnRUb1BpeGVscygpIG1ldGhvZCBzZWFyY2hlcyBmb3IgdGhlIGtleXdvcmRzIFwiTGVmdFwiLCBcIlJpZ2h0XCIsIFwiVG9wXCIsIGFuZCBcIkJvdHRvbVwiIHRvIGRldGVybWluZSBvZiBpdCdzIGEgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0eSwgYW5kIHdlIG5lZWQgXCJib3JkZXJcIiBpbiB0aGUgbmFtZSBzbyB0aGF0IGl0IGtub3dzIGl0IHNob3VsZCBtZWFzdXJlIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50IGl0c2VsZiwgbm90IGl0cyBwYXJlbnQuXG5cdFx0XHRcdFx0dm4gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyVG9wXCIsIGJuLCBic2Z4KTsgLy92ZXJ0aWNhbCBudW1iZXJcblx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gdyAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHRcdGJzMiA9ICh2biAvIGggKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ID09PSBcImVtXCIpIHtcblx0XHRcdFx0XHRcdGVtID0gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlckxlZnRcIiwgMSwgXCJlbVwiKTtcblx0XHRcdFx0XHRcdGJzID0gKGhuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gZW0pICsgXCJlbVwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicyA9IGhuICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0YnMyID0gdm4gKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRcdGVzID0gKHBhcnNlRmxvYXQoYnMpICsgZW4pICsgZXNmeDtcblx0XHRcdFx0XHRcdGVzMiA9IChwYXJzZUZsb2F0KGJzMikgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IF9wYXJzZUNvbXBsZXgoc3R5bGUsIHByb3BzW2ldLCBicyArIFwiIFwiICsgYnMyLCBlcyArIFwiIFwiICsgZXMyLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHggMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLGJvcmRlclRvcExlZnRSYWRpdXMsYm9yZGVyVG9wUmlnaHRSYWRpdXNcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0cmV0dXJuIF9wYXJzZUNvbXBsZXgodC5zdHlsZSwgcCwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHAsIF9jcywgZmFsc2UsIFwiMHB4IDBweFwiKSksIHRoaXMuZm9ybWF0KGUpLCBmYWxzZSwgXCIwcHhcIiwgcHQpO1xuXHRcdH0sIHByZWZpeDp0cnVlLCBmb3JtYXR0ZXI6X2dldEZvcm1hdHRlcihcIjBweCAwcHhcIiwgZmFsc2UsIHRydWUpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2dyb3VuZFBvc2l0aW9uXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBicCA9IFwiYmFja2dyb3VuZC1wb3NpdGlvblwiLFxuXHRcdFx0XHRjcyA9IChfY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCkpLFxuXHRcdFx0XHRicyA9IHRoaXMuZm9ybWF0KCAoKGNzKSA/IF9pZVZlcnMgPyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteFwiKSArIFwiIFwiICsgY3MuZ2V0UHJvcGVydHlWYWx1ZShicCArIFwiLXlcIikgOiBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwKSA6IHQuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblggKyBcIiBcIiArIHQuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblkpIHx8IFwiMCAwXCIpLCAvL0ludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgcmVwb3J0IGJhY2tncm91bmQtcG9zaXRpb24gY29ycmVjdGx5IC0gd2UgbXVzdCBxdWVyeSBiYWNrZ3JvdW5kLXBvc2l0aW9uLXggYW5kIGJhY2tncm91bmQtcG9zaXRpb24teSBhbmQgY29tYmluZSB0aGVtIChldmVuIGluIElFMTApLiBCZWZvcmUgSUU5LCB3ZSBtdXN0IGRvIHRoZSBzYW1lIHdpdGggdGhlIGN1cnJlbnRTdHlsZSBvYmplY3QgYW5kIHVzZSBjYW1lbENhc2Vcblx0XHRcdFx0ZXMgPSB0aGlzLmZvcm1hdChlKSxcblx0XHRcdFx0YmEsIGVhLCBpLCBwY3QsIG92ZXJsYXAsIHNyYztcblx0XHRcdGlmICgoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKSAhPT0gKGVzLmluZGV4T2YoXCIlXCIpICE9PSAtMSkgJiYgZXMuc3BsaXQoXCIsXCIpLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0c3JjID0gX2dldFN0eWxlKHQsIFwiYmFja2dyb3VuZEltYWdlXCIpLnJlcGxhY2UoX3VybEV4cCwgXCJcIik7XG5cdFx0XHRcdGlmIChzcmMgJiYgc3JjICE9PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdGJhID0gYnMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGVhID0gZXMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdF90ZW1wSW1nLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMpOyAvL3NldCB0aGUgdGVtcCBJTUcncyBzcmMgdG8gdGhlIGJhY2tncm91bmQtaW1hZ2Ugc28gdGhhdCB3ZSBjYW4gbWVhc3VyZSBpdHMgd2lkdGgvaGVpZ2h0XG5cdFx0XHRcdFx0aSA9IDI7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRicyA9IGJhW2ldO1xuXHRcdFx0XHRcdFx0cGN0ID0gKGJzLmluZGV4T2YoXCIlXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0XHRpZiAocGN0ICE9PSAoZWFbaV0uaW5kZXhPZihcIiVcIikgIT09IC0xKSkge1xuXHRcdFx0XHRcdFx0XHRvdmVybGFwID0gKGkgPT09IDApID8gdC5vZmZzZXRXaWR0aCAtIF90ZW1wSW1nLndpZHRoIDogdC5vZmZzZXRIZWlnaHQgLSBfdGVtcEltZy5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdGJhW2ldID0gcGN0ID8gKHBhcnNlRmxvYXQoYnMpIC8gMTAwICogb3ZlcmxhcCkgKyBcInB4XCIgOiAocGFyc2VGbG9hdChicykgLyBvdmVybGFwICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicyA9IGJhLmpvaW4oXCIgXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYnMsIGVzLCBwdCwgcGx1Z2luKTtcblx0XHR9LCBmb3JtYXR0ZXI6X3BhcnNlUG9zaXRpb259KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kU2l6ZVwiLCB7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsIGZvcm1hdHRlcjpmdW5jdGlvbih2KSB7XG5cdFx0XHR2ICs9IFwiXCI7IC8vZW5zdXJlIGl0J3MgYSBzdHJpbmdcblx0XHRcdHJldHVybiBfcGFyc2VQb3NpdGlvbih2LmluZGV4T2YoXCIgXCIpID09PSAtMSA/IHYgKyBcIiBcIiArIHYgOiB2KTsgLy9pZiBzZXQgdG8gc29tZXRoaW5nIGxpa2UgXCIxMDAlIDEwMCVcIiwgU2FmYXJpIHR5cGljYWxseSByZXBvcnRzIHRoZSBjb21wdXRlZCBzdHlsZSBhcyBqdXN0IFwiMTAwJVwiIChubyAybmQgdmFsdWUpLCBidXQgd2Ugc2hvdWxkIGVuc3VyZSB0aGF0IHRoZXJlIGFyZSB0d28gdmFsdWVzLCBzbyBjb3B5IHRoZSBmaXJzdCBvbmUuIE90aGVyd2lzZSwgaXQnZCBiZSBpbnRlcnByZXRlZCBhcyBcIjEwMCUgMFwiICh3cm9uZykuXG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwZXJzcGVjdGl2ZU9yaWdpblwiLCB7ZGVmYXVsdFZhbHVlOlwiNTAlIDUwJVwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRyYW5zZm9ybVN0eWxlXCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tmYWNlVmlzaWJpbGl0eVwiLCB7cHJlZml4OnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ1c2VyU2VsZWN0XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm1hcmdpblwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwibWFyZ2luVG9wLG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxtYXJnaW5MZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGFkZGluZ1wiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdFwiKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsaXBcIiwge2RlZmF1bHRWYWx1ZTpcInJlY3QoMHB4LDBweCwwcHgsMHB4KVwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbil7XG5cdFx0XHR2YXIgYiwgY3MsIGRlbGltO1xuXHRcdFx0aWYgKF9pZVZlcnMgPCA5KSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvbid0IHJlcG9ydCBhIFwiY2xpcFwiIHZhbHVlIGluIHRoZSBjdXJyZW50U3R5bGUgLSBpbnN0ZWFkLCB0aGUgdmFsdWVzIGFyZSBzcGxpdCBhcGFydCBpbnRvIGNsaXBUb3AsIGNsaXBSaWdodCwgY2xpcEJvdHRvbSwgYW5kIGNsaXBMZWZ0LiBBbHNvLCBpbiBJRTcgYW5kIGVhcmxpZXIsIHRoZSB2YWx1ZXMgaW5zaWRlIHJlY3QoKSBhcmUgc3BhY2UtZGVsaW1pdGVkLCBub3QgY29tbWEtZGVsaW1pdGVkLlxuXHRcdFx0XHRjcyA9IHQuY3VycmVudFN0eWxlO1xuXHRcdFx0XHRkZWxpbSA9IF9pZVZlcnMgPCA4ID8gXCIgXCIgOiBcIixcIjtcblx0XHRcdFx0YiA9IFwicmVjdChcIiArIGNzLmNsaXBUb3AgKyBkZWxpbSArIGNzLmNsaXBSaWdodCArIGRlbGltICsgY3MuY2xpcEJvdHRvbSArIGRlbGltICsgY3MuY2xpcExlZnQgKyBcIilcIjtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiLFwiKS5qb2luKGRlbGltKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGIgPSB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgdGhpcy5wLCBfY3MsIGZhbHNlLCB0aGlzLmRmbHQpKTtcblx0XHRcdFx0ZSA9IHRoaXMuZm9ybWF0KGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIGIsIGUsIHB0LCBwbHVnaW4pO1xuXHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0ZXh0U2hhZG93XCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAjOTk5XCIsIGNvbG9yOnRydWUsIG11bHRpOnRydWV9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJhdXRvUm91bmQsc3RyaWN0VW5pdHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge3JldHVybiBwdDt9fSk7IC8vanVzdCBzbyB0aGF0IHdlIGNhbiBpZ25vcmUgdGhlc2UgcHJvcGVydGllcyAobm90IHR3ZWVuIHRoZW0pXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHggc29saWQgIzAwMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJ3ID0gX2dldFN0eWxlKHQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgX2NzLCBmYWxzZSwgXCIwcHhcIiksXG5cdFx0XHRcdGVuZCA9IHRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0ZXNmeCA9IGVuZFswXS5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpO1xuXHRcdFx0aWYgKGVzZnggIT09IFwicHhcIikgeyAvL2lmIHdlJ3JlIGFuaW1hdGluZyB0byBhIG5vbi1weCB2YWx1ZSwgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBiZWdpbm5pbmcgd2lkdGggdG8gdGhhdCB1bml0LlxuXHRcdFx0XHRidyA9IChwYXJzZUZsb2F0KGJ3KSAvIF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJUb3BXaWR0aFwiLCAxLCBlc2Z4KSkgKyBlc2Z4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsIHRoaXMuZm9ybWF0KGJ3ICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BTdHlsZVwiLCBfY3MsIGZhbHNlLCBcInNvbGlkXCIpICsgXCIgXCIgKyBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BDb2xvclwiLCBfY3MsIGZhbHNlLCBcIiMwMDBcIikpLCBlbmQuam9pbihcIiBcIiksIHB0LCBwbHVnaW4pO1xuXHRcdFx0fSwgY29sb3I6dHJ1ZSwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIGEgPSB2LnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0cmV0dXJuIGFbMF0gKyBcIiBcIiArIChhWzFdIHx8IFwic29saWRcIikgKyBcIiBcIiArICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW1wiIzAwMFwiXSlbMF07XG5cdFx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyV2lkdGhcIiwge3BhcnNlcjpfZ2V0RWRnZVBhcnNlcihcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSk7IC8vRmlyZWZveCBkb2Vzbid0IHBpY2sgdXAgb24gYm9yZGVyV2lkdGggc2V0IGluIHN0eWxlIHNoZWV0cyAob25seSBpbmxpbmUpLlxuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgcyA9IHQuc3R5bGUsXG5cdFx0XHRcdHByb3AgPSAoXCJjc3NGbG9hdFwiIGluIHMpID8gXCJjc3NGbG9hdFwiIDogXCJzdHlsZUZsb2F0XCI7XG5cdFx0XHRyZXR1cm4gbmV3IENTU1Byb3BUd2VlbihzLCBwcm9wLCAwLCAwLCBwdCwgLTEsIHAsIGZhbHNlLCAwLCBzW3Byb3BdLCBlKTtcblx0XHR9fSk7XG5cblx0XHQvL29wYWNpdHktcmVsYXRlZFxuXHRcdHZhciBfc2V0SUVPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciB0ID0gdGhpcy50LCAvL3JlZmVycyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0ZmlsdGVycyA9IHQuZmlsdGVyIHx8IF9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpIHx8IFwiXCIsXG5cdFx0XHRcdFx0dmFsID0gKHRoaXMucyArIHRoaXMuYyAqIHYpIHwgMCxcblx0XHRcdFx0XHRza2lwO1xuXHRcdFx0XHRpZiAodmFsID09PSAxMDApIHsgLy9mb3Igb2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhhdCBuZWVkIHRvIHVzZSBhIGZpbHRlciB0byBhcHBseSBvcGFjaXR5LCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBmaWx0ZXIgaWYgb3BhY2l0eSBoaXRzIDEgaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgYnV0IG1ha2Ugc3VyZSB0aGVyZSBpc24ndCBhIHRyYW5zZm9ybSAobWF0cml4KSBvciBncmFkaWVudCBpbiB0aGUgZmlsdGVycy5cblx0XHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiYXRyaXgoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJyYWRpZW50KFwiKSA9PT0gLTEgJiYgZmlsdGVycy5pbmRleE9mKFwib2FkZXIoXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gKCFfZ2V0U3R5bGUodGhpcy5kYXRhLCBcImZpbHRlclwiKSk7IC8vaWYgYSBjbGFzcyBpcyBhcHBsaWVkIHRoYXQgaGFzIGFuIGFscGhhIGZpbHRlciwgaXQgd2lsbCB0YWtlIGVmZmVjdCAod2UgZG9uJ3Qgd2FudCB0aGF0KSwgc28gcmUtYXBwbHkgb3VyIGFscGhhIGZpbHRlciBpbiB0aGF0IGNhc2UuIFdlIG11c3QgZmlyc3QgcmVtb3ZlIGl0IGFuZCB0aGVuIGNoZWNrLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfYWxwaGFGaWx0ZXJFeHAsIFwiXCIpO1xuXHRcdFx0XHRcdFx0c2tpcCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnhuMSkge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzID0gZmlsdGVycyB8fCAoXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCIpOyAvL3dvcmtzIGFyb3VuZCBidWcgaW4gSUU3LzggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseSBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEgb24gdGhlIHNhbWUgZnJhbWUuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJwYWNpdHlcIikgPT09IC0xKSB7IC8vb25seSB1c2VkIGlmIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHN0eWxlIHByb3BlcnR5IChJRSA3IGFuZCA4KS4gV2Ugb21pdCB0aGUgXCJPXCIgdG8gYXZvaWQgY2FzZS1zZW5zaXRpdml0eSBpc3N1ZXNcblx0XHRcdFx0XHRcdGlmICh2YWwgIT09IDAgfHwgIXRoaXMueG4xKSB7IC8vYnVncyBpbiBJRTcvOCB3b24ndCByZW5kZXIgdGhlIGZpbHRlciBwcm9wZXJseSBpZiBvcGFjaXR5IGlzIEFEREVEIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBcInZpc2liaWxpdHlcIiBjaGFuZ2VzICh0aGlzLnhuMSBpcyAxIGlmIHRoaXMgdHdlZW4gaXMgYW4gXCJhdXRvQWxwaGFcIiB0d2Vlbilcblx0XHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzICsgXCIgYWxwaGEob3BhY2l0eT1cIiArIHZhbCArIFwiKVwiOyAvL3dlIHJvdW5kIHRoZSB2YWx1ZSBiZWNhdXNlIG90aGVyd2lzZSwgYnVncyBpbiBJRTcvOCBjYW4gcHJldmVudCBcInZpc2liaWxpdHlcIiBjaGFuZ2VzIGZyb20gYmVpbmcgYXBwbGllZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dC5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX29wYWNpdHlFeHAsIFwib3BhY2l0eT1cIiArIHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIsIHtkZWZhdWx0VmFsdWU6XCIxXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYiA9IHBhcnNlRmxvYXQoX2dldFN0eWxlKHQsIFwib3BhY2l0eVwiLCBfY3MsIGZhbHNlLCBcIjFcIikpLFxuXHRcdFx0XHRzdHlsZSA9IHQuc3R5bGUsXG5cdFx0XHRcdGlzQXV0b0FscGhhID0gKHAgPT09IFwiYXV0b0FscGhhXCIpO1xuXHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJzdHJpbmdcIiAmJiBlLmNoYXJBdCgxKSA9PT0gXCI9XCIpIHtcblx0XHRcdFx0ZSA9ICgoZS5jaGFyQXQoMCkgPT09IFwiLVwiKSA/IC0xIDogMSkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSArIGI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEgJiYgYiA9PT0gMSAmJiBfZ2V0U3R5bGUodCwgXCJ2aXNpYmlsaXR5XCIsIF9jcykgPT09IFwiaGlkZGVuXCIgJiYgZSAhPT0gMCkgeyAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuXHRcdFx0XHRiID0gMDtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIsIGUgLSBiLCBwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIFwib3BhY2l0eVwiLCBiICogMTAwLCAoZSAtIGIpICogMTAwLCBwdCk7XG5cdFx0XHRcdHB0LnhuMSA9IGlzQXV0b0FscGhhID8gMSA6IDA7IC8vd2UgbmVlZCB0byByZWNvcmQgd2hldGhlciBvciBub3QgdGhpcyBpcyBhbiBhdXRvQWxwaGEgc28gdGhhdCBpbiB0aGUgc2V0UmF0aW8oKSwgd2Uga25vdyB0byBkdXBsaWNhdGUgdGhlIHNldHRpbmcgb2YgdGhlIGFscGhhIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFNyBhbmQgSUU4IHRoYXQgcHJldmVudHMgY2hhbmdlcyB0byBcInZpc2liaWxpdHlcIiBmcm9tIHRha2luZyBlZmZlY3QgaWYgdGhlIGZpbHRlciBpcyBjaGFuZ2VkIHRvIGEgZGlmZmVyZW50IGFscGhhKG9wYWNpdHkpIGF0IHRoZSBzYW1lIHRpbWUuIFNldHRpbmcgaXQgdG8gdGhlIFNBTUUgdmFsdWUgZmlyc3QsIHRoZW4gdGhlIG5ldyB2YWx1ZSB3b3JrcyBhcm91bmQgdGhlIElFNy84IGJ1Zy5cblx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0cHQudHlwZSA9IDI7XG5cdFx0XHRcdHB0LmIgPSBcImFscGhhKG9wYWNpdHk9XCIgKyBwdC5zICsgXCIpXCI7XG5cdFx0XHRcdHB0LmUgPSBcImFscGhhKG9wYWNpdHk9XCIgKyAocHQucyArIHB0LmMpICsgXCIpXCI7XG5cdFx0XHRcdHB0LmRhdGEgPSB0O1xuXHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHB0LnNldFJhdGlvID0gX3NldElFT3BhY2l0eVJhdGlvO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXV0b0FscGhhKSB7IC8vd2UgaGF2ZSB0byBjcmVhdGUgdGhlIFwidmlzaWJpbGl0eVwiIFByb3BUd2VlbiBhZnRlciB0aGUgb3BhY2l0eSBvbmUgaW4gdGhlIGxpbmtlZCBsaXN0IHNvIHRoYXQgdGhleSBydW4gaW4gdGhlIG9yZGVyIHRoYXQgd29ya3MgcHJvcGVybHkgaW4gSUU4IGFuZCBlYXJsaWVyXG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJ2aXNpYmlsaXR5XCIsIDAsIDAsIHB0LCAtMSwgbnVsbCwgZmFsc2UsIDAsICgoYiAhPT0gMCkgPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIpLCAoKGUgPT09IDApID8gXCJoaWRkZW5cIiA6IFwiaW5oZXJpdFwiKSk7XG5cdFx0XHRcdHB0LnhzMCA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHB0Lm4pO1xuXHRcdFx0XHRjc3NwLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXG5cdFx0dmFyIF9yZW1vdmVQcm9wID0gZnVuY3Rpb24ocywgcCkge1xuXHRcdFx0XHRpZiAocCkge1xuXHRcdFx0XHRcdGlmIChzLnJlbW92ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRpZiAocC5zdWJzdHIoMCwyKSA9PT0gXCJtc1wiIHx8IHAuc3Vic3RyKDAsNikgPT09IFwid2Via2l0XCIpIHsgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuXHRcdFx0XHRcdFx0XHRwID0gXCItXCIgKyBwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cy5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vbm90ZTogb2xkIHZlcnNpb25zIG9mIElFIHVzZSBcInJlbW92ZUF0dHJpYnV0ZSgpXCIgaW5zdGVhZCBvZiBcInJlbW92ZVByb3BlcnR5KClcIlxuXHRcdFx0XHRcdFx0cy5yZW1vdmVBdHRyaWJ1dGUocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3NldENsYXNzTmFtZVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IHRoaXM7XG5cdFx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgKHYgPT09IDApID8gdGhpcy5iIDogdGhpcy5lKTtcblx0XHRcdFx0XHR2YXIgbXB0ID0gdGhpcy5kYXRhLCAvL2ZpcnN0IE1pbmlQcm9wVHdlZW5cblx0XHRcdFx0XHRcdHMgPSB0aGlzLnQuc3R5bGU7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0aWYgKCFtcHQudikge1xuXHRcdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBtcHQucCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzW21wdC5wXSA9IG1wdC52O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodiA9PT0gMSAmJiB0aGlzLnQuX2dzQ2xhc3NQVCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy50Ll9nc0NsYXNzUFQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgIT09IHRoaXMuZSkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsYXNzTmFtZVwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4sIHZhcnMpIHtcblx0XHRcdHZhciBiID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiLCAvL2Rvbid0IHVzZSB0LmNsYXNzTmFtZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgd29yayBjb25zaXN0ZW50bHkgb24gU1ZHIGVsZW1lbnRzOyBnZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSBhbmQgc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdmFsdWVcIikgaXMgbW9yZSByZWxpYWJsZS5cblx0XHRcdFx0Y3NzVGV4dCA9IHQuc3R5bGUuY3NzVGV4dCxcblx0XHRcdFx0ZGlmRGF0YSwgYnMsIGNucHQsIGNucHRMb29rdXAsIG1wdDtcblx0XHRcdHB0ID0gY3NzcC5fY2xhc3NOYW1lUFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsYXNzTmFtZVJhdGlvO1xuXHRcdFx0cHQucHIgPSAtMTE7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cHQuYiA9IGI7XG5cdFx0XHRicyA9IF9nZXRBbGxTdHlsZXModCwgX2NzKTtcblx0XHRcdC8vaWYgdGhlcmUncyBhIGNsYXNzTmFtZSB0d2VlbiBhbHJlYWR5IG9wZXJhdGluZyBvbiB0aGUgdGFyZ2V0LCBmb3JjZSBpdCB0byBpdHMgZW5kIHNvIHRoYXQgdGhlIG5lY2Vzc2FyeSBpbmxpbmUgc3R5bGVzIGFyZSByZW1vdmVkIGFuZCB0aGUgY2xhc3MgbmFtZSBpcyBhcHBsaWVkIGJlZm9yZSB3ZSBkZXRlcm1pbmUgdGhlIGVuZCBzdGF0ZSAod2UgZG9uJ3Qgd2FudCBpbmxpbmUgc3R5bGVzIGludGVyZmVyaW5nIHRoYXQgd2VyZSB0aGVyZSBqdXN0IGZvciBjbGFzcy1zcGVjaWZpYyB2YWx1ZXMpXG5cdFx0XHRjbnB0ID0gdC5fZ3NDbGFzc1BUO1xuXHRcdFx0aWYgKGNucHQpIHtcblx0XHRcdFx0Y25wdExvb2t1cCA9IHt9O1xuXHRcdFx0XHRtcHQgPSBjbnB0LmRhdGE7IC8vZmlyc3QgTWluaVByb3BUd2VlbiB3aGljaCBzdG9yZXMgdGhlIGlubGluZSBzdHlsZXMgLSB3ZSBuZWVkIHRvIGZvcmNlIHRoZXNlIHNvIHRoYXQgdGhlIGlubGluZSBzdHlsZXMgZG9uJ3QgY29udGFtaW5hdGUgdGhpbmdzLiBPdGhlcndpc2UsIHRoZXJlJ3MgYSBzbWFsbCBjaGFuY2UgdGhhdCBhIHR3ZWVuIGNvdWxkIHN0YXJ0IGFuZCB0aGUgaW5saW5lIHZhbHVlcyBtYXRjaCB0aGUgZGVzdGluYXRpb24gdmFsdWVzIGFuZCB0aGV5IG5ldmVyIGdldCBjbGVhbmVkLlxuXHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0Y25wdExvb2t1cFttcHQucF0gPSAxO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbnB0LnNldFJhdGlvKDEpO1xuXHRcdFx0fVxuXHRcdFx0dC5fZ3NDbGFzc1BUID0gcHQ7XG5cdFx0XHRwdC5lID0gKGUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlIDogYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGUuY2hhckF0KDApID09PSBcIitcIikgPyBcIiBcIiArIGUuc3Vic3RyKDIpIDogXCJcIik7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHB0LmUpO1xuXHRcdFx0ZGlmRGF0YSA9IF9jc3NEaWYodCwgYnMsIF9nZXRBbGxTdHlsZXModCksIHZhcnMsIGNucHRMb29rdXApO1xuXHRcdFx0dC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBiKTtcblx0XHRcdHB0LmRhdGEgPSBkaWZEYXRhLmZpcnN0TVBUO1xuXHRcdFx0dC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDsgLy93ZSByZWNvcmRlZCBjc3NUZXh0IGJlZm9yZSB3ZSBzd2FwcGVkIGNsYXNzZXMgYW5kIHJhbiBfZ2V0QWxsU3R5bGVzKCkgYmVjYXVzZSBpbiBjYXNlcyB3aGVuIGEgY2xhc3NOYW1lIHR3ZWVuIGlzIG92ZXJ3cml0dGVuLCB3ZSByZW1vdmUgYWxsIHRoZSByZWxhdGVkIHR3ZWVuaW5nIHByb3BlcnRpZXMgZnJvbSB0aGF0IGNsYXNzIGNoYW5nZSAob3RoZXJ3aXNlIGNsYXNzLXNwZWNpZmljIHN0dWZmIGNhbid0IG92ZXJyaWRlIHByb3BlcnRpZXMgd2UndmUgZGlyZWN0bHkgc2V0IG9uIHRoZSB0YXJnZXQncyBzdHlsZSBvYmplY3QgZHVlIHRvIHNwZWNpZmljaXR5KS5cblx0XHRcdHB0ID0gcHQueGZpcnN0ID0gY3NzcC5wYXJzZSh0LCBkaWZEYXRhLmRpZnMsIHB0LCBwbHVnaW4pOyAvL3dlIHJlY29yZCB0aGUgQ1NTUHJvcFR3ZWVuIGFzIHRoZSB4Zmlyc3Qgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIG92ZXJ3cml0aW5nIHByb3BlcnRseSAoaWYgXCJjbGFzc05hbWVcIiBnZXRzIG92ZXJ3cml0dGVuLCB3ZSBtdXN0IGtpbGwgYWxsIHRoZSBwcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xhc3NOYW1lIHBhcnQgb2YgdGhlIHR3ZWVuLCBzbyB3ZSBjYW4gbG9vcCB0aHJvdWdoIGZyb20geGZpcnN0IHRvIHRoZSBwdCBpdHNlbGYpXG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3NldENsZWFyUHJvcHNSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdGlmICh2ID09PSAxIHx8IHYgPT09IDApIGlmICh0aGlzLmRhdGEuX3RvdGFsVGltZSA9PT0gdGhpcy5kYXRhLl90b3RhbER1cmF0aW9uICYmIHRoaXMuZGF0YS5kYXRhICE9PSBcImlzRnJvbVN0YXJ0XCIpIHsgLy90aGlzLmRhdGEgcmVmZXJzIHRvIHRoZSB0d2Vlbi4gT25seSBjbGVhciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgbWFrZSB0aGUgcmF0aW8gZ28gZnJvbSAxIHRvIDAsIHNvIHdlIGNhbid0IGp1c3QgY2hlY2sgdGhhdCBhbmQgaWYgdGhlIHR3ZWVuIGlzIHRoZSB6ZXJvLWR1cmF0aW9uIG9uZSB0aGF0J3MgY3JlYXRlZCBpbnRlcm5hbGx5IHRvIHJlbmRlciB0aGUgc3RhcnRpbmcgdmFsdWVzIGluIGEgZnJvbSgpIHR3ZWVuLCBpZ25vcmUgdGhhdCBiZWNhdXNlIG90aGVyd2lzZSwgZm9yIGV4YW1wbGUsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluKS5cblx0XHRcdFx0dmFyIHMgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0dHJhbnNmb3JtUGFyc2UgPSBfc3BlY2lhbFByb3BzLnRyYW5zZm9ybS5wYXJzZSxcblx0XHRcdFx0XHRhLCBwLCBpLCBjbGVhclRyYW5zZm9ybSwgdHJhbnNmb3JtO1xuXHRcdFx0XHRpZiAodGhpcy5lID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdFx0cy5jc3NUZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHRoaXMuZS5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IGFbaV07XG5cdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoX3NwZWNpYWxQcm9wc1twXS5wYXJzZSA9PT0gdHJhbnNmb3JtUGFyc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhclRyYW5zZm9ybSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cCA9IChwID09PSBcInRyYW5zZm9ybU9yaWdpblwiKSA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3NwZWNpYWxQcm9wc1twXS5wOyAvL2Vuc3VyZXMgdGhhdCBzcGVjaWFsIHByb3BlcnRpZXMgdXNlIHRoZSBwcm9wZXIgYnJvd3Nlci1zcGVjaWZpYyBwcm9wZXJ0eSBuYW1lLCBsaWtlIFwic2NhbGVYXCIgbWlnaHQgYmUgXCItd2Via2l0LXRyYW5zZm9ybVwiIG9yIFwiYm94U2hhZG93XCIgbWlnaHQgYmUgXCItbW96LWJveC1zaGFkb3dcIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNsZWFyVHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0X3JlbW92ZVByb3AocywgX3RyYW5zZm9ybVByb3ApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybSA9IHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zZm9ybS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcblx0XHRcdFx0XHRcdFx0dGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLnQuX2dzVHJhbnNmb3JtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJjbGVhclByb3BzXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQpIHtcblx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBwLCAwLCAwLCBwdCwgMik7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IF9zZXRDbGVhclByb3BzUmF0aW87XG5cdFx0XHRwdC5lID0gZTtcblx0XHRcdHB0LnByID0gLTEwO1xuXHRcdFx0cHQuZGF0YSA9IGNzc3AuX3R3ZWVuO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblx0XHRwID0gXCJiZXppZXIsdGhyb3dQcm9wcyxwaHlzaWNzUHJvcHMscGh5c2ljczJEXCIuc3BsaXQoXCIsXCIpO1xuXHRcdGkgPSBwLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wKHBbaV0pO1xuXHRcdH1cblxuXG5cblxuXG5cblxuXG5cdFx0cCA9IENTU1BsdWdpbi5wcm90b3R5cGU7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPSBwLl90cmFuc2Zvcm0gPSBudWxsO1xuXG5cdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBraWNrcyBldmVyeXRoaW5nIG9mZiwgcmVjb3JkaW5nIHN0YXJ0L2VuZCB2YWx1ZXMsIGV0Yy5cblx0XHRwLl9vbkluaXRUd2VlbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4KSB7XG5cdFx0XHRpZiAoIXRhcmdldC5ub2RlVHlwZSkgeyAvL2NzcyBpcyBvbmx5IGZvciBkb20gZWxlbWVudHNcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGFyZ2V0ID0gX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHR0aGlzLl92YXJzID0gdmFycztcblx0XHRcdF9pbmRleCA9IGluZGV4O1xuXHRcdFx0X2F1dG9Sb3VuZCA9IHZhcnMuYXV0b1JvdW5kO1xuXHRcdFx0X2hhc1ByaW9yaXR5ID0gZmFsc2U7XG5cdFx0XHRfc3VmZml4TWFwID0gdmFycy5zdWZmaXhNYXAgfHwgQ1NTUGx1Z2luLnN1ZmZpeE1hcDtcblx0XHRcdF9jcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgXCJcIik7XG5cdFx0XHRfb3ZlcndyaXRlUHJvcHMgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcztcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0diwgcHQsIHB0MiwgZmlyc3QsIGxhc3QsIG5leHQsIHpJbmRleCwgdHB0LCB0aHJlZUQ7XG5cdFx0XHRpZiAoX3JlcVNhZmFyaUZpeCkgaWYgKHN0eWxlLnpJbmRleCA9PT0gXCJcIikge1xuXHRcdFx0XHR2ID0gX2dldFN0eWxlKHRhcmdldCwgXCJ6SW5kZXhcIiwgX2NzKTtcblx0XHRcdFx0aWYgKHYgPT09IFwiYXV0b1wiIHx8IHYgPT09IFwiXCIpIHtcblx0XHRcdFx0XHQvL2NvcnJlY3RzIGEgYnVnIGluIFtub24tQW5kcm9pZF0gU2FmYXJpIHRoYXQgcHJldmVudHMgaXQgZnJvbSByZXBhaW50aW5nIGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMgaWYgdGhleSBkb24ndCBoYXZlIGEgekluZGV4IHNldC4gV2UgYWxzbyBjYW4ndCBqdXN0IGFwcGx5IHRoaXMgaW5zaWRlIF9wYXJzZVRyYW5zZm9ybSgpIGJlY2F1c2UgYW55dGhpbmcgdGhhdCdzIG1vdmVkIGluIGFueSB3YXkgKGxpa2UgdXNpbmcgXCJsZWZ0XCIgb3IgXCJ0b3BcIiBpbnN0ZWFkIG9mIHRyYW5zZm9ybXMgbGlrZSBcInhcIiBhbmQgXCJ5XCIpIGNhbiBiZSBhZmZlY3RlZCwgc28gaXQgaXMgYmVzdCB0byBlbnN1cmUgdGhhdCBhbnl0aGluZyB0aGF0J3MgdHdlZW5pbmcgaGFzIGEgei1pbmRleC4gU2V0dGluZyBcIldlYmtpdFBlcnNwZWN0aXZlXCIgdG8gYSBub24temVybyB2YWx1ZSB3b3JrZWQgdG9vIGV4Y2VwdCB0aGF0IG9uIGlPUyBTYWZhcmkgdGhpbmdzIHdvdWxkIGZsaWNrZXIgcmFuZG9tbHkuIFBsdXMgekluZGV4IGlzIGxlc3MgbWVtb3J5LWludGVuc2l2ZS5cblx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcInpJbmRleFwiLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mKHZhcnMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGZpcnN0ID0gc3R5bGUuY3NzVGV4dDtcblx0XHRcdFx0diA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCBfY3MpO1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3QgKyBcIjtcIiArIHZhcnM7XG5cdFx0XHRcdHYgPSBfY3NzRGlmKHRhcmdldCwgdiwgX2dldEFsbFN0eWxlcyh0YXJnZXQpKS5kaWZzO1xuXHRcdFx0XHRpZiAoIV9zdXBwb3J0c09wYWNpdHkgJiYgX29wYWNpdHlWYWxFeHAudGVzdCh2YXJzKSkge1xuXHRcdFx0XHRcdHYub3BhY2l0eSA9IHBhcnNlRmxvYXQoIFJlZ0V4cC4kMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMgPSB2O1xuXHRcdFx0XHRzdHlsZS5jc3NUZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YXJzLmNsYXNzTmFtZSkgeyAvL2NsYXNzTmFtZSB0d2VlbnMgd2lsbCBjb21iaW5lIGFueSBkaWZmZXJlbmNlcyB0aGV5IGZpbmQgaW4gdGhlIGNzcyB3aXRoIHRoZSB2YXJzIHRoYXQgYXJlIHBhc3NlZCBpbiwgc28ge2NsYXNzTmFtZTpcIm15Q2xhc3NcIiwgc2NhbGU6MC41LCBsZWZ0OjIwfSB3b3VsZCB3b3JrLlxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQgPSBfc3BlY2lhbFByb3BzLmNsYXNzTmFtZS5wYXJzZSh0YXJnZXQsIHZhcnMuY2xhc3NOYW1lLCBcImNsYXNzTmFtZVwiLCB0aGlzLCBudWxsLCBudWxsLCB2YXJzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IHRoaXMucGFyc2UodGFyZ2V0LCB2YXJzLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3RyYW5zZm9ybVR5cGUpIHtcblx0XHRcdFx0dGhyZWVEID0gKHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpO1xuXHRcdFx0XHRpZiAoIV90cmFuc2Zvcm1Qcm9wKSB7XG5cdFx0XHRcdFx0c3R5bGUuem9vbSA9IDE7IC8vaGVscHMgY29ycmVjdCBhbiBJRSBpc3N1ZS5cblx0XHRcdFx0fSBlbHNlIGlmIChfaXNTYWZhcmkpIHtcblx0XHRcdFx0XHRfcmVxU2FmYXJpRml4ID0gdHJ1ZTtcblx0XHRcdFx0XHQvL2lmIHpJbmRleCBpc24ndCBzZXQsIGlPUyBTYWZhcmkgZG9lc24ndCByZXBhaW50IHRoaW5ncyBjb3JyZWN0bHkgc29tZXRpbWVzIChzZWVtaW5nbHkgYXQgcmFuZG9tKS5cblx0XHRcdFx0XHRpZiAoc3R5bGUuekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHR6SW5kZXggPSBfZ2V0U3R5bGUodGFyZ2V0LCBcInpJbmRleFwiLCBfY3MpO1xuXHRcdFx0XHRcdFx0aWYgKHpJbmRleCA9PT0gXCJhdXRvXCIgfHwgekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiekluZGV4XCIsIDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL1NldHRpbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGNvcnJlY3RzIDMgYnVnczpcblx0XHRcdFx0XHQvLyAxKSBbbm9uLUFuZHJvaWRdIFNhZmFyaSBza2lwcyByZW5kZXJpbmcgY2hhbmdlcyB0byBcInRvcFwiIGFuZCBcImxlZnRcIiB0aGF0IGFyZSBtYWRlIG9uIHRoZSBzYW1lIGZyYW1lL3JlbmRlciBhcyBhIHRyYW5zZm9ybSB1cGRhdGUuXG5cdFx0XHRcdFx0Ly8gMikgaU9TIFNhZmFyaSBzb21ldGltZXMgbmVnbGVjdHMgdG8gcmVwYWludCBlbGVtZW50cyBpbiB0aGVpciBuZXcgcG9zaXRpb25zLiBTZXR0aW5nIFwiV2Via2l0UGVyc3BlY3RpdmVcIiB0byBhIG5vbi16ZXJvIHZhbHVlIHdvcmtlZCB0b28gZXhjZXB0IHRoYXQgb24gaU9TIFNhZmFyaSB0aGluZ3Mgd291bGQgZmxpY2tlciByYW5kb21seS5cblx0XHRcdFx0XHQvLyAzKSBTYWZhcmkgc29tZXRpbWVzIGRpc3BsYXllZCBvZGQgYXJ0aWZhY3RzIHdoZW4gdHdlZW5pbmcgdGhlIHRyYW5zZm9ybSAob3IgV2Via2l0VHJhbnNmb3JtKSBwcm9wZXJ0eSwgbGlrZSBnaG9zdHMgb2YgdGhlIGVkZ2VzIG9mIHRoZSBlbGVtZW50IHJlbWFpbmVkLiBEZWZpbml0ZWx5IGEgYnJvd3NlciBidWcuXG5cdFx0XHRcdFx0Ly9Ob3RlOiB3ZSBhbGxvdyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgYXV0by1zZXR0aW5nIGJ5IGRlZmluaW5nIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSBpbiB0aGUgdmFycyBvZiB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0aWYgKF9pc1NhZmFyaUxUNikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIiwgdGhpcy5fdmFycy5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgfHwgKHRocmVlRCA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwdDIgPSBwdDtcblx0XHRcdFx0d2hpbGUgKHB0MiAmJiBwdDIuX25leHQpIHtcblx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0YXJnZXQsIFwidHJhbnNmb3JtXCIsIDAsIDAsIG51bGwsIDIpO1xuXHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh0cHQsIG51bGwsIHB0Mik7XG5cdFx0XHRcdHRwdC5zZXRSYXRpbyA9IF90cmFuc2Zvcm1Qcm9wID8gX3NldFRyYW5zZm9ybVJhdGlvIDogX3NldElFVHJhbnNmb3JtUmF0aW87XG5cdFx0XHRcdHRwdC5kYXRhID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGFyZ2V0LCBfY3MsIHRydWUpO1xuXHRcdFx0XHR0cHQudHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0dHB0LnByID0gLTE7IC8vZW5zdXJlcyB0aGF0IHRoZSB0cmFuc2Zvcm1zIGdldCBhcHBsaWVkIGFmdGVyIHRoZSBjb21wb25lbnRzIGFyZSB1cGRhdGVkLlxuXHRcdFx0XHRfb3ZlcndyaXRlUHJvcHMucG9wKCk7IC8vd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSB0aGUgb3ZlcndyaXRlIG9mIGFsbCBcInRyYW5zZm9ybVwiIHR3ZWVucyBvZiB0aGUgdGFyZ2V0IC0gd2Ugb25seSBjYXJlIGFib3V0IGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnRpZXMgbGlrZSBzY2FsZVgsIHJvdGF0aW9uLCBldGMuIFRoZSBDU1NQcm9wVHdlZW4gY29uc3RydWN0b3IgYXV0b21hdGljYWxseSBhZGRzIHRoZSBwcm9wZXJ0eSB0byBfb3ZlcndyaXRlUHJvcHMgd2hpY2ggaXMgd2h5IHdlIG5lZWQgdG8gcG9wKCkgaGVyZS5cblx0XHRcdH1cblxuXHRcdFx0aWYgKF9oYXNQcmlvcml0eSkge1xuXHRcdFx0XHQvL3Jlb3JkZXJzIHRoZSBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwciAocHJpb3JpdHkpXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9O1xuXG5cblx0XHRwLnBhcnNlID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG5cdFx0XHRcdHAsIHNwLCBibiwgZW4sIGJzLCBlcywgYnNmeCwgZXNmeCwgaXNTdHIsIHJlbDtcblx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdGVzID0gdmFyc1twXTsgLy9lbmRpbmcgdmFsdWUgc3RyaW5nXG5cdFx0XHRcdGlmICh0eXBlb2YoZXMpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlcyA9IGVzKF9pbmRleCwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3AgPSBfc3BlY2lhbFByb3BzW3BdOyAvL1NwZWNpYWxQcm9wIGxvb2t1cC5cblx0XHRcdFx0aWYgKHNwKSB7XG5cdFx0XHRcdFx0cHQgPSBzcC5wYXJzZSh0YXJnZXQsIGVzLCBwLCB0aGlzLCBwdCwgcGx1Z2luLCB2YXJzKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJzID0gX2dldFN0eWxlKHRhcmdldCwgcCwgX2NzKSArIFwiXCI7XG5cdFx0XHRcdFx0aXNTdHIgPSAodHlwZW9mKGVzKSA9PT0gXCJzdHJpbmdcIik7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwiY29sb3JcIiB8fCBwID09PSBcImZpbGxcIiB8fCBwID09PSBcInN0cm9rZVwiIHx8IHAuaW5kZXhPZihcIkNvbG9yXCIpICE9PSAtMSB8fCAoaXNTdHIgJiYgX3JnYmhzbEV4cC50ZXN0KGVzKSkpIHsgLy9PcGVyYSB1c2VzIGJhY2tncm91bmQ6IHRvIGRlZmluZSBjb2xvciBzb21ldGltZXMgaW4gYWRkaXRpb24gdG8gYmFja2dyb3VuZENvbG9yOlxuXHRcdFx0XHRcdFx0aWYgKCFpc1N0cikge1xuXHRcdFx0XHRcdFx0XHRlcyA9IF9wYXJzZUNvbG9yKGVzKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSAoKGVzLmxlbmd0aCA+IDMpID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpICsgZXMuam9pbihcIixcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBcInRyYW5zcGFyZW50XCIsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc1N0ciAmJiBfY29tcGxleEV4cC50ZXN0KGVzKSkge1xuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIG51bGwsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdFx0XHRic2Z4ID0gKGJuIHx8IGJuID09PSAwKSA/IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpIDogXCJcIjsgLy9yZW1lbWJlciwgYnMgY291bGQgYmUgbm9uLW51bWVyaWMgbGlrZSBcIm5vcm1hbFwiIGZvciBmb250V2VpZ2h0LCBzbyB3ZSBzaG91bGQgZGVmYXVsdCB0byBhIGJsYW5rIHN1ZmZpeCBpbiB0aGF0IGNhc2UuXG5cblx0XHRcdFx0XHRcdGlmIChicyA9PT0gXCJcIiB8fCBicyA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfZ2V0RGltZW5zaW9uKHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9jYWxjdWxhdGVPZmZzZXQodGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSAocCAhPT0gXCJvcGFjaXR5XCIpID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVsID0gKGlzU3RyICYmIGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKSArIFwiMVwiLCAxMCk7XG5cdFx0XHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gaXNTdHIgPyBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IChwIGluIF9zdWZmaXhNYXApID8gX3N1ZmZpeE1hcFtwXSA6IGJzZng7IC8vcG9wdWxhdGUgdGhlIGVuZCBzdWZmaXgsIHByaW9yaXRpemluZyB0aGUgbWFwLCB0aGVuIGlmIG5vbmUgaXMgZm91bmQsIHVzZSB0aGUgYmVnaW5uaW5nIHN1ZmZpeC5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXMgPSAoZW4gfHwgZW4gPT09IDApID8gKHJlbCA/IGVuICsgYm4gOiBlbikgKyBlc2Z4IDogdmFyc1twXTsgLy9lbnN1cmVzIHRoYXQgYW55ICs9IG9yIC09IHByZWZpeGVzIGFyZSB0YWtlbiBjYXJlIG9mLiBSZWNvcmQgdGhlIGVuZCB2YWx1ZSBiZWZvcmUgbm9ybWFsaXppbmcgdGhlIHN1ZmZpeCBiZWNhdXNlIHdlIGFsd2F5cyB3YW50IHRvIGVuZCB0aGUgdHdlZW4gb24gZXhhY3RseSB3aGF0IHRoZXkgaW50ZW5kZWQgZXZlbiBpZiBpdCBkb2Vzbid0IG1hdGNoIHRoZSBiZWdpbm5pbmcgdmFsdWUncyBzdWZmaXguXG5cblx0XHRcdFx0XHRcdC8vaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgZG9uJ3QgbWF0Y2gsIG5vcm1hbGl6ZSB0aGVtLi4uXG5cdFx0XHRcdFx0XHRpZiAoYnNmeCAhPT0gZXNmeCkgaWYgKGVzZnggIT09IFwiXCIpIGlmIChlbiB8fCBlbiA9PT0gMCkgaWYgKGJuKSB7IC8vbm90ZTogaWYgdGhlIGJlZ2lubmluZyB2YWx1ZSAoYm4pIGlzIDAsIHdlIGRvbid0IG5lZWQgdG8gY29udmVydCB1bml0cyFcblx0XHRcdFx0XHRcdFx0Ym4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgYm4sIGJzZngpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZXNmeCA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMTAwLCBcIiVcIikgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhcnMuc3RyaWN0VW5pdHMgIT09IHRydWUpIHsgLy9zb21lIGJyb3dzZXJzIHJlcG9ydCBvbmx5IFwicHhcIiB2YWx1ZXMgaW5zdGVhZCBvZiBhbGxvd2luZyBcIiVcIiB3aXRoIGdldENvbXB1dGVkU3R5bGUoKSwgc28gd2UgYXNzdW1lIHRoYXQgaWYgd2UncmUgdHdlZW5pbmcgdG8gYSAlLCB3ZSBzaG91bGQgc3RhcnQgdGhlcmUgdG9vIHVubGVzcyBzdHJpY3RVbml0czp0cnVlIGlzIGRlZmluZWQuIFRoaXMgYXBwcm9hY2ggaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgcmVzcG9uc2l2ZSBkZXNpZ25zIHRoYXQgdXNlIGZyb20oKSB0d2VlbnMuXG5cdFx0XHRcdFx0XHRcdFx0XHRicyA9IGJuICsgXCIlXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCA9PT0gXCJlbVwiIHx8IGVzZnggPT09IFwicmVtXCIgfHwgZXNmeCA9PT0gXCJ2d1wiIHx8IGVzZnggPT09IFwidmhcIikge1xuXHRcdFx0XHRcdFx0XHRcdGJuIC89IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCAxLCBlc2Z4KTtcblxuXHRcdFx0XHRcdFx0XHQvL290aGVyd2lzZSBjb252ZXJ0IHRvIHBpeGVscy5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlc2Z4ICE9PSBcInB4XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRlbiA9IF9jb252ZXJ0VG9QaXhlbHModGFyZ2V0LCBwLCBlbiwgZXNmeCk7XG5cdFx0XHRcdFx0XHRcdFx0ZXNmeCA9IFwicHhcIjsgLy93ZSBkb24ndCB1c2UgYnNmeCBhZnRlciB0aGlzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHNldCBpdCB0byBweCB0b28uXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHJlbCkgaWYgKGVuIHx8IGVuID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXMgPSAoZW4gKyBibikgKyBlc2Z4OyAvL3RoZSBjaGFuZ2VzIHdlIG1hZGUgYWZmZWN0IHJlbGF0aXZlIGNhbGN1bGF0aW9ucywgc28gYWRqdXN0IHRoZSBlbmQgdmFsdWUgaGVyZS5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAocmVsKSB7XG5cdFx0XHRcdFx0XHRcdGVuICs9IGJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoKGJuIHx8IGJuID09PSAwKSAmJiAoZW4gfHwgZW4gPT09IDApKSB7IC8vZmFzdGVyIHRoYW4gaXNOYU4oKS4gQWxzbywgcHJldmlvdXNseSB3ZSByZXF1aXJlZCBlbiAhPT0gYm4gYnV0IHRoYXQgZG9lc24ndCByZWFsbHkgZ2FpbiBtdWNoIHBlcmZvcm1hbmNlIGFuZCBpdCBwcmV2ZW50cyBfcGFyc2VUb1Byb3h5KCkgZnJvbSB3b3JraW5nIHByb3Blcmx5IGlmIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBtYXRjaCBidXQgbmVlZCB0byBnZXQgdHdlZW5lZCBieSBhbiBleHRlcm5hbCBwbHVnaW4gYW55d2F5LiBGb3IgZXhhbXBsZSwgYSBiZXppZXIgdHdlZW4gd2hlcmUgdGhlIHRhcmdldCBzdGFydHMgYXQgbGVmdDowIGFuZCBoYXMgdGhlc2UgcG9pbnRzOiBbe2xlZnQ6NTB9LHtsZWZ0OjB9XSB3b3VsZG4ndCB3b3JrIHByb3Blcmx5IGJlY2F1c2Ugd2hlbiBwYXJzaW5nIHRoZSBsYXN0IHBvaW50LCBpdCdkIG1hdGNoIHRoZSBmaXJzdCAoY3VycmVudCkgb25lIGFuZCBhIG5vbi10d2VlbmluZyBDU1NQcm9wVHdlZW4gd291bGQgYmUgcmVjb3JkZWQgd2hlbiB3ZSBhY3R1YWxseSBuZWVkIGEgbm9ybWFsIHR3ZWVuICh0eXBlOjApIHNvIHRoYXQgdGhpbmdzIGdldCB1cGRhdGVkIGR1cmluZyB0aGUgdHdlZW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgYm4sIGVuIC0gYm4sIHB0LCAwLCBwLCAoX2F1dG9Sb3VuZCAhPT0gZmFsc2UgJiYgKGVzZnggPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSksIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IGVzZng7XG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJ0d2VlbiBcIitwK1wiIGZyb20gXCIrcHQuYitcIiAoXCIrYm4rZXNmeCtcIikgdG8gXCIrcHQuZStcIiB3aXRoIHN1ZmZpeDogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3R5bGVbcF0gPT09IHVuZGVmaW5lZCB8fCAhZXMgJiYgKGVzICsgXCJcIiA9PT0gXCJOYU5cIiB8fCBlcyA9PSBudWxsKSkge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiaW52YWxpZCBcIiArIHAgKyBcIiB0d2VlbiB2YWx1ZTogXCIgKyB2YXJzW3BdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgZW4gfHwgYm4gfHwgMCwgMCwgcHQsIC0xLCBwLCBmYWxzZSwgMCwgYnMsIGVzKTtcblx0XHRcdFx0XHRcdFx0cHQueHMwID0gKGVzID09PSBcIm5vbmVcIiAmJiAocCA9PT0gXCJkaXNwbGF5XCIgfHwgcC5pbmRleE9mKFwiU3R5bGVcIikgIT09IC0xKSkgPyBicyA6IGVzOyAvL2ludGVybWVkaWF0ZSB2YWx1ZSBzaG91bGQgdHlwaWNhbGx5IGJlIHNldCBpbW1lZGlhdGVseSAoZW5kIHZhbHVlKSBleGNlcHQgZm9yIFwiZGlzcGxheVwiIG9yIHRoaW5ncyBsaWtlIGJvcmRlclRvcFN0eWxlLCBib3JkZXJCb3R0b21TdHlsZSwgZXRjLiB3aGljaCBzaG91bGQgdXNlIHRoZSBiZWdpbm5pbmcgdmFsdWUgZHVyaW5nIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm5vbi10d2VlbmluZyB2YWx1ZSBcIitwK1wiOiBcIitwdC54czApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGx1Z2luKSBpZiAocHQgJiYgIXB0LnBsdWdpbikge1xuXHRcdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH07XG5cblxuXHRcdC8vZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgdHdlZW4gdXBkYXRlcywgcGFzc2luZyB0aGUgbmV3IHJhdGlvICh0eXBpY2FsbHkgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIGJ1dCBub3QgYWx3YXlzIChmb3IgZXhhbXBsZSwgaWYgYW4gRWxhc3RpYy5lYXNlT3V0IGlzIHVzZWQsIHRoZSB2YWx1ZSBjYW4ganVtcCBhYm92ZSAxIG1pZC10d2VlbikuIEl0IHdpbGwgYWx3YXlzIHN0YXJ0IGFuZCAwIGFuZCBlbmQgYXQgMS5cblx0XHRwLnNldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdHZhbCwgc3RyLCBpO1xuXHRcdFx0Ly9hdCB0aGUgZW5kIG9mIHRoZSB0d2Vlbiwgd2Ugc2V0IHRoZSB2YWx1ZXMgdG8gZXhhY3RseSB3aGF0IHdlIHJlY2VpdmVkIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBub24tdHdlZW5pbmcgdmFsdWVzIChsaWtlIFwicG9zaXRpb25cIiBvciBcImZsb2F0XCIgb3Igd2hhdGV2ZXIpIGFyZSBzZXQgYW5kIHNvIHRoYXQgaWYgdGhlIGJlZ2lubmluZy9lbmRpbmcgc3VmZml4ZXMgKHVuaXRzKSBkaWRuJ3QgbWF0Y2ggYW5kIHdlIG5vcm1hbGl6ZWQgdG8gcHgsIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIHBhc3NlZCBpbiBpcyB1c2VkIGhlcmUuIFdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHdlZW4gaXMgYXQgaXRzIGJlZ2lubmluZyBpbiBjYXNlIGl0J3MgYSBmcm9tKCkgdHdlZW4gaW4gd2hpY2ggY2FzZSB0aGUgcmF0aW8gd2lsbCBhY3R1YWxseSBnbyBmcm9tIDEgdG8gMCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlIHR3ZWVuIChiYWNrd2FyZHMpLlxuXHRcdFx0aWYgKHYgPT09IDEgJiYgKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRpZiAocHQuciAmJiBwdC50eXBlICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHB0LnMgKyBwdC5jKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7IC8vY29tcGxleCB2YWx1ZSAob25lIHRoYXQgdHlwaWNhbGx5IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluc2lkZSBhIHN0cmluZywgbGlrZSBcInJlY3QoNXB4LDEwcHgsMjBweCwyNXB4KVwiXG5cdFx0XHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgdmFsICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gc3RyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh2IHx8ICEodGhpcy5fdHdlZW4uX3RpbWUgPT09IHRoaXMuX3R3ZWVuLl9kdXJhdGlvbiB8fCB0aGlzLl90d2Vlbi5fdGltZSA9PT0gMCkgfHwgdGhpcy5fdHdlZW4uX3Jhd1ByZXZUaW1lID09PSAtMC4wMDAwMDEpIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0dmFsID0gcHQuYyAqIHYgKyBwdC5zO1xuXHRcdFx0XHRcdGlmIChwdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4pIGlmICh2YWwgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXB0LnR5cGUpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAxKSB7IC8vY29tcGxleCB2YWx1ZSAob25lIHRoYXQgdHlwaWNhbGx5IGhhcyBtdWx0aXBsZSBudW1iZXJzIGluc2lkZSBhIHN0cmluZywgbGlrZSBcInJlY3QoNXB4LDEwcHgsMjBweCwyNXB4KVwiXG5cdFx0XHRcdFx0XHRpID0gcHQubDtcblx0XHRcdFx0XHRcdGlmIChpID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNCkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czMgKyBwdC54bjMgKyBwdC54czQgKyBwdC54bjQgKyBwdC54czU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBwdC54czAgKyB2YWwgKyBwdC54czE7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC50eXBlID09PSAtMSkgeyAvL25vbi10d2VlbmluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQuc2V0UmF0aW8pIHsgLy9jdXN0b20gc2V0UmF0aW8oKSBmb3IgdGhpbmdzIGxpa2UgU3BlY2lhbFByb3BzLCBleHRlcm5hbCBwbHVnaW5zLCBldGMuXG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHQvL2lmIHRoZSB0d2VlbiBpcyByZXZlcnNlZCBhbGwgdGhlIHdheSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWVzIHdoaWNoIG1heSBoYXZlIGRpZmZlcmVudCB1bml0cyAobGlrZSAlIGluc3RlYWQgb2YgcHggb3IgZW0gb3Igd2hhdGV2ZXIpLlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LnR5cGUgIT09IDIpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC5iO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zZXRSYXRpbyh2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEZvcmNlcyByZW5kZXJpbmcgb2YgdGhlIHRhcmdldCdzIHRyYW5zZm9ybXMgKHJvdGF0aW9uLCBzY2FsZSwgZXRjLikgd2hlbmV2ZXIgdGhlIENTU1BsdWdpbidzIHNldFJhdGlvKCkgaXMgY2FsbGVkLlxuXHRcdCAqIEJhc2ljYWxseSwgdGhpcyB0ZWxscyB0aGUgQ1NTUGx1Z2luIHRvIGNyZWF0ZSBhIENTU1Byb3BUd2VlbiAodHlwZSAyKSBhZnRlciBpbnN0YW50aWF0aW9uIHRoYXQgcnVucyBsYXN0IGluIHRoZSBsaW5rZWRcblx0XHQgKiBsaXN0IGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgKDNEIG9yIDJEKSByZW5kZXJpbmcgZnVuY3Rpb24uIFdlIHNlcGFyYXRlIHRoaXMgaW50byBpdHMgb3duIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjYWxsXG5cdFx0ICogaXQgZnJvbSBvdGhlciBwbHVnaW5zIGxpa2UgQmV6aWVyUGx1Z2luIGlmLCBmb3IgZXhhbXBsZSwgaXQgbmVlZHMgdG8gYXBwbHkgYW4gYXV0b1JvdGF0aW9uIGFuZCB0aGlzIENTU1BsdWdpblxuXHRcdCAqIGRvZXNuJ3QgaGF2ZSBhbnkgdHJhbnNmb3JtLXJlbGF0ZWQgcHJvcGVydGllcyBvZiBpdHMgb3duLiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgYXMgbWFueSB0aW1lcyBhcyB5b3Vcblx0XHQgKiB3YW50IGFuZCBpdCB3b24ndCBjcmVhdGUgZHVwbGljYXRlIENTU1Byb3BUd2VlbnMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRocmVlRCBpZiB0cnVlLCBpdCBzaG91bGQgYXBwbHkgM0QgdHdlZW5zIChvdGhlcndpc2UsIGp1c3QgMkQgb25lcyBhcmUgZmluZSBhbmQgdHlwaWNhbGx5IGZhc3Rlcilcblx0XHQgKi9cblx0XHRwLl9lbmFibGVUcmFuc2Zvcm1zID0gZnVuY3Rpb24odGhyZWVEKSB7XG5cdFx0XHR0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0aGlzLl90YXJnZXQsIF9jcywgdHJ1ZSk7IC8vZW5zdXJlcyB0aGF0IHRoZSBlbGVtZW50IGhhcyBhIF9nc1RyYW5zZm9ybSBwcm9wZXJ0eSB3aXRoIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXMuXG5cdFx0XHR0aGlzLl90cmFuc2Zvcm1UeXBlID0gKCEodGhpcy5fdHJhbnNmb3JtLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKHRocmVlRCB8fCB0aGlzLl90cmFuc2Zvcm1UeXBlID09PSAzKSkgPyAzIDogMjtcblx0XHR9O1xuXG5cdFx0dmFyIGxhenlTZXQgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHR0aGlzLnRbdGhpcy5wXSA9IHRoaXMuZTtcblx0XHRcdHRoaXMuZGF0YS5fbGlua0NTU1AodGhpcywgdGhpcy5fbmV4dCwgbnVsbCwgdHJ1ZSk7IC8vd2UgcHVycG9zZWZ1bGx5IGtlZXAgdGhpcy5fbmV4dCBldmVuIHRob3VnaCBpdCdkIG1ha2Ugc2Vuc2UgdG8gbnVsbCBpdCwgYnV0IHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGFzIHRoaXMgaGFwcGVucyBkdXJpbmcgdGhlIHdoaWxlIChwdCkge30gbG9vcCBpbiBzZXRSYXRpbygpIGF0IHRoZSBib3R0b20gb2Ygd2hpY2ggaXQgc2V0cyBwdCA9IHB0Ll9uZXh0LCBzbyBpZiB3ZSBudWxsIGl0LCB0aGUgbGlua2VkIGxpc3Qgd2lsbCBiZSBicm9rZW4gaW4gdGhhdCBsb29wLlxuXHRcdH07XG5cdFx0LyoqIEBwcml2YXRlIEdpdmVzIHVzIGEgd2F5IHRvIHNldCBhIHZhbHVlIG9uIHRoZSBmaXJzdCByZW5kZXIgKGFuZCBvbmx5IHRoZSBmaXJzdCByZW5kZXIpLiAqKi9cblx0XHRwLl9hZGRMYXp5U2V0ID0gZnVuY3Rpb24odCwgcCwgdikge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgdGhpcy5fZmlyc3RQVCwgMik7XG5cdFx0XHRwdC5lID0gdjtcblx0XHRcdHB0LnNldFJhdGlvID0gbGF6eVNldDtcblx0XHRcdHB0LmRhdGEgPSB0aGlzO1xuXHRcdH07XG5cblx0XHQvKiogQHByaXZhdGUgKiovXG5cdFx0cC5fbGlua0NTU1AgPSBmdW5jdGlvbihwdCwgbmV4dCwgcHJldiwgcmVtb3ZlKSB7XG5cdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX3ByZXYpIHtcblx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0UFQgPT09IHB0KSB7XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHJlbW92ZSA9IHRydWU7IC8vanVzdCB0byBwcmV2ZW50IHJlc2V0dGluZyB0aGlzLl9maXJzdFBUIDUgbGluZXMgZG93biBpbiBjYXNlIHB0Ll9uZXh0IGlzIG51bGwuIChvcHRpbWl6ZWQgZm9yIHNwZWVkKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2KSB7XG5cdFx0XHRcdFx0cHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFyZW1vdmUgJiYgdGhpcy5fZmlyc3RQVCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdC5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdHB0Ll9wcmV2ID0gcHJldjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0cC5fbW9kID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YobG9va3VwW3B0LnBdKSA9PT0gXCJmdW5jdGlvblwiICYmIGxvb2t1cFtwdC5wXSA9PT0gTWF0aC5yb3VuZCkgeyAvL29ubHkgZ2V0cyBjYWxsZWQgYnkgUm91bmRQcm9wc1BsdWdpbiAoTW9kaWZ5UGx1Z2luIG1hbmFnZXMgYWxsIHRoZSByZW5kZXJpbmcgaW50ZXJuYWxseSBmb3IgQ1NTUGx1Z2luIHByb3BlcnRpZXMgdGhhdCBuZWVkIG1vZGlmaWNhdGlvbikuIFJlbWVtYmVyLCB3ZSBoYW5kbGUgcm91bmRpbmcgYSBiaXQgZGlmZmVyZW50bHkgaW4gdGhpcyBwbHVnaW4gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGxldmVyYWdpbmcgXCJyXCIgYXMgYW4gaW5kaWNhdG9yIHRoYXQgdGhlIHZhbHVlIHNob3VsZCBiZSByb3VuZGVkIGludGVybmFsbHkuLlxuXHRcdFx0XHRcdHB0LnIgPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBpZiBhbHBoYSBvciBhdXRvQWxwaGEgaXMga2lsbGVkLCBvcGFjaXR5IGlzIHRvby4gQW5kIGF1dG9BbHBoYSBhZmZlY3RzIHRoZSBcInZpc2liaWxpdHlcIiBwcm9wZXJ0eS5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24obG9va3VwKSB7XG5cdFx0XHR2YXIgY29weSA9IGxvb2t1cCxcblx0XHRcdFx0cHQsIHAsIHhmaXJzdDtcblx0XHRcdGlmIChsb29rdXAuYXV0b0FscGhhIHx8IGxvb2t1cC5hbHBoYSkge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiBsb29rdXApIHsgLy9jb3B5IHRoZSBsb29rdXAgc28gdGhhdCB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIG1heSBiZSBwYXNzZWQgZWxzZXdoZXJlLlxuXHRcdFx0XHRcdGNvcHlbcF0gPSBsb29rdXBbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5vcGFjaXR5ID0gMTtcblx0XHRcdFx0aWYgKGNvcHkuYXV0b0FscGhhKSB7XG5cdFx0XHRcdFx0Y29weS52aXNpYmlsaXR5ID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxvb2t1cC5jbGFzc05hbWUgJiYgKHB0ID0gdGhpcy5fY2xhc3NOYW1lUFQpKSB7IC8vZm9yIGNsYXNzTmFtZSB0d2VlbnMsIHdlIG5lZWQgdG8ga2lsbCBhbnkgYXNzb2NpYXRlZCBDU1NQcm9wVHdlZW5zIHRvbzsgYSBsaW5rZWQgbGlzdCBzdGFydHMgYXQgdGhlIGNsYXNzTmFtZSdzIFwieGZpcnN0XCIuXG5cdFx0XHRcdHhmaXJzdCA9IHB0LnhmaXJzdDtcblx0XHRcdFx0aWYgKHhmaXJzdCAmJiB4Zmlyc3QuX3ByZXYpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUCh4Zmlyc3QuX3ByZXYsIHB0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYuX3ByZXYpOyAvL2JyZWFrIG9mZiB0aGUgcHJldlxuXHRcdFx0XHR9IGVsc2UgaWYgKHhmaXJzdCA9PT0gdGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuX25leHQpIHtcblx0XHRcdFx0XHR0aGlzLl9saW5rQ1NTUChwdC5fbmV4dCwgcHQuX25leHQuX25leHQsIHhmaXJzdC5fcHJldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2xhc3NOYW1lUFQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cHQgPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChwdC5wbHVnaW4gJiYgcHQucGx1Z2luICE9PSBwICYmIHB0LnBsdWdpbi5fa2lsbCkgeyAvL2ZvciBwbHVnaW5zIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCBDU1NQbHVnaW4sIHdlIHNob3VsZCBub3RpZnkgdGhlbSBvZiB0aGUga2lsbC5cblx0XHRcdFx0XHRwdC5wbHVnaW4uX2tpbGwobG9va3VwKTtcblx0XHRcdFx0XHRwID0gcHQucGx1Z2luO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gVHdlZW5QbHVnaW4ucHJvdG90eXBlLl9raWxsLmNhbGwodGhpcywgY29weSk7XG5cdFx0fTtcblxuXG5cblx0XHQvL3VzZWQgYnkgY2FzY2FkZVRvKCkgZm9yIGdhdGhlcmluZyBhbGwgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgZWFjaCBjaGlsZCBlbGVtZW50IGludG8gYW4gYXJyYXkgZm9yIGNvbXBhcmlzb24uXG5cdFx0dmFyIF9nZXRDaGlsZFN0eWxlcyA9IGZ1bmN0aW9uKGUsIHByb3BzLCB0YXJnZXRzKSB7XG5cdFx0XHRcdHZhciBjaGlsZHJlbiwgaSwgY2hpbGQsIHR5cGU7XG5cdFx0XHRcdGlmIChlLnNsaWNlKSB7XG5cdFx0XHRcdFx0aSA9IGUubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0X2dldENoaWxkU3R5bGVzKGVbaV0sIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gZS5jaGlsZE5vZGVzO1xuXHRcdFx0XHRpID0gY2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdHR5cGUgPSBjaGlsZC50eXBlO1xuXHRcdFx0XHRcdGlmIChjaGlsZC5zdHlsZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMucHVzaChfZ2V0QWxsU3R5bGVzKGNoaWxkKSk7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0cykge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHR5cGUgPT09IDEgfHwgdHlwZSA9PT0gOSB8fCB0eXBlID09PSAxMSkgJiYgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhjaGlsZCwgcHJvcHMsIHRhcmdldHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgY2xhc3NOYW1lIHR3ZWVucyB0aGF0IG1heSBhZmZlY3QgY2hpbGQgZWxlbWVudHMsIHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBUd2VlbkxpdGVcblx0XHQgKiBhbmQgdGhlbiBjb21wYXJlcyB0aGUgc3R5bGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHRhcmdldCdzIGNoaWxkIGVsZW1lbnRzIGF0IHRoZSB0d2VlbidzIHN0YXJ0IGFuZCBlbmQsIGFuZFxuXHRcdCAqIGlmIGFueSBhcmUgZGlmZmVyZW50LCBpdCBhbHNvIGNyZWF0ZXMgdHdlZW5zIGZvciB0aG9zZSBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIEFMTCBvZiB0aGUgcmVzdWx0aW5nXG5cdFx0ICogdHdlZW5zIChzbyB0aGF0IHlvdSBjYW4gZWFzaWx5IGFkZCgpIHRoZW0gdG8gYSBUaW1lbGluZUxpdGUsIGZvciBleGFtcGxlKS4gVGhlIHJlYXNvbiB0aGlzIGZ1bmN0aW9uYWxpdHkgaXNcblx0XHQgKiB3cmFwcGVkIGludG8gYSBzZXBhcmF0ZSBzdGF0aWMgbWV0aG9kIG9mIENTU1BsdWdpbiBpbnN0ZWFkIG9mIGJlaW5nIGludGVncmF0ZWQgaW50byBhbGwgcmVndWxhciBjbGFzc05hbWUgdHdlZW5zXG5cdFx0ICogaXMgYmVjYXVzZSBpdCBjcmVhdGVzIGVudGlyZWx5IG5ldyB0d2VlbnMgdGhhdCBtYXkgaGF2ZSBjb21wbGV0ZWx5IGRpZmZlcmVudCB0YXJnZXRzIHRoYW4gdGhlIG9yaWdpbmFsIHR3ZWVuLFxuXHRcdCAqIHNvIGlmIHRoZXkgd2VyZSBhbGwgbHVtcGVkIGludG8gdGhlIG9yaWdpbmFsIHR3ZWVuIGluc3RhbmNlLCBpdCB3b3VsZCBiZSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgQVBJXG5cdFx0ICogYW5kIGl0IHdvdWxkIGNyZWF0ZSBvdGhlciBwcm9ibGVtcy4gRm9yIGV4YW1wbGU6XG5cdFx0ICogIC0gSWYgSSBjcmVhdGUgYSB0d2VlbiBvZiBlbGVtZW50QSwgdGhhdCB0d2VlbiBpbnN0YW5jZSBtYXkgc3VkZGVubHkgY2hhbmdlIGl0cyB0YXJnZXQgdG8gaW5jbHVkZSA1MCBvdGhlciBlbGVtZW50cyAodW5pbnR1aXRpdmUgaWYgSSBzcGVjaWZpY2FsbHkgZGVmaW5lZCB0aGUgdGFyZ2V0IEkgd2FudGVkKVxuXHRcdCAqICAtIFdlIGNhbid0IGp1c3QgY3JlYXRlIG5ldyBpbmRlcGVuZGVudCB0d2VlbnMgYmVjYXVzZSBvdGhlcndpc2UsIHdoYXQgaGFwcGVucyBpZiB0aGUgb3JpZ2luYWwvcGFyZW50IHR3ZWVuIGlzIHJldmVyc2VkIG9yIHBhdXNlIG9yIGRyb3BwZWQgaW50byBhIFRpbWVsaW5lTGl0ZSBmb3IgdGlnaHQgY29udHJvbD8gWW91J2QgZXhwZWN0IHRoYXQgdHdlZW4ncyBiZWhhdmlvciB0byBhZmZlY3QgYWxsIHRoZSBvdGhlcnMuXG5cdFx0ICogIC0gQW5hbHl6aW5nIGV2ZXJ5IHN0eWxlIHByb3BlcnR5IG9mIGV2ZXJ5IGNoaWxkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gd2hlbiB0aGVyZSBhcmUgbWFueSBjaGlsZHJlbiwgc28gdGhpcyBiZWhhdmlvciBzaG91bGRuJ3QgYmUgaW1wb3NlZCBvbiBhbGwgY2xhc3NOYW1lIHR3ZWVucyBieSBkZWZhdWx0LCBlc3BlY2lhbGx5IHNpbmNlIGl0J3MgcHJvYmFibHkgcmFyZSB0aGF0IHRoaXMgZXh0cmEgZnVuY3Rpb25hbGl0eSBpcyBuZWVkZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IG9iamVjdCB0byBiZSB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IER1cmF0aW9uIGluIHNlY29uZHMgKG9yIGZyYW1lcyBmb3IgZnJhbWVzLWJhc2VkIHR3ZWVucylcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuZCB2YWx1ZXMsIGxpa2Uge2NsYXNzTmFtZTpcIm5ld0NsYXNzXCIsIGVhc2U6TGluZWFyLmVhc2VOb25lfVxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBUd2VlbkxpdGUgaW5zdGFuY2VzXG5cdFx0ICovXG5cdFx0Q1NTUGx1Z2luLmNhc2NhZGVUbyA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhciB0d2VlbiA9IFR3ZWVuTGl0ZS50byh0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSxcblx0XHRcdFx0cmVzdWx0cyA9IFt0d2Vlbl0sXG5cdFx0XHRcdGIgPSBbXSxcblx0XHRcdFx0ZSA9IFtdLFxuXHRcdFx0XHR0YXJnZXRzID0gW10sXG5cdFx0XHRcdF9yZXNlcnZlZFByb3BzID0gVHdlZW5MaXRlLl9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyxcblx0XHRcdFx0aSwgZGlmcywgcCwgZnJvbTtcblx0XHRcdHRhcmdldCA9IHR3ZWVuLl90YXJnZXRzIHx8IHR3ZWVuLnRhcmdldDtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGIsIHRhcmdldHMpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKGR1cmF0aW9uLCB0cnVlLCB0cnVlKTtcblx0XHRcdF9nZXRDaGlsZFN0eWxlcyh0YXJnZXQsIGUpO1xuXHRcdFx0dHdlZW4ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0dHdlZW4uX2VuYWJsZWQodHJ1ZSk7XG5cdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0ZGlmcyA9IF9jc3NEaWYodGFyZ2V0c1tpXSwgYltpXSwgZVtpXSk7XG5cdFx0XHRcdGlmIChkaWZzLmZpcnN0TVBUKSB7XG5cdFx0XHRcdFx0ZGlmcyA9IGRpZnMuZGlmcztcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGRpZnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcm9tID0ge307XG5cdFx0XHRcdFx0Zm9yIChwIGluIGRpZnMpIHtcblx0XHRcdFx0XHRcdGZyb21bcF0gPSBiW2ldW3BdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goVHdlZW5MaXRlLmZyb21Ubyh0YXJnZXRzW2ldLCBkdXJhdGlvbiwgZnJvbSwgZGlmcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW0NTU1BsdWdpbl0pO1xuXHRcdHJldHVybiBDU1NQbHVnaW47XG5cblx0fSwgdHJ1ZSk7XG5cblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUm91bmRQcm9wc1BsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdChmdW5jdGlvbigpIHtcblxuXHRcdHZhciBSb3VuZFByb3BzUGx1Z2luID0gX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRcdHByb3BOYW1lOiBcInJvdW5kUHJvcHNcIixcblx0XHRcdFx0dmVyc2lvbjogXCIxLjYuMFwiLFxuXHRcdFx0XHRwcmlvcml0eTogLTEsXG5cdFx0XHRcdEFQSTogMixcblxuXHRcdFx0XHQvL2NhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX3R3ZWVuID0gdHdlZW47XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSksXG5cdFx0XHRfcm91bmRMaW5rZWRMaXN0ID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0XHRcdGlmICghbm9kZS5mICYmICFub2RlLmJsb2IpIHtcblx0XHRcdFx0XHRcdG5vZGUubSA9IE1hdGgucm91bmQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cCA9IFJvdW5kUHJvcHNQbHVnaW4ucHJvdG90eXBlO1xuXG5cdFx0cC5fb25Jbml0QWxsUHJvcHMgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX3R3ZWVuLFxuXHRcdFx0XHRycCA9ICh0d2Vlbi52YXJzLnJvdW5kUHJvcHMuam9pbikgPyB0d2Vlbi52YXJzLnJvdW5kUHJvcHMgOiB0d2Vlbi52YXJzLnJvdW5kUHJvcHMuc3BsaXQoXCIsXCIpLFxuXHRcdFx0XHRpID0gcnAubGVuZ3RoLFxuXHRcdFx0XHRsb29rdXAgPSB7fSxcblx0XHRcdFx0cnB0ID0gdHdlZW4uX3Byb3BMb29rdXAucm91bmRQcm9wcyxcblx0XHRcdFx0cHJvcCwgcHQsIG5leHQ7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0bG9va3VwW3JwW2ldXSA9IE1hdGgucm91bmQ7XG5cdFx0XHR9XG5cdFx0XHRpID0gcnAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHByb3AgPSBycFtpXTtcblx0XHRcdFx0cHQgPSB0d2Vlbi5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0OyAvL3JlY29yZCBoZXJlLCBiZWNhdXNlIGl0IG1heSBnZXQgcmVtb3ZlZFxuXHRcdFx0XHRcdGlmIChwdC5wZykge1xuXHRcdFx0XHRcdFx0cHQudC5fbW9kKGxvb2t1cCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5uID09PSBwcm9wKSB7XG5cdFx0XHRcdFx0XHRpZiAocHQuZiA9PT0gMiAmJiBwdC50KSB7IC8vYSBibG9iICh0ZXh0IGNvbnRhaW5pbmcgbXVsdGlwbGUgbnVtZXJpYyB2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdF9yb3VuZExpbmtlZExpc3QocHQudC5fZmlyc3RQVCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9hZGQocHQudCwgcHJvcCwgcHQucywgcHQuYyk7XG5cdFx0XHRcdFx0XHRcdC8vcmVtb3ZlIGZyb20gbGlua2VkIGxpc3Rcblx0XHRcdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuLl9maXJzdFBUID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0dHdlZW4uX3Byb3BMb29rdXBbcHJvcF0gPSBycHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLl9hZGQgPSBmdW5jdGlvbih0YXJnZXQsIHAsIHMsIGMpIHtcblx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgcywgcyArIGMsIHAsIE1hdGgucm91bmQpO1xuXHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHR9O1xuXG5cdH0oKSk7XG5cblxuXG5cblxuXG5cblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBdHRyUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRcdHByb3BOYW1lOiBcImF0dHJcIixcblx0XHRcdEFQSTogMixcblx0XHRcdHZlcnNpb246IFwiMC42LjBcIixcblxuXHRcdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCkge1xuXHRcdFx0XHR2YXIgcCwgZW5kO1xuXHRcdFx0XHRpZiAodHlwZW9mKHRhcmdldC5zZXRBdHRyaWJ1dGUpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0ZW5kID0gdmFsdWVbcF07XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihlbmQpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdGVuZCA9IGVuZChpbmRleCwgdGFyZ2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBcInNldEF0dHJpYnV0ZVwiLCB0YXJnZXQuZ2V0QXR0cmlidXRlKHApICsgXCJcIiwgZW5kICsgXCJcIiwgcCwgZmFsc2UsIHApO1xuXHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHR9KTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdHByb3BOYW1lOiBcImRpcmVjdGlvbmFsUm90YXRpb25cIixcblx0XHR2ZXJzaW9uOiBcIjAuMy4wXCIsXG5cdFx0QVBJOiAyLFxuXG5cdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgpIHtcblx0XHRcdGlmICh0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdHZhbHVlID0ge3JvdGF0aW9uOnZhbHVlfTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZmluYWxzID0ge307XG5cdFx0XHR2YXIgY2FwID0gKHZhbHVlLnVzZVJhZGlhbnMgPT09IHRydWUpID8gTWF0aC5QSSAqIDIgOiAzNjAsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRwLCB2LCBzdGFydCwgZW5kLCBkaWYsIHNwbGl0O1xuXHRcdFx0Zm9yIChwIGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmIChwICE9PSBcInVzZVJhZGlhbnNcIikge1xuXHRcdFx0XHRcdGVuZCA9IHZhbHVlW3BdO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZW5kKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBlbmQoaW5kZXgsIHRhcmdldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNwbGl0ID0gKGVuZCArIFwiXCIpLnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHR2ID0gc3BsaXRbMF07XG5cdFx0XHRcdFx0c3RhcnQgPSBwYXJzZUZsb2F0KCAodHlwZW9mKHRhcmdldFtwXSkgIT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbcF0gOiB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdKCkgKTtcblx0XHRcdFx0XHRlbmQgPSB0aGlzLmZpbmFsc1twXSA9ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHN0YXJ0ICsgcGFyc2VJbnQodi5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogTnVtYmVyKHYuc3Vic3RyKDIpKSA6IE51bWJlcih2KSB8fCAwO1xuXHRcdFx0XHRcdGRpZiA9IGVuZCAtIHN0YXJ0O1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHYgPSBzcGxpdC5qb2luKFwiX1wiKTtcblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJzaG9ydFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gZGlmICUgY2FwO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGlmICE9PSBkaWYgJSAoY2FwIC8gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRkaWYgPSAoZGlmIDwgMCkgPyBkaWYgKyBjYXAgOiBkaWYgLSBjYXA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh2LmluZGV4T2YoXCJfY3dcIikgIT09IC0xICYmIGRpZiA8IDApIHtcblx0XHRcdFx0XHRcdFx0ZGlmID0gKChkaWYgKyBjYXAgKiA5OTk5OTk5OTk5KSAlIGNhcCkgLSAoKGRpZiAvIGNhcCkgfCAwKSAqIGNhcDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodi5pbmRleE9mKFwiY2N3XCIpICE9PSAtMSAmJiBkaWYgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmIC0gY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkaWYgPiBtaW4gfHwgZGlmIDwgLW1pbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fYWRkVHdlZW4odGFyZ2V0LCBwLCBzdGFydCwgc3RhcnQgKyBkaWYsIHApO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvL2NhbGxlZCBlYWNoIHRpbWUgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCwgYW5kIHRoZSByYXRpbyBnZXRzIHBhc3NlZCBhcyB0aGUgb25seSBwYXJhbWV0ZXIgKHR5cGljYWxseSBpdCdzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgaXQgY2FuIGV4Y2VlZCB0aG9zZSB3aGVuIHVzaW5nIGFuIGVhc2UgbGlrZSBFbGFzdGljLmVhc2VPdXQgb3IgQmFjay5lYXNlT3V0LCBldGMuKVxuXHRcdHNldDogZnVuY3Rpb24ocmF0aW8pIHtcblx0XHRcdHZhciBwdDtcblx0XHRcdGlmIChyYXRpbyAhPT0gMSkge1xuXHRcdFx0XHR0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsIHJhdGlvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0odGhpcy5maW5hbHNbcHQucF0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdGhpcy5maW5hbHNbcHQucF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0fSkuX2F1dG9DU1MgPSB0cnVlO1xuXG5cblxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEVhc2VQYWNrXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwiZWFzaW5nLkJhY2tcIiwgW1wiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKEVhc2UpIHtcblx0XHRcblx0XHR2YXIgdyA9IChfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzIHx8IF9nc1Njb3BlKSxcblx0XHRcdGdzID0gdy5jb20uZ3JlZW5zb2NrLFxuXHRcdFx0XzJQSSA9IE1hdGguUEkgKiAyLFxuXHRcdFx0X0hBTEZfUEkgPSBNYXRoLlBJIC8gMixcblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyxcblx0XHRcdF9jcmVhdGUgPSBmdW5jdGlvbihuLCBmKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiICsgbiwgZnVuY3Rpb24oKXt9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciB8fCBmdW5jdGlvbigpe30sIC8vcHV0IGFuIGVtcHR5IGZ1bmN0aW9uIGluIHBsYWNlIGp1c3QgYXMgYSBzYWZldHkgbWVhc3VyZSBpbiBjYXNlIHNvbWVvbmUgbG9hZHMgYW4gT0xEIHZlcnNpb24gb2YgVHdlZW5MaXRlLmpzIHdoZXJlIEVhc2UucmVnaXN0ZXIgZG9lc24ndCBleGlzdC5cblx0XHRcdF93cmFwID0gZnVuY3Rpb24obmFtZSwgRWFzZU91dCwgRWFzZUluLCBFYXNlSW5PdXQsIGFsaWFzZXMpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwge1xuXHRcdFx0XHRcdGVhc2VPdXQ6bmV3IEVhc2VPdXQoKSxcblx0XHRcdFx0XHRlYXNlSW46bmV3IEVhc2VJbigpLFxuXHRcdFx0XHRcdGVhc2VJbk91dDpuZXcgRWFzZUluT3V0KClcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdF9lYXNlUmVnKEMsIG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRFYXNlUG9pbnQgPSBmdW5jdGlvbih0aW1lLCB2YWx1ZSwgbmV4dCkge1xuXHRcdFx0XHR0aGlzLnQgPSB0aW1lO1xuXHRcdFx0XHR0aGlzLnYgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHR0aGlzLm5leHQgPSBuZXh0O1xuXHRcdFx0XHRcdG5leHQucHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL0JhY2tcblx0XHRcdF9jcmVhdGVCYWNrID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKG92ZXJzaG9vdCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcDEgPSAob3ZlcnNob290IHx8IG92ZXJzaG9vdCA9PT0gMCkgPyBvdmVyc2hvb3QgOiAxLjcwMTU4O1xuXHRcdFx0XHRcdFx0dGhpcy5fcDIgPSB0aGlzLl9wMSAqIDEuNTI1O1xuXHRcdFx0XHRcdH0sIHRydWUpLFxuXHRcdFx0XHRcdHAgPSBDLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0XHRwLmdldFJhdGlvID0gZjtcblx0XHRcdFx0cC5jb25maWcgPSBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEMob3ZlcnNob290KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXG5cdFx0XHRCYWNrID0gX3dyYXAoXCJCYWNrXCIsXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCA9IHAgLSAxKSAqIHAgKiAoKHRoaXMuX3AxICsgMSkgKiBwICsgdGhpcy5fcDEpICsgMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHAgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCAtIHRoaXMuX3AxKTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdF9jcmVhdGVCYWNrKFwiQmFja0luT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBwICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgLSB0aGlzLl9wMikgOiAwLjUgKiAoKHAgLT0gMikgKiBwICogKCh0aGlzLl9wMiArIDEpICogcCArIHRoaXMuX3AyKSArIDIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KSxcblxuXG5cdFx0XHQvL1Nsb3dNb1xuXHRcdFx0U2xvd01vID0gX2NsYXNzKFwiZWFzaW5nLlNsb3dNb1wiLCBmdW5jdGlvbihsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG5cdFx0XHRcdHBvd2VyID0gKHBvd2VyIHx8IHBvd2VyID09PSAwKSA/IHBvd2VyIDogMC43O1xuXHRcdFx0XHRpZiAobGluZWFyUmF0aW8gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMC43O1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmVhclJhdGlvID4gMSkge1xuXHRcdFx0XHRcdGxpbmVhclJhdGlvID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9wID0gKGxpbmVhclJhdGlvICE9PSAxKSA/IHBvd2VyIDogMDtcblx0XHRcdFx0dGhpcy5fcDEgPSAoMSAtIGxpbmVhclJhdGlvKSAvIDI7XG5cdFx0XHRcdHRoaXMuX3AyID0gbGluZWFyUmF0aW87XG5cdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDEgKyB0aGlzLl9wMjtcblx0XHRcdFx0dGhpcy5fY2FsY0VuZCA9ICh5b3lvTW9kZSA9PT0gdHJ1ZSk7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdHAgPSBTbG93TW8ucHJvdG90eXBlID0gbmV3IEVhc2UoKSxcblx0XHRcdFN0ZXBwZWRFYXNlLCBSb3VnaEVhc2UsIF9jcmVhdGVFbGFzdGljO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNsb3dNbztcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0dmFyIHIgPSBwICsgKDAuNSAtIHApICogdGhpcy5fcDtcblx0XHRcdGlmIChwIDwgdGhpcy5fcDEpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbGNFbmQgPyAxIC0gKChwID0gMSAtIChwIC8gdGhpcy5fcDEpKSAqIHApIDogciAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwICogcCAqIHAgKiByKTtcblx0XHRcdH0gZWxzZSBpZiAocCA+IHRoaXMuX3AzKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtIChwID0gKHAgLSB0aGlzLl9wMykgLyB0aGlzLl9wMSkgKiBwIDogciArICgocCAtIHIpICogKHAgPSAocCAtIHRoaXMuX3AzKSAvIHRoaXMuX3AxKSAqIHAgKiBwICogcCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgOiByO1xuXHRcdH07XG5cdFx0U2xvd01vLmVhc2UgPSBuZXcgU2xvd01vKDAuNywgMC43KTtcblxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0XHRzdGVwcyA9IHN0ZXBzIHx8IDE7XG5cdFx0XHRcdHRoaXMuX3AxID0gMSAvIHN0ZXBzO1xuXHRcdFx0XHR0aGlzLl9wMiA9IHN0ZXBzICsgMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdHAgPSBTdGVwcGVkRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTdGVwcGVkRWFzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHAgPCAwKSB7XG5cdFx0XHRcdHAgPSAwO1xuXHRcdFx0fSBlbHNlIGlmIChwID49IDEpIHtcblx0XHRcdFx0cCA9IDAuOTk5OTk5OTk5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICgodGhpcy5fcDIgKiBwKSA+PiAwKSAqIHRoaXMuX3AxO1xuXHRcdH07XG5cdFx0cC5jb25maWcgPSBTdGVwcGVkRWFzZS5jb25maWcgPSBmdW5jdGlvbihzdGVwcykge1xuXHRcdFx0cmV0dXJuIG5ldyBTdGVwcGVkRWFzZShzdGVwcyk7XG5cdFx0fTtcblxuXG5cdFx0Ly9Sb3VnaEVhc2Vcblx0XHRSb3VnaEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuUm91Z2hFYXNlXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHRhcGVyID0gdmFycy50YXBlciB8fCBcIm5vbmVcIixcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwb2ludHMgPSAodmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdFx0aSA9IHBvaW50cyxcblx0XHRcdFx0cmFuZG9taXplID0gKHZhcnMucmFuZG9taXplICE9PSBmYWxzZSksXG5cdFx0XHRcdGNsYW1wID0gKHZhcnMuY2xhbXAgPT09IHRydWUpLFxuXHRcdFx0XHR0ZW1wbGF0ZSA9ICh2YXJzLnRlbXBsYXRlIGluc3RhbmNlb2YgRWFzZSkgPyB2YXJzLnRlbXBsYXRlIDogbnVsbCxcblx0XHRcdFx0c3RyZW5ndGggPSAodHlwZW9mKHZhcnMuc3RyZW5ndGgpID09PSBcIm51bWJlclwiKSA/IHZhcnMuc3RyZW5ndGggKiAwLjQgOiAwLjQsXG5cdFx0XHRcdHgsIHksIGJ1bXAsIGludlgsIG9iaiwgcG50O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogKDEgLyBwb2ludHMpICogaTtcblx0XHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUuZ2V0UmF0aW8oeCkgOiB4O1xuXHRcdFx0XHRpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdFx0aW52WCA9IDEgLSB4O1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0XHRidW1wID0geCAqIHggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh4IDwgMC41KSB7ICAvL1wiYm90aFwiIChzdGFydClcblx0XHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvL1wiYm90aFwiIChlbmQpXG5cdFx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0XHR5ICs9IChNYXRoLnJhbmRvbSgpICogYnVtcCkgLSAoYnVtcCAqIDAuNSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSAlIDIpIHtcblx0XHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSAtPSBidW1wICogMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGFtcCkge1xuXHRcdFx0XHRcdGlmICh5ID4gMSkge1xuXHRcdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5IDwgMCkge1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbY250KytdID0ge3g6eCwgeTp5fTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnggLSBiLng7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRcdGkgPSBwb2ludHM7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0b2JqID0gYVtpXTtcblx0XHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludChvYmoueCwgb2JqLnksIHBudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZXYgPSBuZXcgRWFzZVBvaW50KDAsIDAsIChwbnQudCAhPT0gMCkgPyBwbnQgOiBwbnQubmV4dCk7XG5cdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFJvdWdoRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBSb3VnaEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwbnQgPSB0aGlzLl9wcmV2O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcHJldiA9IHBudDtcblx0XHRcdHJldHVybiAocG50LnYgKyAoKHAgLSBwbnQudCkgLyBwbnQuZ2FwKSAqIHBudC5jKTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBSb3VnaEVhc2UodmFycyk7XG5cdFx0fTtcblx0XHRSb3VnaEVhc2UuZWFzZSA9IG5ldyBSb3VnaEVhc2UoKTtcblxuXG5cdFx0Ly9Cb3VuY2Vcblx0XHRfd3JhcChcIkJvdW5jZVwiLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKChwID0gMSAtIHApIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiBwICogcCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1KTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0dmFyIGludmVydCA9IChwIDwgMC41KTtcblx0XHRcdFx0aWYgKGludmVydCkge1xuXHRcdFx0XHRcdHAgPSAxIC0gKHAgKiAyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gKHAgKiAyKSAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpbnZlcnQgPyAoMSAtIHApICogMC41IDogcCAqIDAuNSArIDAuNTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9DSVJDXG5cdFx0X3dyYXAoXCJDaXJjXCIsXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtIChwID0gcCAtIDEpICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIChwICogcCkpIC0gMSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwKj0yKSA8IDEpID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHAgKiBwKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKHAgLT0gMikgKiBwKSArIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0VsYXN0aWNcblx0XHRfY3JlYXRlRWxhc3RpYyA9IGZ1bmN0aW9uKG4sIGYsIGRlZikge1xuXHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRcdHRoaXMuX3AxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDE7IC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRcdFx0dGhpcy5fcDIgPSAocGVyaW9kIHx8IGRlZikgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpO1xuXHRcdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gdGhpcy5fcDEpIHx8IDApO1xuXHRcdFx0XHRcdHRoaXMuX3AyID0gXzJQSSAvIHRoaXMuX3AyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQyhhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIEM7XG5cdFx0fTtcblx0XHRfd3JhcChcIkVsYXN0aWNcIixcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSArIDE7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLSh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSk7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAtMC41ICogKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMikpIDogdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKihwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKiAwLjUgKyAxO1xuXHRcdFx0fSwgMC40NSlcblx0XHQpO1xuXG5cblx0XHQvL0V4cG9cblx0XHRfd3JhcChcIkV4cG9cIixcblx0XHRcdF9jcmVhdGUoXCJFeHBvT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9JblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIC0gMC4wMDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vU2luZVxuXHRcdF93cmFwKFwiU2luZVwiLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4ocCAqIF9IQUxGX1BJKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtTWF0aC5jb3MocCAqIF9IQUxGX1BJKSArIDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogcCkgLSAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdF9jbGFzcyhcImVhc2luZy5FYXNlTG9va3VwXCIsIHtcblx0XHRcdFx0ZmluZDpmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVhc2UubWFwW3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblxuXHRcdC8vcmVnaXN0ZXIgdGhlIG5vbi1zdGFuZGFyZCBlYXNlc1xuXHRcdF9lYXNlUmVnKHcuU2xvd01vLCBcIlNsb3dNb1wiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFJvdWdoRWFzZSwgXCJSb3VnaEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhTdGVwcGVkRWFzZSwgXCJTdGVwcGVkRWFzZVwiLCBcImVhc2UsXCIpO1xuXG5cdFx0cmV0dXJuIEJhY2s7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cbn0pO1xuXG5pZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH0gLy9uZWNlc3NhcnkgaW4gY2FzZSBUd2VlbkxpdGUgd2FzIGFscmVhZHkgbG9hZGVkIHNlcGFyYXRlbHkuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJhc2UgY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgU2ltcGxlVGltZWxpbmUsIEVhc2UsIFRpY2tlciwgZXRjLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4oZnVuY3Rpb24od2luZG93LCBtb2R1bGVOYW1lKSB7XG5cblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX2V4cG9ydHMgPSB7fSxcblx0XHRcdF9kb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdFx0XHRfZ2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgfHwgd2luZG93O1xuXHRcdGlmIChfZ2xvYmFscy5Ud2VlbkxpdGUpIHtcblx0XHRcdHJldHVybjsgLy9pbiBjYXNlIHRoZSBjb3JlIHNldCBvZiBjbGFzc2VzIGlzIGFscmVhZHkgbG9hZGVkLCBkb24ndCBpbnN0YW50aWF0ZSB0d2ljZS5cblx0XHR9XG5cdFx0dmFyIF9uYW1lc3BhY2UgPSBmdW5jdGlvbihucykge1xuXHRcdFx0XHR2YXIgYSA9IG5zLnNwbGl0KFwiLlwiKSxcblx0XHRcdFx0XHRwID0gX2dsb2JhbHMsIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cFthW2ldXSA9IHAgPSBwW2FbaV1dIHx8IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdGdzID0gX25hbWVzcGFjZShcImNvbS5ncmVlbnNvY2tcIiksXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSkge31cblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2VtcHR5RnVuYyA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfaXNBcnJheSA9IChmdW5jdGlvbigpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIGlmcmFtZSBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIEFycmF5IGdsb2JhbCBpc24ndCBzaGFyZWQsIHRodXMgaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGluIGEgZGlmZmVyZW50IHdpbmRvdy9pZnJhbWUsIFwiKG9iaiBpbnN0YW5jZW9mIEFycmF5KVwiIHdpbGwgZXZhbHVhdGUgZmFsc2UuIFdlIGFkZGVkIHNvbWUgc3BlZWQgb3B0aW1pemF0aW9ucyB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKSB1bmxlc3MgaXQncyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgVkVSWSBzbG93IChsaWtlIDIweCBzbG93ZXIpXG5cdFx0XHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0XHRcdFx0YXJyYXkgPSB0b1N0cmluZy5jYWxsKFtdKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgKHR5cGVvZihvYmopID09PSBcIm9iamVjdFwiICYmICEhb2JqLnB1c2ggJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSBhcnJheSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKSxcblx0XHRcdGEsIGksIHAsIF90aWNrZXIsIF90aWNrZXJBY3RpdmUsXG5cdFx0XHRfZGVmTG9va3VwID0ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0XHQgKiBEZWZpbmVzIGEgR3JlZW5Tb2NrIGNsYXNzLCBvcHRpb25hbGx5IHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgZmlyc3QgYW5kIHBhc3NlZCBpbnRvIHRoZSBkZWZpbml0aW9uLlxuXHRcdFx0ICogVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9hZCBHcmVlblNvY2sgSlMgZmlsZXMgaW4gYW55IG9yZGVyIGV2ZW4gaWYgdGhleSBoYXZlIGludGVyZGVwZW5kZW5jaWVzIChsaWtlIENTU1BsdWdpbiBleHRlbmRzIFR3ZWVuUGx1Z2luIHdoaWNoIGlzXG5cdFx0XHQgKiBpbnNpZGUgVHdlZW5MaXRlLmpzLCBidXQgaWYgQ1NTUGx1Z2luIGlzIGxvYWRlZCBmaXJzdCwgaXQgc2hvdWxkIHdhaXQgdG8gcnVuIGl0cyBjb2RlIHVudGlsIFR3ZWVuTGl0ZS5qcyBsb2FkcyBhbmQgaW5zdGFudGlhdGVzIFR3ZWVuUGx1Z2luXG5cdFx0XHQgKiBhbmQgdGhlbiBwYXNzIFR3ZWVuUGx1Z2luIHRvIENTU1BsdWdpbidzIGRlZmluaXRpb24pLiBUaGlzIGlzIGFsbCBkb25lIGF1dG9tYXRpY2FsbHkgYW5kIGludGVybmFsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRXZlcnkgZGVmaW5pdGlvbiB3aWxsIGJlIGFkZGVkIHRvIGEgXCJjb20uZ3JlZW5zb2NrXCIgZ2xvYmFsIG9iamVjdCAodHlwaWNhbGx5IHdpbmRvdywgYnV0IGlmIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IGlzIGZvdW5kLFxuXHRcdFx0ICogaXQgd2lsbCBnbyB0aGVyZSBhcyBvZiB2MS43KS4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZSB3aWxsIGJlIGZvdW5kIGF0IHdpbmRvdy5jb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSBhbmQgc2luY2UgaXQncyBhIGdsb2JhbCBjbGFzcyB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgYW55d2hlcmUsXG5cdFx0XHQgKiBpdCBpcyBBTFNPIHJlZmVyZW5jZWQgYXQgd2luZG93LlR3ZWVuTGl0ZS4gSG93ZXZlciBzb21lIGNsYXNzZXMgYXJlbid0IGNvbnNpZGVyZWQgZ2xvYmFsLCBsaWtlIHRoZSBiYXNlIGNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24gY2xhc3MsIHNvXG5cdFx0XHQgKiB0aG9zZSB3aWxsIG9ubHkgYmUgYXQgdGhlIHBhY2thZ2UgbGlrZSB3aW5kb3cuY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbi4gQWdhaW4sIGlmIHlvdSBkZWZpbmUgYSBHcmVlblNvY2tHbG9iYWxzIG9iamVjdCBvbiB0aGUgd2luZG93LCBldmVyeXRoaW5nXG5cdFx0XHQgKiBnZXRzIHR1Y2tlZCBuZWF0bHkgaW5zaWRlIHRoZXJlIGluc3RlYWQgb2Ygb24gdGhlIHdpbmRvdyBkaXJlY3RseS4gVGhpcyBhbGxvd3MgeW91IHRvIGRvIGFkdmFuY2VkIHRoaW5ncyBsaWtlIGxvYWQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgR3JlZW5Tb2NrXG5cdFx0XHQgKiBmaWxlcyBhbmQgcHV0IHRoZW0gaW50byBkaXN0aW5jdCBvYmplY3RzIChpbWFnaW5lIGEgYmFubmVyIGFkIHVzZXMgYSBuZXdlciB2ZXJzaW9uIGJ1dCB0aGUgbWFpbiBzaXRlIHVzZXMgYW4gb2xkZXIgb25lKS4gSW4gdGhhdCBjYXNlLCB5b3UgY291bGRcblx0XHRcdCAqIHNhbmRib3ggdGhlIGJhbm5lciBvbmUgbGlrZTpcblx0XHRcdCAqXG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHZhciBncyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge307IC8vdGhlIG5ld2VyIHZlcnNpb24gd2UncmUgYWJvdXQgdG8gbG9hZCBjb3VsZCBub3cgYmUgcmVmZXJlbmNlZCBpbiBhIFwiZ3NcIiBvYmplY3QsIGxpa2UgZ3MuVHdlZW5MaXRlLnRvKC4uLikuIFVzZSB3aGF0ZXZlciBhbGlhcyB5b3Ugd2FudCBhcyBsb25nIGFzIGl0J3MgdW5pcXVlLCBcImdzXCIgb3IgXCJiYW5uZXJcIiBvciB3aGF0ZXZlci5cblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNy9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5fZ3NRdWV1ZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBudWxsOyAvL3Jlc2V0IGl0IGJhY2sgdG8gbnVsbCAoYWxvbmcgd2l0aCB0aGUgc3BlY2lhbCBfZ3NRdWV1ZSB2YXJpYWJsZSkgc28gdGhhdCB0aGUgbmV4dCBsb2FkIG9mIFR3ZWVuTWF4IGFmZmVjdHMgdGhlIHdpbmRvdyBhbmQgd2UgY2FuIHJlZmVyZW5jZSB0aGluZ3MgZGlyZWN0bHkgbGlrZSBUd2VlbkxpdGUudG8oLi4uKVxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS42L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIGdzLlR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS43XG5cdFx0XHQgKiAgICAgVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjZcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbnMgVGhlIG5hbWVzcGFjZSBvZiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgbGVhdmluZyBvZmYgXCJjb20uZ3JlZW5zb2NrLlwiIGFzIHRoYXQncyBhc3N1bWVkLiBGb3IgZXhhbXBsZSwgXCJUd2VlbkxpdGVcIiBvciBcInBsdWdpbnMuQ1NTUGx1Z2luXCIgb3IgXCJlYXNpbmcuQmFja1wiLlxuXHRcdFx0ICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgKGRlc2NyaWJlZCBhcyB0aGVpciBuYW1lc3BhY2VzIG1pbnVzIFwiY29tLmdyZWVuc29jay5cIiBwcmVmaXgpLiBGb3IgZXhhbXBsZSBbXCJUd2VlbkxpdGVcIixcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcImNvcmUuQW5pbWF0aW9uXCJdXG5cdFx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbigpOk9iamVjdH0gZnVuYyBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGFuZCBwYXNzZWQgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyB3aGljaCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGNsYXNzIGZvciB0aGlzIGRlZmluaXRpb24uXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBnbG9iYWwgSWYgdHJ1ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZSAodHlwaWNhbGx5IHdpbmRvdyB1bmxlc3MgeW91IGRlZmluZSBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHR0aGlzLnNjID0gKF9kZWZMb29rdXBbbnNdKSA/IF9kZWZMb29rdXBbbnNdLnNjIDogW107IC8vc3ViY2xhc3Nlc1xuXHRcdFx0XHRfZGVmTG9va3VwW25zXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZ3NDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHZhciBfY2xhc3NlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24oaW5pdCkge1xuXHRcdFx0XHRcdHZhciBpID0gZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdG1pc3NpbmcgPSBpLFxuXHRcdFx0XHRcdFx0Y3VyLCBhLCBuLCBjbCwgaGFzTW9kdWxlO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKChjdXIgPSBfZGVmTG9va3VwW2RlcGVuZGVuY2llc1tpXV0gfHwgbmV3IERlZmluaXRpb24oZGVwZW5kZW5jaWVzW2ldLCBbXSkpLmdzQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0X2NsYXNzZXNbaV0gPSBjdXIuZ3NDbGFzcztcblx0XHRcdFx0XHRcdFx0bWlzc2luZy0tO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRcdGN1ci5zYy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWlzc2luZyA9PT0gMCAmJiBmdW5jKSB7XG5cdFx0XHRcdFx0XHRhID0gKFwiY29tLmdyZWVuc29jay5cIiArIG5zKS5zcGxpdChcIi5cIik7XG5cdFx0XHRcdFx0XHRuID0gYS5wb3AoKTtcblx0XHRcdFx0XHRcdGNsID0gX25hbWVzcGFjZShhLmpvaW4oXCIuXCIpKVtuXSA9IHRoaXMuZ3NDbGFzcyA9IGZ1bmMuYXBwbHkoZnVuYywgX2NsYXNzZXMpO1xuXG5cdFx0XHRcdFx0XHQvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoZ2xvYmFsKSB7XG5cdFx0XHRcdFx0XHRcdF9nbG9iYWxzW25dID0gX2V4cG9ydHNbbl0gPSBjbDsgLy9wcm92aWRlcyBhIHdheSB0byBhdm9pZCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi4gQnkgZGVmYXVsdCwgdGhlIG1haW4gY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgUG93ZXIxLCBTdHJvbmcsIGV0Yy4gYXJlIGFkZGVkIHRvIHdpbmRvdyB1bmxlc3MgYSBHcmVlblNvY2tHbG9iYWxzIGlzIGRlZmluZWQuIFNvIGlmIHlvdSB3YW50IHRvIGhhdmUgdGhpbmdzIGFkZGVkIHRvIGEgY3VzdG9tIG9iamVjdCBpbnN0ZWFkLCBqdXN0IGRvIHNvbWV0aGluZyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge30gYmVmb3JlIGxvYWRpbmcgYW55IEdyZWVuU29jayBmaWxlcy4gWW91IGNhbiBldmVuIHNldCB1cCBhbiBhbGlhcyBsaWtlIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93cy5ncyA9IHt9IHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgZXZlcnl0aGluZyBsaWtlIGdzLlR3ZWVuTGl0ZS4gQWxzbyByZW1lbWJlciB0aGF0IEFMTCBjbGFzc2VzIGFyZSBhZGRlZCB0byB0aGUgd2luZG93LmNvbS5ncmVlbnNvY2sgb2JqZWN0IChpbiB0aGVpciByZXNwZWN0aXZlIHBhY2thZ2VzLCBsaWtlIGNvbS5ncmVlbnNvY2suZWFzaW5nLlBvd2VyMSwgY29tLmdyZWVuc29jay5Ud2VlbkxpdGUsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdGhhc01vZHVsZSA9ICh0eXBlb2YobW9kdWxlKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyk7XG5cdFx0XHRcdFx0XHRcdGlmICghaGFzTW9kdWxlICYmIHR5cGVvZihkZWZpbmUpID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCl7IC8vQU1EXG5cdFx0XHRcdFx0XHRcdFx0ZGVmaW5lKCh3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCA/IHdpbmRvdy5HcmVlblNvY2tBTURQYXRoICsgXCIvXCIgOiBcIlwiKSArIG5zLnNwbGl0KFwiLlwiKS5wb3AoKSwgW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gY2w7IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGhhc01vZHVsZSl7IC8vbm9kZVxuXHRcdFx0XHRcdFx0XHRcdGlmIChucyA9PT0gbW9kdWxlTmFtZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBfZXhwb3J0c1ttb2R1bGVOYW1lXSA9IGNsO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIF9leHBvcnRzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNsW2ldID0gX2V4cG9ydHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChfZXhwb3J0c1ttb2R1bGVOYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0X2V4cG9ydHNbbW9kdWxlTmFtZV1bbl0gPSBjbDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnNjLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2NbaV0uY2hlY2soKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuY2hlY2sodHJ1ZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL3VzZWQgdG8gY3JlYXRlIERlZmluaXRpb24gaW5zdGFuY2VzICh3aGljaCBiYXNpY2FsbHkgcmVnaXN0ZXJzIGEgY2xhc3MgdGhhdCBoYXMgZGVwZW5kZW5jaWVzKS5cblx0XHRcdF9nc0RlZmluZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBmdW5jdGlvbihucywgZGVwZW5kZW5jaWVzLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBEZWZpbml0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2EgcXVpY2sgd2F5IHRvIGNyZWF0ZSBhIGNsYXNzIHRoYXQgZG9lc24ndCBoYXZlIGFueSBkZXBlbmRlbmNpZXMuIFJldHVybnMgdGhlIGNsYXNzLCBidXQgZmlyc3QgcmVnaXN0ZXJzIGl0IGluIHRoZSBHcmVlblNvY2sgbmFtZXNwYWNlIHNvIHRoYXQgb3RoZXIgY2xhc3NlcyBjYW4gZ3JhYiBpdCAob3RoZXIgY2xhc3NlcyBtaWdodCBiZSBkZXBlbmRlbnQgb24gdGhlIGNsYXNzKS5cblx0XHRcdF9jbGFzcyA9IGdzLl9jbGFzcyA9IGZ1bmN0aW9uKG5zLCBmdW5jLCBnbG9iYWwpIHtcblx0XHRcdFx0ZnVuYyA9IGZ1bmMgfHwgZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0X2dzRGVmaW5lKG5zLCBbXSwgZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmM7IH0sIGdsb2JhbCk7XG5cdFx0XHRcdHJldHVybiBmdW5jO1xuXHRcdFx0fTtcblxuXHRcdF9nc0RlZmluZS5nbG9iYWxzID0gX2dsb2JhbHM7XG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRWFzZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIF9iYXNlUGFyYW1zID0gWzAsIDAsIDEsIDFdLFxuXHRcdFx0X2JsYW5rQXJyYXkgPSBbXSxcblx0XHRcdEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuRWFzZVwiLCBmdW5jdGlvbihmdW5jLCBleHRyYVBhcmFtcywgdHlwZSwgcG93ZXIpIHtcblx0XHRcdFx0dGhpcy5fZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3Bvd2VyID0gcG93ZXIgfHwgMDtcblx0XHRcdFx0dGhpcy5fcGFyYW1zID0gZXh0cmFQYXJhbXMgPyBfYmFzZVBhcmFtcy5jb25jYXQoZXh0cmFQYXJhbXMpIDogX2Jhc2VQYXJhbXM7XG5cdFx0XHR9LCB0cnVlKSxcblx0XHRcdF9lYXNlTWFwID0gRWFzZS5tYXAgPSB7fSxcblx0XHRcdF9lYXNlUmVnID0gRWFzZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGVhc2UsIG5hbWVzLCB0eXBlcywgY3JlYXRlKSB7XG5cdFx0XHRcdHZhciBuYSA9IG5hbWVzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRpID0gbmEubGVuZ3RoLFxuXHRcdFx0XHRcdHRhID0gKHR5cGVzIHx8IFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0XHRlLCBuYW1lLCBqLCB0eXBlO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFbaV07XG5cdFx0XHRcdFx0ZSA9IGNyZWF0ZSA/IF9jbGFzcyhcImVhc2luZy5cIituYW1lLCBudWxsLCB0cnVlKSA6IGdzLmVhc2luZ1tuYW1lXSB8fCB7fTtcblx0XHRcdFx0XHRqID0gdGEubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRhW2pdO1xuXHRcdFx0XHRcdFx0X2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgdHlwZV0gPSBfZWFzZU1hcFt0eXBlICsgbmFtZV0gPSBlW3R5cGVdID0gZWFzZS5nZXRSYXRpbyA/IGVhc2UgOiBlYXNlW3R5cGVdIHx8IG5ldyBlYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cCA9IEVhc2UucHJvdG90eXBlO1xuXHRcdHAuX2NhbGNFbmQgPSBmYWxzZTtcblx0XHRwLmdldFJhdGlvID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYgKHRoaXMuX2Z1bmMpIHtcblx0XHRcdFx0dGhpcy5fcGFyYW1zWzBdID0gcDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2Z1bmMuYXBwbHkobnVsbCwgdGhpcy5fcGFyYW1zKTtcblx0XHRcdH1cblx0XHRcdHZhciB0ID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cHcgPSB0aGlzLl9wb3dlcixcblx0XHRcdFx0ciA9ICh0ID09PSAxKSA/IDEgLSBwIDogKHQgPT09IDIpID8gcCA6IChwIDwgMC41KSA/IHAgKiAyIDogKDEgLSBwKSAqIDI7XG5cdFx0XHRpZiAocHcgPT09IDEpIHtcblx0XHRcdFx0ciAqPSByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMikge1xuXHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0fSBlbHNlIGlmIChwdyA9PT0gMykge1xuXHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDQpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgLSByIDogKHQgPT09IDIpID8gciA6IChwIDwgMC41KSA/IHIgLyAyIDogMSAtIChyIC8gMik7XG5cdFx0fTtcblxuXHRcdC8vY3JlYXRlIGFsbCB0aGUgc3RhbmRhcmQgZWFzZXMgbGlrZSBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBhbmQgUG93ZXI0IChlYWNoIHdpdGggZWFzZUluLCBlYXNlT3V0LCBhbmQgZWFzZUluT3V0KVxuXHRcdGEgPSBbXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdHAgPSBhW2ldK1wiLFBvd2VyXCIraTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwxLGkpLCBwLCBcImVhc2VPdXRcIiwgdHJ1ZSk7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMixpKSwgcCwgXCJlYXNlSW5cIiArICgoaSA9PT0gMCkgPyBcIixlYXNlTm9uZVwiIDogXCJcIikpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDMsaSksIHAsIFwiZWFzZUluT3V0XCIpO1xuXHRcdH1cblx0XHRfZWFzZU1hcC5saW5lYXIgPSBncy5lYXNpbmcuTGluZWFyLmVhc2VJbjtcblx0XHRfZWFzZU1hcC5zd2luZyA9IGdzLmVhc2luZy5RdWFkLmVhc2VJbk91dDsgLy9mb3IgalF1ZXJ5IGZvbGtzXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEV2ZW50RGlzcGF0Y2hlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEV2ZW50RGlzcGF0Y2hlciA9IF9jbGFzcyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIiwgZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRcdHRoaXMuX2V2ZW50VGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG5cdFx0fSk7XG5cdFx0cCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XG5cblx0XHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgc2NvcGUsIHVzZVBhcmFtLCBwcmlvcml0eSkge1xuXHRcdFx0cHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwO1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGlzdGVuZXIsIGk7XG5cdFx0XHRpZiAodGhpcyA9PT0gX3RpY2tlciAmJiAhX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmIChsaXN0ID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdCA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyLmMgPT09IGNhbGxiYWNrICYmIGxpc3RlbmVyLnMgPT09IHNjb3BlKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgbGlzdGVuZXIucHIgPCBwcmlvcml0eSkge1xuXHRcdFx0XHRcdGluZGV4ID0gaSArIDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpc3Quc3BsaWNlKGluZGV4LCAwLCB7YzpjYWxsYmFjaywgczpzY29wZSwgdXA6dXNlUGFyYW0sIHByOnByaW9yaXR5fSk7XG5cdFx0fTtcblxuXHRcdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSwgaTtcblx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGxpc3RbaV0uYyA9PT0gY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcblx0XHRcdFx0aSwgdCwgbGlzdGVuZXI7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdGlmIChpID4gMSkge1xuXHRcdFx0XHRcdGxpc3QgPSBsaXN0LnNsaWNlKDApOyAvL2luIGNhc2UgYWRkRXZlbnRMaXN0ZW5lcigpIGlzIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGxpc3RlbmVyL2NhbGxiYWNrIChvdGhlcndpc2UgdGhlIGluZGV4IGNvdWxkIGNoYW5nZSwgcmVzdWx0aW5nIGluIGEgc2tpcClcblx0XHRcdFx0fVxuXHRcdFx0XHR0ID0gdGhpcy5fZXZlbnRUYXJnZXQ7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAobGlzdGVuZXIpIHtcblx0XHRcdFx0XHRcdGlmIChsaXN0ZW5lci51cCkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lci5jLmNhbGwobGlzdGVuZXIucyB8fCB0LCB7dHlwZTp0eXBlLCB0YXJnZXQ6dH0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGlja2VyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbiBcdFx0dmFyIF9yZXFBbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcblx0XHRcdF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO30sXG5cdFx0XHRfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCk7XG5cblx0XHQvL25vdyB0cnkgdG8gZGV0ZXJtaW5lIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIGNhbmNlbEFuaW1hdGlvbkZyYW1lIGZ1bmN0aW9ucyBhbmQgaWYgbm9uZSBhcmUgZm91bmQsIHdlJ2xsIHVzZSBhIHNldFRpbWVvdXQoKS9jbGVhclRpbWVvdXQoKSBwb2x5ZmlsbC5cblx0XHRhID0gW1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdO1xuXHRcdGkgPSBhLmxlbmd0aDtcblx0XHR3aGlsZSAoLS1pID4gLTEgJiYgIV9yZXFBbmltRnJhbWUpIHtcblx0XHRcdF9yZXFBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdFx0X2NhbmNlbEFuaW1GcmFtZSA9IHdpbmRvd1thW2ldICsgXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXSB8fCB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuXHRcdH1cblxuXHRcdF9jbGFzcyhcIlRpY2tlclwiLCBmdW5jdGlvbihmcHMsIHVzZVJBRikge1xuXHRcdFx0dmFyIF9zZWxmID0gdGhpcyxcblx0XHRcdFx0X3N0YXJ0VGltZSA9IF9nZXRUaW1lKCksXG5cdFx0XHRcdF91c2VSQUYgPSAodXNlUkFGICE9PSBmYWxzZSAmJiBfcmVxQW5pbUZyYW1lKSA/IFwiYXV0b1wiIDogZmFsc2UsXG5cdFx0XHRcdF9sYWdUaHJlc2hvbGQgPSA1MDAsXG5cdFx0XHRcdF9hZGp1c3RlZExhZyA9IDMzLFxuXHRcdFx0XHRfdGlja1dvcmQgPSBcInRpY2tcIiwgLy9oZWxwcyByZWR1Y2UgZ2MgYnVyZGVuXG5cdFx0XHRcdF9mcHMsIF9yZXEsIF9pZCwgX2dhcCwgX25leHRUaW1lLFxuXHRcdFx0XHRfdGljayA9IGZ1bmN0aW9uKG1hbnVhbCkge1xuXHRcdFx0XHRcdHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuXHRcdFx0XHRcdFx0b3ZlcmxhcCwgZGlzcGF0Y2g7XG5cdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkKSB7XG5cdFx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0X3NlbGYudGltZSA9IChfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWUpIC8gMTAwMDtcblx0XHRcdFx0XHRvdmVybGFwID0gX3NlbGYudGltZSAtIF9uZXh0VGltZTtcblx0XHRcdFx0XHRpZiAoIV9mcHMgfHwgb3ZlcmxhcCA+IDAgfHwgbWFudWFsID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5mcmFtZSsrO1xuXHRcdFx0XHRcdFx0X25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gMC4wMDQgOiBfZ2FwIC0gb3ZlcmxhcCk7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYW51YWwgIT09IHRydWUpIHsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblx0XHRcdFx0XHRcdF9pZCA9IF9yZXEoX3RpY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlzcGF0Y2gpIHtcblx0XHRcdFx0XHRcdF9zZWxmLmRpc3BhdGNoRXZlbnQoX3RpY2tXb3JkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdEV2ZW50RGlzcGF0Y2hlci5jYWxsKF9zZWxmKTtcblx0XHRcdF9zZWxmLnRpbWUgPSBfc2VsZi5mcmFtZSA9IDA7XG5cdFx0XHRfc2VsZi50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90aWNrKHRydWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYubGFnU21vb3RoaW5nID0gZnVuY3Rpb24odGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8ICgxIC8gX3RpbnlOdW0pOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuc2xlZXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3VzZVJBRiB8fCAhX2NhbmNlbEFuaW1GcmFtZSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jYW5jZWxBbmltRnJhbWUoX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gX2VtcHR5RnVuYztcblx0XHRcdFx0X2lkID0gbnVsbDtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi53YWtlID0gZnVuY3Rpb24oc2VhbWxlc3MpIHtcblx0XHRcdFx0aWYgKF9pZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IC1fbGFzdFVwZGF0ZSArIChfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zZWxmLmZyYW1lID4gMTApIHsgLy9kb24ndCB0cmlnZ2VyIGxhZ1Ntb290aGluZyBpZiB3ZSdyZSBqdXN0IHdha2luZyB1cCwgYW5kIG1ha2Ugc3VyZSB0aGF0IGF0IGxlYXN0IDEwIGZyYW1lcyBoYXZlIGVsYXBzZWQgYmVjYXVzZSBvZiB0aGUgaU9TIGJ1ZyB0aGF0IHdlIHdvcmsgYXJvdW5kIGJlbG93IHdpdGggdGhlIDEuNS1zZWNvbmQgc2V0VGltb3V0KCkuXG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpIC0gX2xhZ1RocmVzaG9sZCArIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IChfZnBzID09PSAwKSA/IF9lbXB0eUZ1bmMgOiAoIV91c2VSQUYgfHwgIV9yZXFBbmltRnJhbWUpID8gZnVuY3Rpb24oZikgeyByZXR1cm4gc2V0VGltZW91dChmLCAoKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEpIHwgMCk7IH0gOiBfcmVxQW5pbUZyYW1lO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGljaygyKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmZwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfZnBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mcHMgPSB2YWx1ZTtcblx0XHRcdFx0X2dhcCA9IDEgLyAoX2ZwcyB8fCA2MCk7XG5cdFx0XHRcdF9uZXh0VGltZSA9IHRoaXMudGltZSArIF9nYXA7XG5cdFx0XHRcdF9zZWxmLndha2UoKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnVzZVJBRiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfdXNlUkFGO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdF91c2VSQUYgPSB2YWx1ZTtcblx0XHRcdFx0X3NlbGYuZnBzKF9mcHMpO1xuXHRcdFx0fTtcblx0XHRcdF9zZWxmLmZwcyhmcHMpO1xuXG5cdFx0XHQvL2EgYnVnIGluIGlPUyA2IFNhZmFyaSBvY2Nhc2lvbmFsbHkgcHJldmVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHdvcmtpbmcgaW5pdGlhbGx5LCBzbyB3ZSB1c2UgYSAxLjUtc2Vjb25kIHRpbWVvdXQgdGhhdCBhdXRvbWF0aWNhbGx5IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCgpIGlmIGl0IHNlbnNlcyB0aGlzIGNvbmRpdGlvbi5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdXNlUkFGID09PSBcImF1dG9cIiAmJiBfc2VsZi5mcmFtZSA8IDUgJiYgX2RvYy52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIpIHtcblx0XHRcdFx0XHRfc2VsZi51c2VSQUYoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCAxNTAwKTtcblx0XHR9KTtcblxuXHRcdHAgPSBncy5UaWNrZXIucHJvdG90eXBlID0gbmV3IGdzLmV2ZW50cy5FdmVudERpc3BhdGNoZXIoKTtcblx0XHRwLmNvbnN0cnVjdG9yID0gZ3MuVGlja2VyO1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBbmltYXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBBbmltYXRpb24gPSBfY2xhc3MoXCJjb3JlLkFuaW1hdGlvblwiLCBmdW5jdGlvbihkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnMgPSB2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdFx0dGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbER1cmF0aW9uID0gZHVyYXRpb24gfHwgMDtcblx0XHRcdFx0dGhpcy5fZGVsYXkgPSBOdW1iZXIodmFycy5kZWxheSkgfHwgMDtcblx0XHRcdFx0dGhpcy5fdGltZVNjYWxlID0gMTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5kYXRhID0gdmFycy5kYXRhO1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9ICh2YXJzLnJldmVyc2VkID09PSB0cnVlKTtcblxuXHRcdFx0XHRpZiAoIV9yb290VGltZWxpbmUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7IC8vc29tZSBicm93c2VycyAobGlrZSBpT1MgNiBTYWZhcmkpIHNodXQgZG93biBKYXZhU2NyaXB0IGV4ZWN1dGlvbiB3aGVuIHRoZSB0YWIgaXMgZGlzYWJsZWQgYW5kIHRoZXkgW29jY2FzaW9uYWxseV0gbmVnbGVjdCB0byBzdGFydCB1cCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYWdhaW4gd2hlbiByZXR1cm5pbmcgLSB0aGlzIGNvZGUgZW5zdXJlcyB0aGF0IHRoZSBlbmdpbmUgc3RhcnRzIHVwIGFnYWluIHByb3Blcmx5LlxuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRsID0gdGhpcy52YXJzLnVzZUZyYW1lcyA/IF9yb290RnJhbWVzVGltZWxpbmUgOiBfcm9vdFRpbWVsaW5lO1xuXHRcdFx0XHR0bC5hZGQodGhpcywgdGwuX3RpbWUpO1xuXG5cdFx0XHRcdGlmICh0aGlzLnZhcnMucGF1c2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0X3RpY2tlciA9IEFuaW1hdGlvbi50aWNrZXIgPSBuZXcgZ3MuVGlja2VyKCk7XG5cdFx0cCA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG5cdFx0cC5fZGlydHkgPSBwLl9nYyA9IHAuX2luaXR0ZWQgPSBwLl9wYXVzZWQgPSBmYWxzZTtcblx0XHRwLl90b3RhbFRpbWUgPSBwLl90aW1lID0gMDtcblx0XHRwLl9yYXdQcmV2VGltZSA9IC0xO1xuXHRcdHAuX25leHQgPSBwLl9sYXN0ID0gcC5fb25VcGRhdGUgPSBwLl90aW1lbGluZSA9IHAudGltZWxpbmUgPSBudWxsO1xuXHRcdHAuX3BhdXNlZCA9IGZhbHNlO1xuXG5cblx0XHQvL3NvbWUgYnJvd3NlcnMgKGxpa2UgaU9TKSBvY2Nhc2lvbmFsbHkgZHJvcCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGV2ZW50IHdoZW4gdGhlIHVzZXIgc3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgdGFiIGFuZCB0aGVuIGNvbWVzIGJhY2sgYWdhaW4sIHNvIHdlIHVzZSBhIDItc2Vjb25kIHNldFRpbWVvdXQoKSB0byBzZW5zZSBpZi93aGVuIHRoYXQgY29uZGl0aW9uIG9jY3VycyBhbmQgdGhlbiB3YWtlKCkgdGhlIHRpY2tlci5cblx0XHR2YXIgX2NoZWNrVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoX3RpY2tlckFjdGl2ZSAmJiBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUgPiAyMDAwKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0VGltZW91dChfY2hlY2tUaW1lb3V0LCAyMDAwKTtcblx0XHRcdH07XG5cdFx0X2NoZWNrVGltZW91dCgpO1xuXG5cblx0XHRwLnBsYXkgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoZnJvbSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucGF1c2UgPSBmdW5jdGlvbihhdFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoYXRUaW1lICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlc3VtZSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnNlZWsgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0aW1lKSwgc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXN0YXJ0ID0gZnVuY3Rpb24oaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQoZmFsc2UpLnBhdXNlZChmYWxzZSkudG90YWxUaW1lKGluY2x1ZGVEZWxheSA/IC10aGlzLl9kZWxheSA6IDAsIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpLCB0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5yZXZlcnNlID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKChmcm9tIHx8IHRoaXMudG90YWxEdXJhdGlvbigpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdC8vc3R1YiAtIHdlIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIHN1YmNsYXNzZXMuXG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IDA7XG5cdFx0XHR0aGlzLl9pbml0dGVkID0gdGhpcy5fZ2MgPSBmYWxzZTtcblx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGwgPSB0aGlzLl90aW1lbGluZSwgLy90aGUgMiByb290IHRpbWVsaW5lcyB3b24ndCBoYXZlIGEgX3RpbWVsaW5lOyB0aGV5J3JlIGFsd2F5cyBhY3RpdmUuXG5cdFx0XHRcdHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cmF3VGltZTtcblx0XHRcdHJldHVybiAoIXRsIHx8ICghdGhpcy5fZ2MgJiYgIXRoaXMuX3BhdXNlZCAmJiB0bC5pc0FjdGl2ZSgpICYmIChyYXdUaW1lID0gdGwucmF3VGltZSh0cnVlKSkgPj0gc3RhcnRUaW1lICYmIHJhd1RpbWUgPCBzdGFydFRpbWUgKyB0aGlzLnRvdGFsRHVyYXRpb24oKSAvIHRoaXMuX3RpbWVTY2FsZSkpO1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24gKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9nYyA9ICFlbmFibGVkO1xuXHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0aWYgKGlnbm9yZVRpbWVsaW5lICE9PSB0cnVlKSB7XG5cdFx0XHRcdGlmIChlbmFibGVkICYmICF0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTtcblx0XHRcdFx0fSBlbHNlIGlmICghZW5hYmxlZCAmJiB0aGlzLnRpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAua2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0dGhpcy5fa2lsbCh2YXJzLCB0YXJnZXQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3VuY2FjaGUgPSBmdW5jdGlvbihpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIHR3ZWVuID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3N3YXBTZWxmSW5QYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHRcdHZhciBpID0gcGFyYW1zLmxlbmd0aCxcblx0XHRcdFx0Y29weSA9IHBhcmFtcy5jb25jYXQoKTtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGFyYW1zW2ldID09PSBcIntzZWxmfVwiKSB7XG5cdFx0XHRcdFx0Y29weVtpXSA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH07XG5cblx0XHRwLl9jYWxsYmFjayA9IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRjYWxsYmFjayA9IHZbdHlwZV0sXG5cdFx0XHRcdHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdLFxuXHRcdFx0XHRzY29wZSA9IHZbdHlwZSArIFwiU2NvcGVcIl0gfHwgdi5jYWxsYmFja1Njb3BlIHx8IHRoaXMsXG5cdFx0XHRcdGwgPSBwYXJhbXMgPyBwYXJhbXMubGVuZ3RoIDogMDtcblx0XHRcdHN3aXRjaCAobCkgeyAvL3NwZWVkIG9wdGltaXphdGlvbjsgY2FsbCgpIGlzIGZhc3RlciB0aGFuIGFwcGx5KCkgc28gdXNlIGl0IHdoZW4gdGhlcmUgYXJlIG9ubHkgYSBmZXcgcGFyYW1ldGVycyAod2hpY2ggaXMgYnkgZmFyIG1vc3QgY29tbW9uKS4gUHJldmlvdXNseSB3ZSBzaW1wbHkgZGlkIHZhciB2ID0gdGhpcy52YXJzOyB2W3R5cGVdLmFwcGx5KHZbdHlwZSArIFwiU2NvcGVcIl0gfHwgdi5jYWxsYmFja1Njb3BlIHx8IHRoaXMsIHZbdHlwZSArIFwiUGFyYW1zXCJdIHx8IF9ibGFua0FycmF5KTtcblx0XHRcdFx0Y2FzZSAwOiBjYWxsYmFjay5jYWxsKHNjb3BlKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMTogY2FsbGJhY2suY2FsbChzY29wZSwgcGFyYW1zWzBdKTsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMjogY2FsbGJhY2suY2FsbChzY29wZSwgcGFyYW1zWzBdLCBwYXJhbXNbMV0pOyBicmVhaztcblx0XHRcdFx0ZGVmYXVsdDogY2FsbGJhY2suYXBwbHkoc2NvcGUsIHBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuLy8tLS0tQW5pbWF0aW9uIGdldHRlcnMvc2V0dGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUpIHtcblx0XHRcdGlmICgodHlwZSB8fCBcIlwiKS5zdWJzdHIoMCwyKSA9PT0gXCJvblwiKSB7XG5cdFx0XHRcdHZhciB2ID0gdGhpcy52YXJzO1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB2W3R5cGVdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHZbdHlwZV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dlt0eXBlXSA9IGNhbGxiYWNrO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiUGFyYW1zXCJdID0gKF9pc0FycmF5KHBhcmFtcykgJiYgcGFyYW1zLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSAhPT0gLTEpID8gdGhpcy5fc3dhcFNlbGZJblBhcmFtcyhwYXJhbXMpIDogcGFyYW1zO1xuXHRcdFx0XHRcdHZbdHlwZSArIFwiU2NvcGVcIl0gPSBzY29wZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJvblVwZGF0ZVwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fb25VcGRhdGUgPSBjYWxsYmFjaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kZWxheTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHR0aGlzLnN0YXJ0VGltZSggdGhpcy5fc3RhcnRUaW1lICsgdmFsdWUgLSB0aGlzLl9kZWxheSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGVsYXkgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7IC8vdHJ1ZSBpbiBjYXNlIGl0J3MgYSBUd2Vlbk1heCBvciBUaW1lbGluZU1heCB0aGF0IGhhcyBhIHJlcGVhdCAtIHdlJ2xsIG5lZWQgdG8gcmVmcmVzaCB0aGUgdG90YWxEdXJhdGlvbi5cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgaWYgKHRoaXMuX3RpbWUgPiAwKSBpZiAodGhpcy5fdGltZSA8IHRoaXMuX2R1cmF0aW9uKSBpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lICogKHZhbHVlIC8gdGhpcy5fZHVyYXRpb24pLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMuZHVyYXRpb24odmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRpbWUgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHR0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnRvdGFsVGltZSgodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikgPyB0aGlzLl9kdXJhdGlvbiA6IHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxUaW1lID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIHVuY2FwcGVkKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RvdGFsVGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgIXVuY2FwcGVkKSB7XG5cdFx0XHRcdFx0dGltZSArPSB0aGlzLnRvdGFsRHVyYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdG90YWxEdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24sXG5cdFx0XHRcdFx0XHR0bCA9IHRoaXMuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdGlmICh0aW1lID4gdG90YWxEdXJhdGlvbiAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHRcdHRpbWUgPSB0b3RhbER1cmF0aW9uO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSAodGhpcy5fcGF1c2VkID8gdGhpcy5fcGF1c2VUaW1lIDogdGwuX3RpbWUpIC0gKCghdGhpcy5fcmV2ZXJzZWQgPyB0aW1lIDogdG90YWxEdXJhdGlvbiAtIHRpbWUpIC8gdGhpcy5fdGltZVNjYWxlKTtcblx0XHRcdFx0XHRpZiAoIXRsLl9kaXJ0eSkgeyAvL2ZvciBwZXJmb3JtYW5jZSBpbXByb3ZlbWVudC4gSWYgdGhlIHBhcmVudCdzIGNhY2hlIGlzIGFscmVhZHkgZGlydHksIGl0IGFscmVhZHkgdG9vayBjYXJlIG9mIG1hcmtpbmcgdGhlIGFuY2VzdG9ycyBhcyBkaXJ0eSB0b28sIHNvIHNraXAgdGhlIGZ1bmN0aW9uIGNhbGwgaGVyZS5cblx0XHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvciB0aW1lbGluZXMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLCB3ZSBzaG91bGQgcmVzZXQgdGhlaXIgdG90YWxUaW1lKCkgd2hpY2ggd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZXkncmUgbGluZWQgdXAgcHJvcGVybHkgYW5kIGVuYWJsZWQuIFNraXAgZm9yIGFuaW1hdGlvbnMgdGhhdCBhcmUgb24gdGhlIHJvb3QgKHdhc3RlZnVsKS4gRXhhbXBsZTogYSBUaW1lbGluZUxpdGUuZXhwb3J0Um9vdCgpIGlzIHBlcmZvcm1lZCB3aGVuIHRoZXJlJ3MgYSBwYXVzZWQgdHdlZW4gb24gdGhlIHJvb3QsIHRoZSBleHBvcnQgd2lsbCBub3QgY29tcGxldGUgdW50aWwgdGhhdCB0d2VlbiBpcyB1bnBhdXNlZCwgYnV0IGltYWdpbmUgYSBjaGlsZCBnZXRzIHJlc3RhcnRlZCBsYXRlciwgYWZ0ZXIgYWxsIFt1bnBhdXNlZF0gdHdlZW5zIGhhdmUgY29tcGxldGVkLiBUaGUgc3RhcnRUaW1lIG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cdFx0XHRcdFx0aWYgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lLl90aW1lICE9PSAodGwuX3N0YXJ0VGltZSArIHRsLl90b3RhbFRpbWUpIC8gdGwuX3RpbWVTY2FsZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRsLnRvdGFsVGltZSh0bC5fdG90YWxUaW1lLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gdGltZSB8fCB0aGlzLl9kdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmYWxzZSk7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gc29tZW9uZSBjYWxscyBzZWVrKCkgb3IgdGltZSgpIG9yIHByb2dyZXNzKCksIHRoZXkgZXhwZWN0IGFuIGltbWVkaWF0ZSByZW5kZXIuXG5cdFx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucHJvZ3Jlc3MgPSBwLnRvdGFsUHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gKGR1cmF0aW9uID8gdGhpcy5fdGltZSAvIGR1cmF0aW9uIDogdGhpcy5yYXRpbykgOiB0aGlzLnRvdGFsVGltZShkdXJhdGlvbiAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuc3RhcnRUaW1lID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB0aGlzLl9zdGFydFRpbWUpIHtcblx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLnRpbWVsaW5lKSBpZiAodGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdFx0dGhpcy50aW1lbGluZS5hZGQodGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7IC8vZW5zdXJlcyB0aGF0IGFueSBuZWNlc3NhcnkgcmUtc2VxdWVuY2luZyBvZiBBbmltYXRpb25zIGluIHRoZSB0aW1lbGluZSBvY2N1cnMgdG8gbWFrZSBzdXJlIHRoZSByZW5kZXJpbmcgb3JkZXIgaXMgY29ycmVjdC5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZW5kVGltZSA9IGZ1bmN0aW9uKGluY2x1ZGVSZXBlYXRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnRUaW1lICsgKChpbmNsdWRlUmVwZWF0cyAhPSBmYWxzZSkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuZHVyYXRpb24oKSkgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHAudGltZVNjYWxlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUgJiYgdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0dmFyIHBhdXNlVGltZSA9IHRoaXMuX3BhdXNlVGltZSxcblx0XHRcdFx0XHR0ID0gKHBhdXNlVGltZSB8fCBwYXVzZVRpbWUgPT09IDApID8gcGF1c2VUaW1lIDogdGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAucmV2ZXJzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9yZXZlcnNlZCkge1xuXHRcdFx0XHR0aGlzLl9yZXZlcnNlZCA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSgoKHRoaXMuX3RpbWVsaW5lICYmICF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSAtIHRoaXMuX3RvdGFsVGltZSA6IHRoaXMuX3RvdGFsVGltZSksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmUsXG5cdFx0XHRcdHJhdywgZWxhcHNlZDtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzLl9wYXVzZWQpIGlmICh0bCkge1xuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUgJiYgIXZhbHVlKSB7XG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmF3ID0gdGwucmF3VGltZSgpO1xuXHRcdFx0XHRlbGFwc2VkID0gcmF3IC0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIHRsLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IGVsYXBzZWQ7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcGF1c2VUaW1lID0gdmFsdWUgPyByYXcgOiBudWxsO1xuXHRcdFx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXHRcdFx0XHRpZiAoIXZhbHVlICYmIGVsYXBzZWQgIT09IDAgJiYgdGhpcy5faW5pdHRlZCAmJiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0XHRyYXcgPSB0bC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMuX3RvdGFsVGltZSA6IChyYXcgLSB0aGlzLl9zdGFydFRpbWUpIC8gdGhpcy5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHJhdywgKHJhdyA9PT0gdGhpcy5fdG90YWxUaW1lKSwgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBjaGFuZ2VkIHZpYSBzb21lIG90aGVyIHR3ZWVuIG9yIG1hbnVhbCB1cGRhdGUgYnkgdGhlIHVzZXIsIHdlIHNob3VsZCBmb3JjZSBhIHJlbmRlci5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2djICYmICF2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFNpbXBsZVRpbWVsaW5lXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgU2ltcGxlVGltZWxpbmUgPSBfY2xhc3MoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIDAsIHZhcnMpO1xuXHRcdFx0dGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSB0aGlzLnNtb290aENoaWxkVGltaW5nID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHAgPSBTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUgPSBuZXcgQW5pbWF0aW9uKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFNpbXBsZVRpbWVsaW5lO1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdHAuX2ZpcnN0ID0gcC5fbGFzdCA9IHAuX3JlY2VudCA9IG51bGw7XG5cdFx0cC5fc29ydENoaWxkcmVuID0gZmFsc2U7XG5cblx0XHRwLmFkZCA9IHAuaW5zZXJ0ID0gZnVuY3Rpb24oY2hpbGQsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIHByZXZUd2Vlbiwgc3Q7XG5cdFx0XHRjaGlsZC5fc3RhcnRUaW1lID0gTnVtYmVyKHBvc2l0aW9uIHx8IDApICsgY2hpbGQuX2RlbGF5O1xuXHRcdFx0aWYgKGNoaWxkLl9wYXVzZWQpIGlmICh0aGlzICE9PSBjaGlsZC5fdGltZWxpbmUpIHsgLy93ZSBvbmx5IGFkanVzdCB0aGUgX3BhdXNlVGltZSBpZiBpdCB3YXNuJ3QgaW4gdGhpcyB0aW1lbGluZSBhbHJlYWR5LiBSZW1lbWJlciwgc29tZXRpbWVzIGEgdHdlZW4gd2lsbCBiZSBpbnNlcnRlZCBhZ2FpbiBpbnRvIHRoZSBzYW1lIHRpbWVsaW5lIHdoZW4gaXRzIHN0YXJ0VGltZSBpcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIHR3ZWVucyBpbiB0aGUgVGltZWxpbmVMaXRlL01heCBhcmUgcmUtb3JkZXJlZCBwcm9wZXJseSBpbiB0aGUgbGlua2VkIGxpc3QgKHNvIGV2ZXJ5dGhpbmcgcmVuZGVycyBpbiB0aGUgcHJvcGVyIG9yZGVyKS5cblx0XHRcdFx0Y2hpbGQuX3BhdXNlVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoKHRoaXMucmF3VGltZSgpIC0gY2hpbGQuX3N0YXJ0VGltZSkgLyBjaGlsZC5fdGltZVNjYWxlKTtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC50aW1lbGluZSkge1xuXHRcdFx0XHRjaGlsZC50aW1lbGluZS5fcmVtb3ZlKGNoaWxkLCB0cnVlKTsgLy9yZW1vdmVzIGZyb20gZXhpc3RpbmcgdGltZWxpbmUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgYWRkZWQgdG8gdGhpcyBvbmUuXG5cdFx0XHR9XG5cdFx0XHRjaGlsZC50aW1lbGluZSA9IGNoaWxkLl90aW1lbGluZSA9IHRoaXM7XG5cdFx0XHRpZiAoY2hpbGQuX2djKSB7XG5cdFx0XHRcdGNoaWxkLl9lbmFibGVkKHRydWUsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdGlmICh0aGlzLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0c3QgPSBjaGlsZC5fc3RhcnRUaW1lO1xuXHRcdFx0XHR3aGlsZSAocHJldlR3ZWVuICYmIHByZXZUd2Vlbi5fc3RhcnRUaW1lID4gc3QpIHtcblx0XHRcdFx0XHRwcmV2VHdlZW4gPSBwcmV2VHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VHdlZW4pIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSBwcmV2VHdlZW4uX25leHQ7XG5cdFx0XHRcdHByZXZUd2Vlbi5fbmV4dCA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGQuX25leHQgPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0dGhpcy5fZmlyc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZC5fbmV4dCkge1xuXHRcdFx0XHRjaGlsZC5fbmV4dC5fcHJldiA9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fbGFzdCA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGQuX3ByZXYgPSBwcmV2VHdlZW47XG5cdFx0XHR0aGlzLl9yZWNlbnQgPSBjaGlsZDtcblx0XHRcdGlmICh0aGlzLl90aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX3JlbW92ZSA9IGZ1bmN0aW9uKHR3ZWVuLCBza2lwRGlzYWJsZSkge1xuXHRcdFx0aWYgKHR3ZWVuLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdGlmICghc2tpcERpc2FibGUpIHtcblx0XHRcdFx0XHR0d2Vlbi5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodHdlZW4uX3ByZXYpIHtcblx0XHRcdFx0XHR0d2Vlbi5fcHJldi5fbmV4dCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0ID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR3ZWVuLl9uZXh0KSB7XG5cdFx0XHRcdFx0dHdlZW4uX25leHQuX3ByZXYgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdHRoaXMuX2xhc3QgPSB0d2Vlbi5fcHJldjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2Vlbi5fbmV4dCA9IHR3ZWVuLl9wcmV2ID0gdHdlZW4udGltZWxpbmUgPSBudWxsO1xuXHRcdFx0XHRpZiAodHdlZW4gPT09IHRoaXMuX3JlY2VudCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRuZXh0O1xuXHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRuZXh0ID0gdHdlZW4uX25leHQ7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRpZiAodHdlZW4uX2FjdGl2ZSB8fCAodGltZSA+PSB0d2Vlbi5fc3RhcnRUaW1lICYmICF0d2Vlbi5fcGF1c2VkKSkge1xuXHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0fTtcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuTGl0ZSA9IF9jbGFzcyhcIlR3ZWVuTGl0ZVwiLCBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2VlbkxpdGUucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblxuXHRcdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXG5cdFx0XHRcdHZhciBpc1NlbGVjdG9yID0gKHRhcmdldC5qcXVlcnkgfHwgKHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0WzBdICYmICh0YXJnZXRbMF0gPT09IHdpbmRvdyB8fCAodGFyZ2V0WzBdLm5vZGVUeXBlICYmIHRhcmdldFswXS5zdHlsZSAmJiAhdGFyZ2V0Lm5vZGVUeXBlKSkpKSxcblx0XHRcdFx0XHRvdmVyd3JpdGUgPSB0aGlzLnZhcnMub3ZlcndyaXRlLFxuXHRcdFx0XHRcdGksIHRhcmcsIHRhcmdldHM7XG5cblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlID0gKG92ZXJ3cml0ZSA9PSBudWxsKSA/IF9vdmVyd3JpdGVMb29rdXBbVHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGVdIDogKHR5cGVvZihvdmVyd3JpdGUpID09PSBcIm51bWJlclwiKSA/IG92ZXJ3cml0ZSA+PiAwIDogX292ZXJ3cml0ZUxvb2t1cFtvdmVyd3JpdGVdO1xuXG5cdFx0XHRcdGlmICgoaXNTZWxlY3RvciB8fCB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSB8fCAodGFyZ2V0LnB1c2ggJiYgX2lzQXJyYXkodGFyZ2V0KSkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0KTsgIC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gW107XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmcpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpLS1dID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmcpOyAvL2luIGNhc2UgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpKzEsIDEpOyAvL3RvIGF2b2lkIGFuIGVuZGxlc3MgbG9vcCAoY2FuJ3QgaW1hZ2luZSB3aHkgdGhlIHNlbGVjdG9yIHdvdWxkIHJldHVybiBhIHN0cmluZywgYnV0IGp1c3QgaW4gY2FzZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZy5sZW5ndGggJiYgdGFyZyAhPT0gd2luZG93ICYmIHRhcmdbMF0gJiYgKHRhcmdbMF0gPT09IHdpbmRvdyB8fCAodGFyZ1swXS5ub2RlVHlwZSAmJiB0YXJnWzBdLnN0eWxlICYmICF0YXJnLm5vZGVUeXBlKSkpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGlzIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc2VsZWN0b3Igb2JqZWN0cyAobGlrZSBqUXVlcnkgb2JqZWN0cyksIHdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgbGV2ZWwgYW5kIHB1bGwgdGhpbmdzIG91dCBpZiBuZWNlc3NhcnkuIEFsc28gbm90ZSB0aGF0IDxzZWxlY3Q+IGVsZW1lbnRzIHBhc3MgYWxsIHRoZSBjcml0ZXJpYSByZWdhcmRpbmcgbGVuZ3RoIGFuZCB0aGUgZmlyc3QgY2hpbGQgaGF2aW5nIHN0eWxlLCBzbyB3ZSBtdXN0IGFsc28gY2hlY2sgdG8gZW5zdXJlIHRoZSB0YXJnZXQgaXNuJ3QgYW4gSFRNTCBub2RlIGl0c2VsZi5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChfc2xpY2UodGFyZykpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmcsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5nc1tpXS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnLCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5nc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IHt9O1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRhcmdldCwgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5ncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5ncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9kZWxheSA9PT0gMCAmJiB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihNYXRoLm1pbigwLCAtdGhpcy5fZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAodiAmJiB2Lmxlbmd0aCAmJiB2ICE9PSB3aW5kb3cgJiYgdlswXSAmJiAodlswXSA9PT0gd2luZG93IHx8ICh2WzBdLm5vZGVUeXBlICYmIHZbMF0uc3R5bGUgJiYgIXYubm9kZVR5cGUpKSk7IC8vd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBpZiB0aGUgdGFyZ2V0IGlzIHdpbmRvdyBmcm9tIHdpdGhpbiBhbiBpZnJhbWUsIG90aGVyd2lzZSBpdCB3aWxsIHRyaWdnZXIgYSBzZWN1cml0eSBlcnJvciBpbiBzb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHRcdH0sXG5cdFx0XHRfYXV0b0NTUyA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0XHR2YXIgY3NzID0ge30sXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdICYmICghKHAgaW4gdGFyZ2V0KSB8fCBwID09PSBcInRyYW5zZm9ybVwiIHx8IHAgPT09IFwieFwiIHx8IHAgPT09IFwieVwiIHx8IHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwiY2xhc3NOYW1lXCIgfHwgcCA9PT0gXCJib3JkZXJcIikgJiYgKCFfcGx1Z2luc1twXSB8fCAoX3BsdWdpbnNbcF0gJiYgX3BsdWdpbnNbcF0uX2F1dG9DU1MpKSkgeyAvL25vdGU6IDxpbWc+IGVsZW1lbnRzIGNvbnRhaW4gcmVhZC1vbmx5IFwieFwiIGFuZCBcInlcIiBwcm9wZXJ0aWVzLiBXZSBzaG91bGQgYWxzbyBwcmlvcml0aXplIGVkaXRpbmcgY3NzIHdpZHRoL2hlaWdodCByYXRoZXIgdGhhbiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHRjc3NbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhcnNbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMuY3NzID0gY3NzO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUd2VlbkxpdGUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2VlbkxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cbi8vLS0tLVR3ZWVuTGl0ZSBkZWZhdWx0cywgb3ZlcndyaXRlIG1hbmFnZW1lbnQsIGFuZCByb290IHVwZGF0ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5yYXRpbyA9IDA7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX3RhcmdldHMgPSBwLl9vdmVyd3JpdHRlblByb3BzID0gcC5fc3RhcnRBdCA9IG51bGw7XG5cdFx0cC5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHAuX2xhenkgPSBmYWxzZTtcblxuXHRcdFR3ZWVuTGl0ZS52ZXJzaW9uID0gXCIxLjE5LjFcIjtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdEVhc2UgPSBwLl9lYXNlID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMSk7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGUgPSBcImF1dG9cIjtcblx0XHRUd2VlbkxpdGUudGlja2VyID0gX3RpY2tlcjtcblx0XHRUd2VlbkxpdGUuYXV0b1NsZWVwID0gMTIwO1xuXHRcdFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRfdGlja2VyLmxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeSB8fCBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5O1xuXHRcdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3IoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZihfZG9jKSA9PT0gXCJ1bmRlZmluZWRcIikgPyBlIDogKF9kb2MucXVlcnlTZWxlY3RvckFsbCA/IF9kb2MucXVlcnlTZWxlY3RvckFsbChlKSA6IF9kb2MuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X251bWJlcnNFeHAgPSAvKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG5cdFx0XHQvL19ub25OdW1iZXJzRXhwID0gLyg/OihbXFwtK10oPyEoXFxkfD0pKSl8W15cXGRcXC0rPWVdfChlKD8hW1xcLStdW1xcZF0pKSkrL2lnLFxuXHRcdFx0X3NldFJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgcHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdHZhbDtcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0dmFsID0gIXB0LmJsb2IgPyBwdC5jICogdiArIHB0LnMgOiAodiA9PT0gMSkgPyB0aGlzLmVuZCA6IHYgPyB0aGlzLmpvaW4oXCJcIikgOiB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRcdGlmIChwdC5tKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBwdC5tKHZhbCwgdGhpcy5fdGFyZ2V0IHx8IHB0LnQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbiAmJiAhcHQuYmxvYikgeyAvL3ByZXZlbnRzIGlzc3VlcyB3aXRoIGNvbnZlcnRpbmcgdmVyeSBzbWFsbCBudW1iZXJzIHRvIHN0cmluZ3MgaW4gdGhlIGJyb3dzZXJcblx0XHRcdFx0XHRcdHZhbCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghcHQuZikge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHZhbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LmZwKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmZwLCB2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvL2NvbXBhcmVzIHR3byBzdHJpbmdzIChzdGFydC9lbmQpLCBmaW5kcyB0aGUgbnVtYmVycyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIHNwaXRzIGJhY2sgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB3aG9sZSB2YWx1ZSBidXQgd2l0aCB0aGUgY2hhbmdpbmcgdmFsdWVzIGlzb2xhdGVkIGFzIGVsZW1lbnRzLiBGb3IgZXhhbXBsZSwgXCJyZ2IoMCwwLDApXCIgYW5kIFwicmdiKDEwMCw1MCwwKVwiIHdvdWxkIGJlY29tZSBbXCJyZ2IoXCIsIDAsIFwiLFwiLCA1MCwgXCIsMClcIl0uIE5vdGljZSBpdCBtZXJnZXMgdGhlIHBhcnRzIHRoYXQgYXJlIGlkZW50aWNhbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKS4gVGhlIGFycmF5IGFsc28gaGFzIGEgbGlua2VkIGxpc3Qgb2YgUHJvcFR3ZWVucyBhdHRhY2hlZCBzdGFydGluZyB3aXRoIF9maXJzdFBUIHRoYXQgY29udGFpbiB0aGUgdHdlZW5pbmcgZGF0YSAodCwgcCwgcywgYywgZiwgZXRjLikuIEl0IGFsc28gc3RvcmVzIHRoZSBzdGFydGluZyB2YWx1ZSBhcyBhIFwic3RhcnRcIiBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiByZXZlcnQgdG8gaXQgaWYvd2hlbiBuZWNlc3NhcnksIGxpa2Ugd2hlbiBhIHR3ZWVuIHJld2luZHMgZnVsbHkuIElmIHRoZSBxdWFudGl0eSBvZiBudW1iZXJzIGRpZmZlcnMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCwgaXQgd2lsbCBhbHdheXMgcHJpb3JpdGl6ZSB0aGUgZW5kIHZhbHVlKHMpLiBUaGUgcHQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIC0gaXQncyBmb3IgYSBQcm9wVHdlZW4gdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0IGFuZCBpcyB0eXBpY2FsbHkgZm9yIGFjdHVhbGx5IHNldHRpbmcgdGhlIHZhbHVlIGFmdGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQgKHdpdGggYXJyYXkuam9pbihcIlwiKSkuXG5cdFx0XHRfYmxvYkRpZiA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGZpbHRlciwgcHQpIHtcblx0XHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0XHRjaGFySW5kZXggPSAwLFxuXHRcdFx0XHRcdHMgPSBcIlwiLFxuXHRcdFx0XHRcdGNvbG9yID0gMCxcblx0XHRcdFx0XHRzdGFydE51bXMsIGVuZE51bXMsIG51bSwgaSwgbCwgbm9uTnVtYmVycywgY3VycmVudE51bTtcblx0XHRcdFx0YS5zdGFydCA9IHN0YXJ0O1xuXHRcdFx0XHRhLmVuZCA9IGVuZDtcblx0XHRcdFx0c3RhcnQgPSBhWzBdID0gc3RhcnQgKyBcIlwiOyAvL2Vuc3VyZSB2YWx1ZXMgYXJlIHN0cmluZ3Ncblx0XHRcdFx0ZW5kID0gYVsxXSA9IGVuZCArIFwiXCI7XG5cdFx0XHRcdGlmIChmaWx0ZXIpIHtcblx0XHRcdFx0XHRmaWx0ZXIoYSk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblx0XHRcdFx0XHRzdGFydCA9IGFbMF07XG5cdFx0XHRcdFx0ZW5kID0gYVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLmxlbmd0aCA9IDA7XG5cdFx0XHRcdHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcblx0XHRcdFx0ZW5kTnVtcyA9IGVuZC5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG5cdFx0XHRcdGlmIChwdCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0ID0gbnVsbDtcblx0XHRcdFx0XHRwdC5ibG9iID0gMTtcblx0XHRcdFx0XHRhLl9maXJzdFBUID0gYS5fYXBwbHlQVCA9IHB0OyAvL2FwcGx5IGxhc3QgaW4gdGhlIGxpbmtlZCBsaXN0ICh3aGljaCBtZWFucyBpbnNlcnRpbmcgaXQgZmlyc3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IGVuZE51bXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y3VycmVudE51bSA9IGVuZE51bXNbaV07XG5cdFx0XHRcdFx0bm9uTnVtYmVycyA9IGVuZC5zdWJzdHIoY2hhckluZGV4LCBlbmQuaW5kZXhPZihjdXJyZW50TnVtLCBjaGFySW5kZXgpLWNoYXJJbmRleCk7XG5cdFx0XHRcdFx0cyArPSAobm9uTnVtYmVycyB8fCAhaSkgPyBub25OdW1iZXJzIDogXCIsXCI7IC8vbm90ZTogU1ZHIHNwZWMgYWxsb3dzIG9taXNzaW9uIG9mIGNvbW1hL3NwYWNlIHdoZW4gYSBuZWdhdGl2ZSBzaWduIGlzIHdlZGdlZCBiZXR3ZWVuIHR3byBudW1iZXJzLCBsaWtlIDIuNS01LjMgaW5zdGVhZCBvZiAyLjUsLTUuMyBidXQgd2hlbiB0d2VlbmluZywgdGhlIG5lZ2F0aXZlIHZhbHVlIG1heSBzd2l0Y2ggdG8gcG9zaXRpdmUsIHNvIHdlIGluc2VydCB0aGUgY29tbWEganVzdCBpbiBjYXNlLlxuXHRcdFx0XHRcdGNoYXJJbmRleCArPSBub25OdW1iZXJzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoY29sb3IpIHsgLy9zZW5zZSByZ2JhKCkgdmFsdWVzIGFuZCByb3VuZCB0aGVtLlxuXHRcdFx0XHRcdFx0Y29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub25OdW1iZXJzLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuXHRcdFx0XHRcdFx0Y29sb3IgPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY3VycmVudE51bSA9PT0gc3RhcnROdW1zW2ldIHx8IHN0YXJ0TnVtcy5sZW5ndGggPD0gaSkge1xuXHRcdFx0XHRcdFx0cyArPSBjdXJyZW50TnVtO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAocykge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2gocyk7XG5cdFx0XHRcdFx0XHRcdHMgPSBcIlwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bnVtID0gcGFyc2VGbG9hdChzdGFydE51bXNbaV0pO1xuXHRcdFx0XHRcdFx0YS5wdXNoKG51bSk7XG5cdFx0XHRcdFx0XHRhLl9maXJzdFBUID0ge19uZXh0OiBhLl9maXJzdFBULCB0OmEsIHA6IGEubGVuZ3RoLTEsIHM6bnVtLCBjOigoY3VycmVudE51bS5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KGN1cnJlbnROdW0uY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQoY3VycmVudE51bS5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoY3VycmVudE51bSkgLSBudW0pKSB8fCAwLCBmOjAsIG06KGNvbG9yICYmIGNvbG9yIDwgNCkgPyBNYXRoLnJvdW5kIDogMH07XG5cdFx0XHRcdFx0XHQvL25vdGU6IHdlIGRvbid0IHNldCBfcHJldiBiZWNhdXNlIHdlJ2xsIG5ldmVyIG5lZWQgdG8gcmVtb3ZlIGluZGl2aWR1YWwgUHJvcFR3ZWVucyBmcm9tIHRoaXMgbGlzdC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hhckluZGV4ICs9IGN1cnJlbnROdW0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHMgKz0gZW5kLnN1YnN0cihjaGFySW5kZXgpO1xuXHRcdFx0XHRpZiAocykge1xuXHRcdFx0XHRcdGEucHVzaChzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnNldFJhdGlvID0gX3NldFJhdGlvO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHQvL25vdGU6IFwiZnVuY1BhcmFtXCIgaXMgb25seSBuZWNlc3NhcnkgZm9yIGZ1bmN0aW9uLWJhc2VkIGdldHRlcnMvc2V0dGVycyB0aGF0IHJlcXVpcmUgYW4gZXh0cmEgcGFyYW1ldGVyIGxpa2UgZ2V0QXR0cmlidXRlKFwid2lkdGhcIikgYW5kIHNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHZhbHVlKS4gSW4gdGhpcyBleGFtcGxlLCBmdW5jUGFyYW0gd291bGQgYmUgXCJ3aWR0aFwiLiBVc2VkIGJ5IEF0dHJQbHVnaW4gZm9yIGV4YW1wbGUuXG5cdFx0XHRfYWRkUHJvcFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBvdmVyd3JpdGVQcm9wLCBtb2QsIGZ1bmNQYXJhbSwgc3RyaW5nRmlsdGVyLCBpbmRleCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGVuZCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mKHRhcmdldFtwcm9wXSksXG5cdFx0XHRcdFx0Z2V0dGVyTmFtZSA9ICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpID8gXCJcIiA6ICgocHJvcC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpKSxcblx0XHRcdFx0XHRzID0gKHN0YXJ0ICE9PSBcImdldFwiKSA/IHN0YXJ0IDogIWdldHRlck5hbWUgPyB0YXJnZXRbcHJvcF0gOiBmdW5jUGFyYW0gPyB0YXJnZXRbZ2V0dGVyTmFtZV0oZnVuY1BhcmFtKSA6IHRhcmdldFtnZXR0ZXJOYW1lXSgpLFxuXHRcdFx0XHRcdGlzUmVsYXRpdmUgPSAodHlwZW9mKGVuZCkgPT09IFwic3RyaW5nXCIgJiYgZW5kLmNoYXJBdCgxKSA9PT0gXCI9XCIpLFxuXHRcdFx0XHRcdHB0ID0ge3Q6dGFyZ2V0LCBwOnByb3AsIHM6cywgZjoodHlwZSA9PT0gXCJmdW5jdGlvblwiKSwgcGc6MCwgbjpvdmVyd3JpdGVQcm9wIHx8IHByb3AsIG06KCFtb2QgPyAwIDogKHR5cGVvZihtb2QpID09PSBcImZ1bmN0aW9uXCIpID8gbW9kIDogTWF0aC5yb3VuZCksIHByOjAsIGM6aXNSZWxhdGl2ZSA/IHBhcnNlSW50KGVuZC5jaGFyQXQoMCkgKyBcIjFcIiwgMTApICogcGFyc2VGbG9hdChlbmQuc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGVuZCkgLSBzKSB8fCAwfSxcblx0XHRcdFx0XHRibG9iO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YocykgIT09IFwibnVtYmVyXCIgfHwgKHR5cGVvZihlbmQpICE9PSBcIm51bWJlclwiICYmICFpc1JlbGF0aXZlKSkge1xuXHRcdFx0XHRcdGlmIChmdW5jUGFyYW0gfHwgaXNOYU4ocykgfHwgKCFpc1JlbGF0aXZlICYmIGlzTmFOKGVuZCkpIHx8IHR5cGVvZihzKSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mKGVuZCkgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdFx0XHQvL2EgYmxvYiAoc3RyaW5nIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gaXQpXG5cdFx0XHRcdFx0XHRwdC5mcCA9IGZ1bmNQYXJhbTtcblx0XHRcdFx0XHRcdGJsb2IgPSBfYmxvYkRpZihzLCAoaXNSZWxhdGl2ZSA/IHB0LnMgKyBwdC5jIDogZW5kKSwgc3RyaW5nRmlsdGVyIHx8IFR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyLCBwdCk7XG5cdFx0XHRcdFx0XHRwdCA9IHt0OiBibG9iLCBwOiBcInNldFJhdGlvXCIsIHM6IDAsIGM6IDEsIGY6IDIsIHBnOiAwLCBuOiBvdmVyd3JpdGVQcm9wIHx8IHByb3AsIHByOiAwLCBtOiAwfTsgLy9cIjJcIiBpbmRpY2F0ZXMgaXQncyBhIEJsb2IgcHJvcGVydHkgdHdlZW4uIE5lZWRlZCBmb3IgUm91bmRQcm9wc1BsdWdpbiBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQucyA9IHBhcnNlRmxvYXQocyk7XG5cdFx0XHRcdFx0XHRpZiAoIWlzUmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdFx0cHQuYyA9IChwYXJzZUZsb2F0KGVuZCkgLSBwdC5zKSB8fCAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHQuYykgeyAvL29ubHkgYWRkIGl0IHRvIHRoZSBsaW5rZWQgbGlzdCBpZiB0aGVyZSdzIGEgY2hhbmdlLlxuXHRcdFx0XHRcdGlmICgocHQuX25leHQgPSB0aGlzLl9maXJzdFBUKSkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0O1xuXHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdF9pbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyA9IHtpc0FycmF5Ol9pc0FycmF5LCBpc1NlbGVjdG9yOl9pc1NlbGVjdG9yLCBsYXp5VHdlZW5zOl9sYXp5VHdlZW5zLCBibG9iRGlmOl9ibG9iRGlmfSwgLy9naXZlcyB1cyBhIHdheSB0byBleHBvc2UgY2VydGFpbiBwcml2YXRlIHZhbHVlcyB0byBvdGhlciBHcmVlblNvY2sgY2xhc3NlcyB3aXRob3V0IGNvbnRhbWluYXRpbmcgdGhhIG1haW4gVHdlZW5MaXRlIG9iamVjdC5cblx0XHRcdF9wbHVnaW5zID0gVHdlZW5MaXRlLl9wbHVnaW5zID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXAgPSBfaW50ZXJuYWxzLnR3ZWVuTG9va3VwID0ge30sXG5cdFx0XHRfdHdlZW5Mb29rdXBOdW0gPSAwLFxuXHRcdFx0X3Jlc2VydmVkUHJvcHMgPSBfaW50ZXJuYWxzLnJlc2VydmVkUHJvcHMgPSB7ZWFzZToxLCBkZWxheToxLCBvdmVyd3JpdGU6MSwgb25Db21wbGV0ZToxLCBvbkNvbXBsZXRlUGFyYW1zOjEsIG9uQ29tcGxldGVTY29wZToxLCB1c2VGcmFtZXM6MSwgcnVuQmFja3dhcmRzOjEsIHN0YXJ0QXQ6MSwgb25VcGRhdGU6MSwgb25VcGRhdGVQYXJhbXM6MSwgb25VcGRhdGVTY29wZToxLCBvblN0YXJ0OjEsIG9uU3RhcnRQYXJhbXM6MSwgb25TdGFydFNjb3BlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlOjEsIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsIG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSwgb25SZXBlYXQ6MSwgb25SZXBlYXRQYXJhbXM6MSwgb25SZXBlYXRTY29wZToxLCBlYXNlUGFyYW1zOjEsIHlveW86MSwgaW1tZWRpYXRlUmVuZGVyOjEsIHJlcGVhdDoxLCByZXBlYXREZWxheToxLCBkYXRhOjEsIHBhdXNlZDoxLCByZXZlcnNlZDoxLCBhdXRvQ1NTOjEsIGxhenk6MSwgb25PdmVyd3JpdGU6MSwgY2FsbGJhY2tTY29wZToxLCBzdHJpbmdGaWx0ZXI6MSwgaWQ6MX0sXG5cdFx0XHRfb3ZlcndyaXRlTG9va3VwID0ge25vbmU6MCwgYWxsOjEsIGF1dG86MiwgY29uY3VycmVudDozLCBhbGxPblN0YXJ0OjQsIHByZWV4aXN0aW5nOjUsIFwidHJ1ZVwiOjEsIFwiZmFsc2VcIjowfSxcblx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUgPSBBbmltYXRpb24uX3Jvb3RGcmFtZXNUaW1lbGluZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpLFxuXHRcdFx0X3Jvb3RUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfbmV4dEdDRnJhbWUgPSAzMCxcblx0XHRcdF9sYXp5UmVuZGVyID0gX2ludGVybmFscy5sYXp5UmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuXHRcdFx0XHRcdHR3ZWVuO1xuXHRcdFx0XHRfbGF6eUxvb2t1cCA9IHt9O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0d2VlbiA9IF9sYXp5VHdlZW5zW2ldO1xuXHRcdFx0XHRcdGlmICh0d2VlbiAmJiB0d2Vlbi5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcih0d2Vlbi5fbGF6eVswXSwgdHdlZW4uX2xhenlbMV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dHdlZW4uX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0X2xhenlUd2VlbnMubGVuZ3RoID0gMDtcblx0XHRcdH07XG5cblx0XHRfcm9vdFRpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLnRpbWU7XG5cdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lID0gX3RpY2tlci5mcmFtZTtcblx0XHRfcm9vdFRpbWVsaW5lLl9hY3RpdmUgPSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9hY3RpdmUgPSB0cnVlO1xuXHRcdHNldFRpbWVvdXQoX2xhenlSZW5kZXIsIDEpOyAvL29uIHNvbWUgbW9iaWxlIGRldmljZXMsIHRoZXJlIGlzbid0IGEgXCJ0aWNrXCIgYmVmb3JlIGNvZGUgcnVucyB3aGljaCBtZWFucyBhbnkgbGF6eSByZW5kZXJzIHdvdWxkbid0IHJ1biBiZWZvcmUgdGhlIG5leHQgb2ZmaWNpYWwgXCJ0aWNrXCIuXG5cblx0XHRBbmltYXRpb24uX3VwZGF0ZVJvb3QgPSBUd2VlbkxpdGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhLCBwO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaWYgY29kZSBpcyBydW4gb3V0c2lkZSBvZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AsIHRoZXJlIG1heSBiZSB0d2VlbnMgcXVldWVkIEFGVEVSIHRoZSBlbmdpbmUgcmVmcmVzaGVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBhbnkgcGVuZGluZyByZW5kZXJzIG9jY3VyIGJlZm9yZSB3ZSByZWZyZXNoIGFnYWluLlxuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3Jvb3RUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIudGltZSAtIF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSkgKiBfcm9vdFRpbWVsaW5lLl90aW1lU2NhbGUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdF9yb290RnJhbWVzVGltZWxpbmUucmVuZGVyKChfdGlja2VyLmZyYW1lIC0gX3Jvb3RGcmFtZXNUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290RnJhbWVzVGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF90aWNrZXIuZnJhbWUgPj0gX25leHRHQ0ZyYW1lKSB7IC8vZHVtcCBnYXJiYWdlIGV2ZXJ5IDEyMCBmcmFtZXMgb3Igd2hhdGV2ZXIgdGhlIHVzZXIgc2V0cyBUd2VlbkxpdGUuYXV0b1NsZWVwIHRvXG5cdFx0XHRcdFx0X25leHRHQ0ZyYW1lID0gX3RpY2tlci5mcmFtZSArIChwYXJzZUludChUd2VlbkxpdGUuYXV0b1NsZWVwLCAxMCkgfHwgMTIwKTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gX3R3ZWVuTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW3BdLnR3ZWVucztcblx0XHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXS5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBfdHdlZW5Mb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaWYgdGhlcmUgYXJlIG5vIG1vcmUgdHdlZW5zIGluIHRoZSByb290IHRpbWVsaW5lcywgb3IgaWYgdGhleSdyZSBhbGwgcGF1c2VkLCBtYWtlIHRoZSBfdGltZXIgc2xlZXAgdG8gcmVkdWNlIGxvYWQgb24gdGhlIENQVSBzbGlnaHRseVxuXHRcdFx0XHRcdHAgPSBfcm9vdFRpbWVsaW5lLl9maXJzdDtcblx0XHRcdFx0XHRpZiAoIXAgfHwgcC5fcGF1c2VkKSBpZiAoVHdlZW5MaXRlLmF1dG9TbGVlcCAmJiAhX3Jvb3RGcmFtZXNUaW1lbGluZS5fZmlyc3QgJiYgX3RpY2tlci5fbGlzdGVuZXJzLnRpY2subGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAocCAmJiBwLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdFx0cCA9IHAuX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXApIHtcblx0XHRcdFx0XHRcdFx0X3RpY2tlci5zbGVlcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdF90aWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgQW5pbWF0aW9uLl91cGRhdGVSb290KTtcblxuXHRcdHZhciBfcmVnaXN0ZXIgPSBmdW5jdGlvbih0YXJnZXQsIHR3ZWVuLCBzY3J1Yikge1xuXHRcdFx0XHR2YXIgaWQgPSB0YXJnZXQuX2dzVHdlZW5JRCwgYSwgaTtcblx0XHRcdFx0aWYgKCFfdHdlZW5Mb29rdXBbaWQgfHwgKHRhcmdldC5fZ3NUd2VlbklEID0gaWQgPSBcInRcIiArIChfdHdlZW5Mb29rdXBOdW0rKykpXSkge1xuXHRcdFx0XHRcdF90d2Vlbkxvb2t1cFtpZF0gPSB7dGFyZ2V0OnRhcmdldCwgdHdlZW5zOltdfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHdlZW4pIHtcblx0XHRcdFx0XHRhID0gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHRcdFx0YVsoaSA9IGEubGVuZ3RoKV0gPSB0d2Vlbjtcblx0XHRcdFx0XHRpZiAoc2NydWIpIHtcblx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX3R3ZWVuTG9va3VwW2lkXS50d2VlbnM7XG5cdFx0XHR9LFxuXHRcdFx0X29uT3ZlcndyaXRlID0gZnVuY3Rpb24ob3ZlcndyaXR0ZW5Ud2Vlbiwgb3ZlcndyaXRpbmdUd2VlbiwgdGFyZ2V0LCBraWxsZWRQcm9wcykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IG92ZXJ3cml0dGVuVHdlZW4udmFycy5vbk92ZXJ3cml0ZSwgcjEsIHIyO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIxID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jID0gVHdlZW5MaXRlLm9uT3ZlcndyaXRlO1xuXHRcdFx0XHRpZiAoZnVuYykge1xuXHRcdFx0XHRcdHIyID0gZnVuYyhvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKHIxICE9PSBmYWxzZSAmJiByMiAhPT0gZmFsc2UpO1xuXHRcdFx0fSxcblx0XHRcdF9hcHBseU92ZXJ3cml0ZSA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHByb3BzLCBtb2RlLCBzaWJsaW5ncykge1xuXHRcdFx0XHR2YXIgaSwgY2hhbmdlZCwgY3VyVHdlZW4sIGw7XG5cdFx0XHRcdGlmIChtb2RlID09PSAxIHx8IG1vZGUgPj0gNCkge1xuXHRcdFx0XHRcdGwgPSBzaWJsaW5ncy5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSAhPT0gdHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjdXJUd2Vlbi5fZ2MpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2tpbGwobnVsbCwgdGFyZ2V0LCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtb2RlID09PSA1KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL05PVEU6IEFkZCAwLjAwMDAwMDAwMDEgdG8gb3ZlcmNvbWUgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIHRoYXQgY2FuIGNhdXNlIHRoZSBzdGFydFRpbWUgdG8gYmUgVkVSWSBzbGlnaHRseSBvZmYgKHdoZW4gYSB0d2VlbidzIHRpbWUoKSBpcyBzZXQgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdHZhciBzdGFydFRpbWUgPSB0d2Vlbi5fc3RhcnRUaW1lICsgX3RpbnlOdW0sXG5cdFx0XHRcdFx0b3ZlcmxhcHMgPSBbXSxcblx0XHRcdFx0XHRvQ291bnQgPSAwLFxuXHRcdFx0XHRcdHplcm9EdXIgPSAodHdlZW4uX2R1cmF0aW9uID09PSAwKSxcblx0XHRcdFx0XHRnbG9iYWxTdGFydDtcblx0XHRcdFx0aSA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKChjdXJUd2VlbiA9IHNpYmxpbmdzW2ldKSA9PT0gdHdlZW4gfHwgY3VyVHdlZW4uX2djIHx8IGN1clR3ZWVuLl9wYXVzZWQpIHtcblx0XHRcdFx0XHRcdC8vaWdub3JlXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fdGltZWxpbmUgIT09IHR3ZWVuLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdFx0Z2xvYmFsU3RhcnQgPSBnbG9iYWxTdGFydCB8fCBfY2hlY2tPdmVybGFwKHR3ZWVuLCAwLCB6ZXJvRHVyKTtcblx0XHRcdFx0XHRcdGlmIChfY2hlY2tPdmVybGFwKGN1clR3ZWVuLCBnbG9iYWxTdGFydCwgemVyb0R1cikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjdXJUd2Vlbi5fc3RhcnRUaW1lIDw9IHN0YXJ0VGltZSkgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgKyBjdXJUd2Vlbi50b3RhbER1cmF0aW9uKCkgLyBjdXJUd2Vlbi5fdGltZVNjYWxlID4gc3RhcnRUaW1lKSBpZiAoISgoemVyb0R1ciB8fCAhY3VyVHdlZW4uX2luaXR0ZWQpICYmIHN0YXJ0VGltZSAtIGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gMC4wMDAwMDAwMDAyKSkge1xuXHRcdFx0XHRcdFx0b3ZlcmxhcHNbb0NvdW50KytdID0gY3VyVHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSA9IG9Db3VudDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y3VyVHdlZW4gPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRpZiAobW9kZSA9PT0gMikgaWYgKGN1clR3ZWVuLl9raWxsKHByb3BzLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtb2RlICE9PSAyIHx8ICghY3VyVHdlZW4uX2ZpcnN0UFQgJiYgY3VyVHdlZW4uX2luaXR0ZWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9kZSAhPT0gMiAmJiAhX29uT3ZlcndyaXRlKGN1clR3ZWVuLCB0d2VlbikpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY3VyVHdlZW4uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKSkgeyAvL2lmIGFsbCBwcm9wZXJ0eSB0d2VlbnMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0fSxcblx0XHRcdF9jaGVja092ZXJsYXAgPSBmdW5jdGlvbih0d2VlbiwgcmVmZXJlbmNlLCB6ZXJvRHVyKSB7XG5cdFx0XHRcdHZhciB0bCA9IHR3ZWVuLl90aW1lbGluZSxcblx0XHRcdFx0XHR0cyA9IHRsLl90aW1lU2NhbGUsXG5cdFx0XHRcdFx0dCA9IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdHdoaWxlICh0bC5fdGltZWxpbmUpIHtcblx0XHRcdFx0XHR0ICs9IHRsLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0dHMgKj0gdGwuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHRpZiAodGwuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIC0xMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHQgLz0gdHM7XG5cdFx0XHRcdHJldHVybiAodCA+IHJlZmVyZW5jZSkgPyB0IC0gcmVmZXJlbmNlIDogKCh6ZXJvRHVyICYmIHQgPT09IHJlZmVyZW5jZSkgfHwgKCF0d2Vlbi5faW5pdHRlZCAmJiB0IC0gcmVmZXJlbmNlIDwgMiAqIF90aW55TnVtKSkgPyBfdGlueU51bSA6ICgodCArPSB0d2Vlbi50b3RhbER1cmF0aW9uKCkgLyB0d2Vlbi5fdGltZVNjYWxlIC8gdHMpID4gcmVmZXJlbmNlICsgX3RpbnlOdW0pID8gMCA6IHQgLSByZWZlcmVuY2UgLSBfdGlueU51bTtcblx0XHRcdH07XG5cblxuLy8tLS0tIFR3ZWVuTGl0ZSBpbnN0YW5jZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLl9pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdiA9IHRoaXMudmFycyxcblx0XHRcdFx0b3AgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzLFxuXHRcdFx0XHRkdXIgPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0aW1tZWRpYXRlID0gISF2LmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0ZWFzZSA9IHYuZWFzZSxcblx0XHRcdFx0aSwgaW5pdFBsdWdpbnMsIHB0LCBwLCBzdGFydFZhcnMsIGw7XG5cdFx0XHRpZiAodi5zdGFydEF0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zdGFydEF0KSB7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvL2lmIHdlJ3ZlIHJ1biBhIHN0YXJ0QXQgcHJldmlvdXNseSAod2hlbiB0aGUgdHdlZW4gaW5zdGFudGlhdGVkKSwgd2Ugc2hvdWxkIHJldmVydCBpdCBzbyB0aGF0IHRoZSB2YWx1ZXMgcmUtaW5zdGFudGlhdGUgY29ycmVjdGx5IHBhcnRpY3VsYXJseSBmb3IgcmVsYXRpdmUgdHdlZW5zLiBXaXRob3V0IHRoaXMsIGEgVHdlZW5MaXRlLmZyb21UbyhvYmosIDEsIHt4OlwiKz0xMDBcIn0sIHt4OlwiLT0xMDBcIn0pLCBmb3IgZXhhbXBsZSwgd291bGQgYWN0dWFsbHkganVtcCB0byArPTIwMCBiZWNhdXNlIHRoZSBzdGFydEF0IHdvdWxkIHJ1biB0d2ljZSwgZG91YmxpbmcgdGhlIHJlbGF0aXZlIGNoYW5nZS5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LmtpbGwoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydFZhcnMgPSB7fTtcblx0XHRcdFx0Zm9yIChwIGluIHYuc3RhcnRBdCkgeyAvL2NvcHkgdGhlIHByb3BlcnRpZXMvdmFsdWVzIGludG8gYSBuZXcgb2JqZWN0IHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgdmFyIHRvID0ge3g6MH0sIGZyb20gPSB7eDo1MDB9OyB0aW1lbGluZS5mcm9tVG8oZSwgMSwgZnJvbSwgdG8pLmZyb21UbyhlLCAxLCB0bywgZnJvbSk7XG5cdFx0XHRcdFx0c3RhcnRWYXJzW3BdID0gdi5zdGFydEF0W3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycy5vdmVyd3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhcnRWYXJzLmltbWVkaWF0ZVJlbmRlciA9IHRydWU7XG5cdFx0XHRcdHN0YXJ0VmFycy5sYXp5ID0gKGltbWVkaWF0ZSAmJiB2LmxhenkgIT09IGZhbHNlKTtcblx0XHRcdFx0c3RhcnRWYXJzLnN0YXJ0QXQgPSBzdGFydFZhcnMuZGVsYXkgPSBudWxsOyAvL25vIG5lc3Rpbmcgb2Ygc3RhcnRBdCBvYmplY3RzIGFsbG93ZWQgKG90aGVyd2lzZSBpdCBjb3VsZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wKS5cblx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgc3RhcnRWYXJzKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lTGl0ZS9NYXggaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2UgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGluIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIGxpa2UgZnJvbSgpKS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGR1ciAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lTGl0ZSBvciBUaW1lbGluZU1heCwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodi5ydW5CYWNrd2FyZHMgJiYgZHVyICE9PSAwKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgIT09IDApIHsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblx0XHRcdFx0XHRcdGltbWVkaWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2KSB7IC8vY29weSBwcm9wcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgc2tpcCBhbnkgcmVzZXJ2ZWQgcHJvcHMsIG90aGVyd2lzZSBvbkNvbXBsZXRlIG9yIG9uVXBkYXRlIG9yIG9uU3RhcnQgY291bGQgZmlyZS4gV2Ugc2hvdWxkLCBob3dldmVyLCBwZXJtaXQgYXV0b0NTUyB0byBnbyB0aHJvdWdoLlxuXHRcdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSB8fCBwID09PSBcImF1dG9DU1NcIikge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHZbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0Lm92ZXJ3cml0ZSA9IDA7XG5cdFx0XHRcdFx0cHQuZGF0YSA9IFwiaXNGcm9tU3RhcnRcIjsgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0cHQubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdFx0cHQuaW1tZWRpYXRlUmVuZGVyID0gaW1tZWRpYXRlOyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgcHQpO1xuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9pbml0KCk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoZmFsc2UpOyAvL25vIG5lZWQgdG8gaGF2ZSB0aGUgdHdlZW4gcmVuZGVyIG9uIHRoZSBuZXh0IGN5Y2xlLiBEaXNhYmxlIGl0IGJlY2F1c2Ugd2UnbGwgYWx3YXlzIG1hbnVhbGx5IGNvbnRyb2wgdGhlIHJlbmRlcnMgb2YgdGhlIF9zdGFydEF0IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZSA9ICghZWFzZSkgPyBUd2VlbkxpdGUuZGVmYXVsdEVhc2UgOiAoZWFzZSBpbnN0YW5jZW9mIEVhc2UpID8gZWFzZSA6ICh0eXBlb2YoZWFzZSkgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgRWFzZShlYXNlLCB2LmVhc2VQYXJhbXMpIDogX2Vhc2VNYXBbZWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0aWYgKHYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5ICYmIGVhc2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlLmNvbmZpZy5hcHBseShlYXNlLCB2LmVhc2VQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZVR5cGUgPSB0aGlzLl9lYXNlLl90eXBlO1xuXHRcdFx0dGhpcy5fZWFzZVBvd2VyID0gdGhpcy5fZWFzZS5fcG93ZXI7XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0bCA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9pbml0UHJvcHMoIHRoaXMuX3RhcmdldHNbaV0sICh0aGlzLl9wcm9wTG9va3VwW2ldID0ge30pLCB0aGlzLl9zaWJsaW5nc1tpXSwgKG9wID8gb3BbaV0gOiBudWxsKSwgaSkgKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbml0UGx1Z2lucyA9IHRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCwgdGhpcy5fcHJvcExvb2t1cCwgdGhpcy5fc2libGluZ3MsIG9wLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluaXRQbHVnaW5zKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkluaXRBbGxQcm9wc1wiLCB0aGlzKTsgLy9yZW9yZGVycyB0aGUgYXJyYXkgaW4gb3JkZXIgb2YgcHJpb3JpdHkuIFVzZXMgYSBzdGF0aWMgVHdlZW5QbHVnaW4gbWV0aG9kIGluIG9yZGVyIHRvIG1pbmltaXplIGZpbGUgc2l6ZSBpbiBUd2VlbkxpdGVcblx0XHRcdH1cblx0XHRcdGlmIChvcCkgaWYgKCF0aGlzLl9maXJzdFBUKSBpZiAodHlwZW9mKHRoaXMudGFyZ2V0KSAhPT0gXCJmdW5jdGlvblwiKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi4gSWYgdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCBpdCdzIHByb2JhYmx5IGEgZGVsYXllZENhbGwgc28gbGV0IGl0IGxpdmUuXG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmICh2LnJ1bkJhY2t3YXJkcykge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHB0LnMgKz0gcHQuYztcblx0XHRcdFx0XHRwdC5jID0gLXB0LmM7XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb25VcGRhdGUgPSB2Lm9uVXBkYXRlO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHAuX2luaXRQcm9wcyA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMsIGluZGV4KSB7XG5cdFx0XHR2YXIgcCwgaSwgaW5pdFBsdWdpbnMsIHBsdWdpbiwgcHQsIHY7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdKSB7XG5cdFx0XHRcdF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy52YXJzLmNzcykgaWYgKHRhcmdldC5zdHlsZSkgaWYgKHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldC5ub2RlVHlwZSkgaWYgKF9wbHVnaW5zLmNzcykgaWYgKHRoaXMudmFycy5hdXRvQ1NTICE9PSBmYWxzZSkgeyAvL2l0J3Mgc28gY29tbW9uIHRvIHVzZSBUd2VlbkxpdGUvTWF4IHRvIGFuaW1hdGUgdGhlIGNzcyBvZiBET00gZWxlbWVudHMsIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgdGhhdCdzIHdoYXQgaXMgaW50ZW5kZWQgKGEgY29udmVuaWVuY2Ugc28gdGhhdCB1c2VycyBkb24ndCBoYXZlIHRvIHdyYXAgdGhpbmdzIGluIGNzczp7fSwgYWx0aG91Z2ggd2Ugc3RpbGwgcmVjb21tZW5kIGl0IGZvciBhIHNsaWdodCBwZXJmb3JtYW5jZSBib29zdCBhbmQgYmV0dGVyIHNwZWNpZmljaXR5KS4gTm90ZTogd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBvbiB0aGUgd2luZG93IGluc2lkZSBhbiBpZnJhbWUuXG5cdFx0XHRcdF9hdXRvQ1NTKHRoaXMudmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB0aGlzLnZhcnMpIHtcblx0XHRcdFx0diA9IHRoaXMudmFyc1twXTtcblx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0aWYgKHYpIGlmICgodiBpbnN0YW5jZW9mIEFycmF5KSB8fCAodi5wdXNoICYmIF9pc0FycmF5KHYpKSkgaWYgKHYuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzW3BdID0gdiA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModiwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twXSgpKS5fb25Jbml0VHdlZW4odGFyZ2V0LCB0aGlzLnZhcnNbcF0sIHRoaXMsIGluZGV4KSkge1xuXG5cdFx0XHRcdFx0Ly90IC0gdGFyZ2V0IFx0XHRbb2JqZWN0XVxuXHRcdFx0XHRcdC8vcCAtIHByb3BlcnR5IFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcyAtIHN0YXJ0XHRcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2MgLSBjaGFuZ2VcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2YgLSBpc0Z1bmN0aW9uXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL24gLSBuYW1lXHRcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3BnIC0gaXNQbHVnaW4gXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL3ByIC0gcHJpb3JpdHlcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL20gLSBtb2QgICAgICAgICAgIFtmdW5jdGlvbiB8IDBdXG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6cGx1Z2luLCBwOlwic2V0UmF0aW9cIiwgczowLCBjOjEsIGY6MSwgbjpwLCBwZzoxLCBwcjpwbHVnaW4uX3ByaW9yaXR5LCBtOjB9O1xuXHRcdFx0XHRcdGkgPSBwbHVnaW4uX292ZXJ3cml0ZVByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHByb3BMb29rdXBbcGx1Z2luLl9vdmVyd3JpdGVQcm9wc1tpXV0gPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9wcmlvcml0eSB8fCBwbHVnaW4uX29uSW5pdEFsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX29uRGlzYWJsZSB8fCBwbHVnaW4uX29uRW5hYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXBbcF0gPSBfYWRkUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBcImdldFwiLCB2LCBwLCAwLCBudWxsLCB0aGlzLnZhcnMuc3RyaW5nRmlsdGVyLCBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG92ZXJ3cml0dGVuUHJvcHMpIGlmICh0aGlzLl9raWxsKG92ZXJ3cml0dGVuUHJvcHMsIHRhcmdldCkpIHsgLy9hbm90aGVyIHR3ZWVuIG1heSBoYXZlIHRyaWVkIHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHdlZW4gYmVmb3JlIGluaXQoKSB3YXMgY2FsbGVkIChsaWtlIGlmIHR3byB0d2VlbnMgc3RhcnQgYXQgdGhlIHNhbWUgdGltZSwgdGhlIG9uZSBjcmVhdGVkIHNlY29uZCB3aWxsIHJ1biBmaXJzdClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzLCBpbmRleCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fb3ZlcndyaXRlID4gMSkgaWYgKHRoaXMuX2ZpcnN0UFQpIGlmIChzaWJsaW5ncy5sZW5ndGggPiAxKSBpZiAoX2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgcHJvcExvb2t1cCwgdGhpcy5fb3ZlcndyaXRlLCBzaWJsaW5ncykpIHtcblx0XHRcdFx0dGhpcy5fa2lsbChwcm9wTG9va3VwLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMsIGluZGV4KTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9maXJzdFBUKSBpZiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyBkb24ndCBsYXp5IHJlbmRlciBieSBkZWZhdWx0OyBldmVyeXRoaW5nIGVsc2UgZG9lcy5cblx0XHRcdFx0X2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbml0UGx1Z2lucztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24gLSAwLjAwMDAwMDEgJiYgdGltZSA+PSAwKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkICkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAoZm9yY2UgfHwgdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKTsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lIDwgMCB8fCAodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgIShwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSA9PT0gXCJpc1BhdXNlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkKSB7IC8vaWYgd2UgcmVuZGVyIHRoZSB2ZXJ5IGJlZ2lubmluZyAodGltZSA9PSAwKSBvZiBhIGZyb21UbygpLCB3ZSBtdXN0IGZvcmNlIHRoZSByZW5kZXIgKG5vcm1hbCB0d2VlbnMgd291bGRuJ3QgbmVlZCB0byByZW5kZXIgYXQgYSB0aW1lIG9mIDAgd2hlbiB0aGUgcHJldlRpbWUgd2FzIGFsc28gMCkuIFRoaXMgaXMgYWxzbyBtYW5kYXRvcnkgdG8gbWFrZSBzdXJlIG92ZXJ3cml0aW5nIGtpY2tzIGluIGltbWVkaWF0ZWx5LlxuXHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRpbWU7XG5cblx0XHRcdFx0aWYgKHRoaXMuX2Vhc2VUeXBlKSB7XG5cdFx0XHRcdFx0dmFyIHIgPSB0aW1lIC8gZHVyYXRpb24sIHR5cGUgPSB0aGlzLl9lYXNlVHlwZSwgcG93ID0gdGhpcy5fZWFzZVBvd2VyO1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxIHx8ICh0eXBlID09PSAzICYmIHIgPj0gMC41KSkge1xuXHRcdFx0XHRcdFx0ciA9IDEgLSByO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocG93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRyICo9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDIpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSA0KSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogciAqIHI7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IDIpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGltZSAvIGR1cmF0aW9uIDwgMC41KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gciAvIDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSAxIC0gKHIgLyAyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl90aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcHJldlJhd1ByZXZUaW1lO1xuXHRcdFx0XHRcdF9sYXp5VHdlZW5zLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5fbGF6eSA9IFt0aW1lLCBzdXBwcmVzc0V2ZW50c107XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vX2Vhc2UgaXMgaW5pdGlhbGx5IHNldCB0byBkZWZhdWx0RWFzZSwgc28gbm93IHRoYXQgaW5pdCgpIGhhcyBydW4sIF9lYXNlIGlzIHNldCBwcm9wZXJseSBhbmQgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgcmF0aW8uIE92ZXJhbGwgdGhpcyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjb25kaXRpb25hbCBsb2dpYyBlYXJsaWVyIGluIHRoZSBtZXRob2QgdG8gYXZvaWQgaGF2aW5nIHRvIHNldCByYXRpbyB0d2ljZSBiZWNhdXNlIHdlIG9ubHkgaW5pdCgpIG9uY2UgYnV0IHJlbmRlclRpbWUoKSBnZXRzIGNhbGxlZCBWRVJZIGZyZXF1ZW50bHkuXG5cdFx0XHRcdGlmICh0aGlzLl90aW1lICYmICFpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQpIHtcblx0XHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5nZXRSYXRpbygodGhpcy5fdGltZSA9PT0gMCkgPyAwIDogMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9sYXp5ICE9PSBmYWxzZSkgeyAvL2luIGNhc2UgYSBsYXp5IHJlbmRlciBpcyBwZW5kaW5nLCB3ZSBzaG91bGQgZmx1c2ggaXQgYmVjYXVzZSB0aGUgbmV3IHJlbmRlciBpcyBvY2N1cnJpbmcgbm93IChpbWFnaW5lIGEgbGF6eSB0d2VlbiBpbnN0YW50aWF0aW5nIGFuZCB0aGVuIGltbWVkaWF0ZWx5IHRoZSB1c2VyIGNhbGxzIHR3ZWVuLnNlZWsodHdlZW4uZHVyYXRpb24oKSksIHNraXBwaW5nIHRvIHRoZSBlbmQgLSB0aGUgZW5kIHJlbmRlciB3b3VsZCBiZSBmb3JjZWQsIGFuZCB0aGVuIGlmIHdlIGRpZG4ndCBmbHVzaCB0aGUgbGF6eSByZW5kZXIsIGl0J2QgZmlyZSBBRlRFUiB0aGUgc2VlaygpLCByZW5kZXJpbmcgaXQgYXQgdGhlIHdyb25nIHRpbWUuXG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fYWN0aXZlKSBpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl90aW1lICE9PSBwcmV2VGltZSAmJiB0aW1lID49IDApIHtcblx0XHRcdFx0dGhpcy5fYWN0aXZlID0gdHJ1ZTsgIC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7IC8vbm90ZTogZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIHR1Y2sgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbnNpZGUgbGVzcyB0cmF2ZWxlZCBhcmVhcyAobW9zdCB0d2VlbnMgZG9uJ3QgaGF2ZSBhbiBvblVwZGF0ZSkuIFdlJ2QganVzdCBoYXZlIGl0IGF0IHRoZSBlbmQgYmVmb3JlIHRoZSBvbkNvbXBsZXRlLCBidXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdXBkYXRlZCBiZWZvcmUgYW55IG9uVXBkYXRlIGlzIGNhbGxlZCwgc28gd2UgQUxTTyBwdXQgaXQgaGVyZSBhbmQgdGhlbiBpZiBpdCdzIG5vdCBjYWxsZWQsIHdlIGRvIHNvIGxhdGVyIG5lYXIgdGhlIG9uQ29tcGxldGUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKHRoaXMuX3RpbWUgIT09IHByZXZUaW1lIHx8IGlzQ29tcGxldGUgfHwgZm9yY2UpIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fZ2MgfHwgZm9yY2UpIHsgLy9jaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGltZSAhPT0gLTAuMDAwMSkgeyAvLy0wLjAwMDEgaXMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgd2UgdXNlIHdoZW4gbG9vcGluZyBiYWNrIHRvIHRoZSBiZWdpbm5pbmcgb2YgYSByZXBlYXRlZCBUaW1lbGluZU1heCwgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRuJ3QgcmVuZGVyIHRoZSBfc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXQsIG92ZXJ3cml0aW5nVHdlZW4pIHtcblx0XHRcdGlmICh2YXJzID09PSBcImFsbFwiKSB7XG5cdFx0XHRcdHZhcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhcnMgPT0gbnVsbCkgaWYgKHRhcmdldCA9PSBudWxsIHx8IHRhcmdldCA9PT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/ICh0YXJnZXQgfHwgdGhpcy5fdGFyZ2V0cyB8fCB0aGlzLnRhcmdldCkgOiBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cdFx0XHR2YXIgc2ltdWx0YW5lb3VzT3ZlcndyaXRlID0gKG92ZXJ3cml0aW5nVHdlZW4gJiYgdGhpcy5fdGltZSAmJiBvdmVyd3JpdGluZ1R3ZWVuLl9zdGFydFRpbWUgPT09IHRoaXMuX3N0YXJ0VGltZSAmJiB0aGlzLl90aW1lbGluZSA9PT0gb3ZlcndyaXRpbmdUd2Vlbi5fdGltZWxpbmUpLFxuXHRcdFx0XHRpLCBvdmVyd3JpdHRlblByb3BzLCBwLCBwdCwgcHJvcExvb2t1cCwgY2hhbmdlZCwga2lsbFByb3BzLCByZWNvcmQsIGtpbGxlZDtcblx0XHRcdGlmICgoX2lzQXJyYXkodGFyZ2V0KSB8fCBfaXNTZWxlY3Rvcih0YXJnZXQpKSAmJiB0eXBlb2YodGFyZ2V0WzBdKSAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRpID0gdGFyZ2V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2tpbGwodmFycywgdGFyZ2V0W2ldLCBvdmVyd3JpdGluZ1R3ZWVuKSkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fdGFyZ2V0cykge1xuXHRcdFx0XHRcdGkgPSB0aGlzLl90YXJnZXRzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQgPT09IHRoaXMuX3RhcmdldHNbaV0pIHtcblx0XHRcdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXBbaV0gfHwge307XG5cdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRvdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnMgPyB0aGlzLl9vdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9IDogXCJhbGxcIjtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy50YXJnZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJvcExvb2t1cCA9IHRoaXMuX3Byb3BMb29rdXA7XG5cdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocHJvcExvb2t1cCkge1xuXHRcdFx0XHRcdGtpbGxQcm9wcyA9IHZhcnMgfHwgcHJvcExvb2t1cDtcblx0XHRcdFx0XHRyZWNvcmQgPSAodmFycyAhPT0gb3ZlcndyaXR0ZW5Qcm9wcyAmJiBvdmVyd3JpdHRlblByb3BzICE9PSBcImFsbFwiICYmIHZhcnMgIT09IHByb3BMb29rdXAgJiYgKHR5cGVvZih2YXJzKSAhPT0gXCJvYmplY3RcIiB8fCAhdmFycy5fdGVtcEtpbGwpKTsgLy9fdGVtcEtpbGwgaXMgYSBzdXBlci1zZWNyZXQgd2F5IHRvIGRlbGV0ZSBhIHBhcnRpY3VsYXIgdHdlZW5pbmcgcHJvcGVydHkgYnV0IE5PVCBoYXZlIGl0IHJlbWVtYmVyZWQgYXMgYW4gb2ZmaWNpYWwgb3ZlcndyaXR0ZW4gcHJvcGVydHkgKGxpa2UgaW4gQmV6aWVyUGx1Z2luKVxuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGluZ1R3ZWVuICYmIChUd2VlbkxpdGUub25PdmVyd3JpdGUgfHwgdGhpcy52YXJzLm9uT3ZlcndyaXRlKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcExvb2t1cFtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgha2lsbGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRraWxsZWQgPSBbXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0a2lsbGVkLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICgoa2lsbGVkIHx8ICF2YXJzKSAmJiAhX29uT3ZlcndyaXRlKHRoaXMsIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkKSkgeyAvL2lmIHRoZSBvbk92ZXJ3cml0ZSByZXR1cm5lZCBmYWxzZSwgdGhhdCBtZWFucyB0aGUgdXNlciB3YW50cyB0byBvdmVycmlkZSB0aGUgb3ZlcndyaXRpbmcgKGNhbmNlbCBpdCkuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHAgaW4ga2lsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpZiAoKHB0ID0gcHJvcExvb2t1cFtwXSkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNpbXVsdGFuZW91c092ZXJ3cml0ZSkgeyAvL2lmIGFub3RoZXIgdHdlZW4gb3ZlcndyaXRlcyB0aGlzIG9uZSBhbmQgdGhleSBib3RoIHN0YXJ0IGF0IGV4YWN0bHkgdGhlIHNhbWUgdGltZSwgeWV0IHRoaXMgdHdlZW4gaGFzIGFscmVhZHkgcmVuZGVyZWQgb25jZSAoZm9yIGV4YW1wbGUsIGF0IDAuMDAxKSBiZWNhdXNlIGl0J3MgZmlyc3QgaW4gdGhlIHF1ZXVlLCB3ZSBzaG91bGQgcmV2ZXJ0IHRoZSB2YWx1ZXMgdG8gd2hlcmUgdGhleSB3ZXJlIGF0IDAgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZW4ndCBjb250YW1pbmF0ZWQgb24gdGhlIG92ZXJ3cml0aW5nIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LnMpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQucztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHB0LnBnICYmIHB0LnQuX2tpbGwoa2lsbFByb3BzKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlOyAvL3NvbWUgcGx1Z2lucyBuZWVkIHRvIGJlIG5vdGlmaWVkIHNvIHRoZXkgY2FuIHBlcmZvcm0gY2xlYW51cCB0YXNrcyBmaXJzdFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICghcHQucGcgfHwgcHQudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRwdC5fbmV4dCA9IHB0Ll9wcmV2ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgcHJvcExvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyZWNvcmQpIHtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wc1twXSA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghdGhpcy5fZmlyc3RQVCAmJiB0aGlzLl9pbml0dGVkKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdHAuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIHtcblx0XHRcdFx0VHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2ZpcnN0UFQgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gbnVsbDtcblx0XHRcdHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQgPSB0aGlzLl9hY3RpdmUgPSB0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gKHRoaXMuX3RhcmdldHMpID8ge30gOiBbXTtcblx0XHRcdEFuaW1hdGlvbi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cdFx0XHRcdHRoaXMucmVuZGVyKE1hdGgubWluKDAsIC10aGlzLl9kZWxheSkpOyAvL2luIGNhc2UgZGVsYXkgaXMgbmVnYXRpdmUuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fZW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKSB7XG5cdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZW5hYmxlZCAmJiB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0cyA9IHRoaXMuX3RhcmdldHMsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zaWJsaW5nc1tpXSA9IF9yZWdpc3Rlcih0YXJnZXRzW2ldLCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBfcmVnaXN0ZXIodGhpcy50YXJnZXQsIHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcywgZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpO1xuXHRcdFx0aWYgKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQpIGlmICh0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdHJldHVybiBUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoKGVuYWJsZWQgPyBcIl9vbkVuYWJsZVwiIDogXCJfb25EaXNhYmxlXCIpLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cbi8vLS0tLVR3ZWVuTGl0ZSBzdGF0aWMgbWV0aG9kcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0VHdlZW5MaXRlLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycykge1xuXHRcdFx0dmFycy5ydW5CYWNrd2FyZHMgPSB0cnVlO1xuXHRcdFx0dmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIGR1cmF0aW9uLCB0b1ZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwgPSBmdW5jdGlvbihkZWxheSwgY2FsbGJhY2ssIHBhcmFtcywgc2NvcGUsIHVzZUZyYW1lcykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUoY2FsbGJhY2ssIDAsIHtkZWxheTpkZWxheSwgb25Db21wbGV0ZTpjYWxsYmFjaywgb25Db21wbGV0ZVBhcmFtczpwYXJhbXMsIGNhbGxiYWNrU2NvcGU6c2NvcGUsIG9uUmV2ZXJzZUNvbXBsZXRlOmNhbGxiYWNrLCBvblJldmVyc2VDb21wbGV0ZVBhcmFtczpwYXJhbXMsIGltbWVkaWF0ZVJlbmRlcjpmYWxzZSwgbGF6eTpmYWxzZSwgdXNlRnJhbWVzOnVzZUZyYW1lcywgb3ZlcndyaXRlOjB9KTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBvbmx5QWN0aXZlKSB7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG5cdFx0XHR0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIGksIGEsIGosIHQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdGEgPSBbXTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0YSA9IGEuY29uY2F0KFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZih0YXJnZXRbaV0sIG9ubHlBY3RpdmUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdC8vbm93IGdldCByaWQgb2YgYW55IGR1cGxpY2F0ZXMgKHR3ZWVucyBvZiBhcnJheXMgb2Ygb2JqZWN0cyBjb3VsZCBjYXVzZSBkdXBsaWNhdGVzKVxuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHR0ID0gYVtpXTtcblx0XHRcdFx0XHRqID0gaTtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0ID09PSBhW2pdKSB7XG5cdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YSA9IF9yZWdpc3Rlcih0YXJnZXQpLmNvbmNhdCgpO1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChhW2ldLl9nYyB8fCAob25seUFjdGl2ZSAmJiAhYVtpXS5pc0FjdGl2ZSgpKSkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5raWxsRGVsYXllZENhbGxzVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUsIHZhcnMpIHtcblx0XHRcdGlmICh0eXBlb2Yob25seUFjdGl2ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFycyA9IG9ubHlBY3RpdmU7IC8vZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChiZWZvcmUgXCJvbmx5QWN0aXZlXCIgcGFyYW1ldGVyIHdhcyBpbnNlcnRlZClcblx0XHRcdFx0b25seUFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCBvbmx5QWN0aXZlKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGFbaV0uX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuUGx1Z2luICAgKGNvdWxkIGVhc2lseSBiZSBzcGxpdCBvdXQgYXMgYSBzZXBhcmF0ZSBmaWxlL2NsYXNzLCBidXQgaW5jbHVkZWQgZm9yIGVhc2Ugb2YgdXNlIChzbyB0aGF0IHBlb3BsZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW5vdGhlciBzY3JpcHQgY2FsbCBiZWZvcmUgbG9hZGluZyBwbHVnaW5zIHdoaWNoIGlzIGVhc3kgdG8gZm9yZ2V0KVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuUGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLCBmdW5jdGlvbihwcm9wcywgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IChwcm9wcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcE5hbWUgPSB0aGlzLl9vdmVyd3JpdGVQcm9wc1swXTtcblx0XHRcdFx0XHR0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0cCA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRUd2VlblBsdWdpbi52ZXJzaW9uID0gXCIxLjE5LjBcIjtcblx0XHRUd2VlblBsdWdpbi5BUEkgPSAyO1xuXHRcdHAuX2ZpcnN0UFQgPSBudWxsO1xuXHRcdHAuX2FkZFR3ZWVuID0gX2FkZFByb3BUd2Vlbjtcblx0XHRwLnNldFJhdGlvID0gX3NldFJhdGlvO1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1dICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbcHQubl0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fbW9kID0gcC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdHZhbCA9IGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gfHwgKHB0Lm4gIT0gbnVsbCAmJiBsb29rdXBbIHB0Lm4uc3BsaXQodGhpcy5fcHJvcE5hbWUgKyBcIl9cIikuam9pbihcIlwiKSBdKTtcblx0XHRcdFx0aWYgKHZhbCAmJiB0eXBlb2YodmFsKSA9PT0gXCJmdW5jdGlvblwiKSB7IC8vc29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZlcnkgcGx1Z2luLXNwZWNpZmljIGFkZCBhIHByZWZpeCBuYW1lZCBhZnRlciB0aGUgX3Byb3BOYW1lIHBsdXMgYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBpZ25vcmUgdGhhdCBleHRyYSBzdHVmZiBoZXJlLlxuXHRcdFx0XHRcdGlmIChwdC5mID09PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50Ll9hcHBseVBULm0gPSB2YWw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0Lm0gPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHR3ZWVuKSB7XG5cdFx0XHR2YXIgcHQgPSB0d2Vlbi5fZmlyc3RQVCxcblx0XHRcdFx0Y2hhbmdlZCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dDtcblx0XHRcdGlmICh0eXBlID09PSBcIl9vbkluaXRBbGxQcm9wc1wiKSB7XG5cdFx0XHRcdC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIHJlbmRlciBlYXJsaWVyL2xhdGVyIHRoYW4gb3RoZXJzLCBsaWtlIE1vdGlvbkJsdXJQbHVnaW4gYXBwbGllcyBpdHMgZWZmZWN0cyBhZnRlciBhbGwgeC95L2FscGhhIHR3ZWVucyBoYXZlIHJlbmRlcmVkIG9uIGVhY2ggZnJhbWUuXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LnBnKSBpZiAodHlwZW9mKHB0LnRbdHlwZV0pID09PSBcImZ1bmN0aW9uXCIpIGlmIChwdC50W3R5cGVdKCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlID0gZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIGkgPSBwbHVnaW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGx1Z2luc1tpXS5BUEkgPT09IFR3ZWVuUGx1Z2luLkFQSSkge1xuXHRcdFx0XHRcdF9wbHVnaW5zWyhuZXcgcGx1Z2luc1tpXSgpKS5fcHJvcE5hbWVdID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8vcHJvdmlkZXMgYSBtb3JlIGNvbmNpc2Ugd2F5IHRvIGRlZmluZSBwbHVnaW5zIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYmVzaWRlcyBUd2VlblBsdWdpbiBhbmQgVHdlZW5MaXRlLCB3cmFwcGluZyBjb21tb24gYm9pbGVycGxhdGUgc3R1ZmYgaW50byBvbmUgZnVuY3Rpb24gKGFkZGVkIGluIDEuOS4wKS4gWW91IGRvbid0IE5FRUQgdG8gdXNlIHRoaXMgdG8gZGVmaW5lIGEgcGx1Z2luIC0gdGhlIG9sZCB3YXkgc3RpbGwgd29ya3MgYW5kIGNhbiBiZSB1c2VmdWwgaW4gY2VydGFpbiAocmFyZSkgc2l0dWF0aW9ucy5cblx0XHRfZ3NEZWZpbmUucGx1Z2luID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHRpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnByb3BOYW1lIHx8ICFjb25maWcuaW5pdCB8fCAhY29uZmlnLkFQSSkgeyB0aHJvdyBcImlsbGVnYWwgcGx1Z2luIGRlZmluaXRpb24uXCI7IH1cblx0XHRcdHZhciBwcm9wTmFtZSA9IGNvbmZpZy5wcm9wTmFtZSxcblx0XHRcdFx0cHJpb3JpdHkgPSBjb25maWcucHJpb3JpdHkgfHwgMCxcblx0XHRcdFx0b3ZlcndyaXRlUHJvcHMgPSBjb25maWcub3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdG1hcCA9IHtpbml0OlwiX29uSW5pdFR3ZWVuXCIsIHNldDpcInNldFJhdGlvXCIsIGtpbGw6XCJfa2lsbFwiLCByb3VuZDpcIl9tb2RcIiwgbW9kOlwiX21vZFwiLCBpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LFxuXHRcdFx0XHRQbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlwiICsgcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zdWJzdHIoMSkgKyBcIlBsdWdpblwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdGVQcm9wcyB8fCBbXTtcblx0XHRcdFx0XHR9LCAoY29uZmlnLmdsb2JhbCA9PT0gdHJ1ZSkpLFxuXHRcdFx0XHRwID0gUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihwcm9wTmFtZSksXG5cdFx0XHRcdHByb3A7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gUGx1Z2luO1xuXHRcdFx0UGx1Z2luLkFQSSA9IGNvbmZpZy5BUEk7XG5cdFx0XHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoY29uZmlnW3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cFttYXBbcHJvcF1dID0gY29uZmlnW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRQbHVnaW4udmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uO1xuXHRcdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW1BsdWdpbl0pO1xuXHRcdFx0cmV0dXJuIFBsdWdpbjtcblx0XHR9O1xuXG5cblx0XHQvL25vdyBydW4gdGhyb3VnaCBhbGwgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGFuZCBpZiBhbnkgYXJlIG1pc3NpbmcsIGxvZyB0aGF0IHRvIHRoZSBjb25zb2xlIGFzIGEgd2FybmluZy4gVGhpcyBpcyB3aHkgaXQncyBiZXN0IHRvIGhhdmUgVHdlZW5MaXRlIGxvYWQgbGFzdCAtIGl0IGNhbiBjaGVjayBhbGwgdGhlIGRlcGVuZGVuY2llcyBmb3IgeW91LlxuXHRcdGEgPSB3aW5kb3cuX2dzUXVldWU7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGFbaV0oKTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiBfZGVmTG9va3VwKSB7XG5cdFx0XHRcdGlmICghX2RlZkxvb2t1cFtwXS5mdW5jKSB7XG5cdFx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKFwiR1NBUCBlbmNvdW50ZXJlZCBtaXNzaW5nIGRlcGVuZGVuY3k6IFwiICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7IC8vZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBvZmZpY2lhbCBhbmltYXRpb24gZm9yY2VzIGEgdGlja2VyLnRpY2soKSB0byB1cGRhdGUgdGhlIHRpbWUgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcblxufSkoKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LCBcIlR3ZWVuTWF4XCIpOyJdfQ==
